/**
 * @file cz_interface.cpp
 *
 * @date Oct 24, 2020
 * @author: Felix
 * @brief canzero interface file
 */
/** @addtogroup CANzero
  * @{
  */
//TODO implement all can callback functions (stm32f4xx_hal_can.h line 710)
#include <cz_interface.hpp>
#include <cz_processRx.hpp>
#include <stdio.h>
#include "led.h"
#include "log.h"
#include "canzero_defines.h"
#include "TaskManager.hpp"
#include "dbc_parser.hpp"


#ifdef USE_CAN_OVER_UART_INTERFACE
// To enable CAN over UART, you need to set the USE_CAN_OVER_UART_INTERFACE in the compiler flags.
#include "SerialPacketProtocol.hpp"

extern UART_HandleTypeDef huart2;
extern osMessageQId czReceiveQueue;

void sppPacketHandler(uint8_t* pData, uint16_t size) {
	CAN_RxHeaderTypeDef rxHeader = {0x00,0x00,CAN_ID_STD,CAN_RTR_DATA,0,0,0};
	rxHeader.StdId = (pData[0] & 0xFF) + ((pData[1] & 0xF) << 8);
	rxHeader.DLC = size - 2;

	RxMessage rxMsg;
	rxMsg.rxHeader = rxHeader;
	for(int i = 0; i < 8; i++) {
		rxMsg.rxBuf[i] = pData[i + 2];
	}

	if(osMessageQueuePut(czReceiveQueue, &rxMsg, 0, 0) != osOK){
		printDebugISR("czReceiveQueue full!\n");
	}
}

SerialPacketProtocol<32, 128> spp(&huart2, &sppPacketHandler);

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
	spp.UART_RxCpltCallback(huart);
}

#endif

cz_interface* cz_interface::canInterface = nullptr;


cz_interface::cz_interface() {
}

void cz_interface::init() {
	setStatus(cz_status::reset);
	// Check number of filters
	static_assert(can::filters::num_ext <= 14, "Number of CAN Ext-ID filter generated by dbc2cpp exceeds 14!");
	static_assert(can::filters::num_std <= 28, "Number of CAN Std-ID filter generated by dbc2cpp exceeds 28!");
	static_assert(can::filters::num_ext * 2 + can::filters::num_std <= 28, "Too many CAN filters configured by dbc2cpp!");
	static_assert(can::filters::num_ext != 0 || can::filters::num_std != 0, "No CAN filters were generated by dbc2cpp!");

	// Configure filters in 32-bit mode to receive Extended IDs (29-bit)
	for(int i = 0; i < can::filters::num_ext; i++) {
		CAN_FilterTypeDef sFilterConfig;
		sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
		sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;

		// A 29-bit ID consists of the 11-bit Base-ID (MSB) and 18-bit Sub-ID (LSB)
		// So STID[10:0] == EXID[28:18]

		// ID high consists of: STID[10:3] STID[2:0] EXID[17:13]  =>  so for us: id_ext[28:13]
		sFilterConfig.FilterIdHigh = ((can::filters::id_ext[i] & 0x1FFFE000ul) >> 13);

		// ID low consists of: EXID[12:5] EXID[4:0] IDE RTR 0  =>  so for us: id[23:11] 1 0 0
		sFilterConfig.FilterIdLow = ((can::filters::id_ext[i] & 0x1FFF) << 3) | 4;

		// Mask high consists of: STID[10:3] STID[2:0] EXID[17:13]  =>  so for us: mask_ext[28:13]
		sFilterConfig.FilterMaskIdHigh = ((can::filters::mask_ext[i] & 0x1FFFE000ul) >> 13);

		// Mask low consists of: EXID[12:5] EXID[4:0] IDE RTR 0  =>  so for us: mask[23:11] 1 1 0
		sFilterConfig.FilterMaskIdLow = ((can::filters::mask_ext[i] & 0x1FFF) << 3) | 6;


		// Alternate between receive FIFO0 and FIFO1 to fill both buffers.
		if ((i / 2) % 2 == 0) {
			sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
		} else {
			sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO1;
		}

		sFilterConfig.FilterActivation = ENABLE;
		sFilterConfig.SlaveStartFilterBank = 14;	// Filter 0-13 for CAN1, 14-27 for CAN2.

		// Configure the filter for both CAN1 and CAN2
		sFilterConfig.FilterBank = i;
		if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}

		sFilterConfig.FilterBank = 14 + i;
		if (HAL_CAN_ConfigFilter(&hcan2, &sFilterConfig) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}
	}


	// Configure filters in 16-bit mode to receive Standard IDs (11-bit)
	for(int i = 0; i < can::filters::num_std; i+=2) {
		CAN_FilterTypeDef sFilterConfig;
		sFilterConfig.FilterBank = can::filters::num_ext + i / 2;	// Each STM32 filterbank has two filters in 16-bit mode, so divide by 2.
		sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;

		// All values are shifted by 5 bits, because the internal layout is: STDID[10:0], RTR, IDE, EXID[17:15] for a 16-bit filter.
		sFilterConfig.FilterIdHigh = can::filters::id_std[i] << 5;
		sFilterConfig.FilterMaskIdHigh = (can::filters::mask_std[i] << 5) | 0x18;  // Set bit 3 and 4, so no remote frame and 11-bit ID.

		// If number of filters is odd, configure last filter in 32-bit mode.
		if (i == can::filters::num_std - 1) {
			// Odd number of filters and last filter.
			sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;

			sFilterConfig.FilterIdLow = 0;
			sFilterConfig.FilterMaskIdLow = 0x6; // Set bit 1 and 2, so ignore remote frames and only receive standard-ID frames
		} else {
			// Even number of filters or odd number and not last filter.
			sFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;

			sFilterConfig.FilterIdLow = can::filters::id_std[i+1] << 5;
			sFilterConfig.FilterMaskIdLow = (can::filters::mask_std[i+1] << 5) | 0x18;  // Set bit 3 and 4, so only receive standard-ID frames and ignore remote frames
		}

		// Alternate between receive FIFO0 and FIFO1 to fill both buffers.
		if ((i / 2) % 2 == 0) {
			sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
		} else {
			sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO1;
		}

		sFilterConfig.FilterActivation = ENABLE;
		sFilterConfig.SlaveStartFilterBank = 14;	// Filter 0-13 for CAN1, 14-27 for CAN2.

		// Configure the filter for both CAN1 and CAN2
		if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}

		sFilterConfig.FilterBank = 14 + can::filters::num_ext + i / 2;
		if (HAL_CAN_ConfigFilter(&hcan2, &sFilterConfig) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}
	}

	if (HAL_CAN_Start(&hcan1) != HAL_OK || HAL_CAN_Start(&hcan2) != HAL_OK) {
		Error_Handler(); /* Start Error */
	}
	if (HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING)!= HAL_OK
			|| HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO1_MSG_PENDING)!= HAL_OK
			|| HAL_CAN_ActivateNotification(&hcan1, CAN_IT_ERROR_PASSIVE)!=HAL_OK) {
		Error_Handler();
	}

	if (HAL_CAN_ActivateNotification(&hcan2, CAN_IT_RX_FIFO0_MSG_PENDING)!= HAL_OK
			|| HAL_CAN_ActivateNotification(&hcan2, CAN_IT_RX_FIFO1_MSG_PENDING)!= HAL_OK
			|| HAL_CAN_ActivateNotification(&hcan2, CAN_IT_ERROR_PASSIVE)!=HAL_OK) {
		Error_Handler();
	}
}

void cz_interface::setFilter(unsigned int canModule, CAN_FilterTypeDef canFilter) {
	printDebug("setting new Filters\n");
	if (canModule == 1) {
		if (HAL_CAN_Stop(&hcan1) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}
		sFilterConfig1 = canFilter;
		if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig1) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}
		if (HAL_CAN_Start(&hcan1) != HAL_OK) {
			Error_Handler(); /* Start Error */
		}
	} else if (canModule == 2) {
		if (HAL_CAN_Stop(&hcan2) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}
		sFilterConfig2 = canFilter;
		if (HAL_CAN_ConfigFilter(&hcan2, &sFilterConfig1) != HAL_OK) {
			Error_Handler(); /* Filter configuration Error */
		}
		if (HAL_CAN_Start(&hcan2) != HAL_OK) {
			Error_Handler(); /* Start Error */
		}
	} else {
		//printDebug("Error in cz_interface: hcanModule %u not supported",
		//		canModule);
		return;
	}
}

cz_status cz_interface::getStatus() {
	extern osMutexId_t nodeStateMutex;
	osMutexAcquire(nodeStateMutex, osWaitForever);
	cz_status returnValue = (cz_status) nodeStatus;
	osMutexRelease(nodeStateMutex);
	return returnValue;
}

void cz_interface::setStatus(cz_status new_status){
	extern osMutexId_t nodeStateMutex;
	osMutexAcquire(nodeStateMutex, osWaitForever);
	nodeStatus = new_status;
	osMutexRelease(nodeStateMutex);
}

void cz_interface::cz_send(void* params){
	extern osMessageQId czSendQueue;
	TxMessage sendMessage;

#ifndef USE_CAN_OVER_UART_INTERFACE
	uint32_t TxMailbox;
	CAN_HandleTypeDef* hcanModule;
#endif

	while(1){
		if(osMessageQueueGet(czSendQueue,&sendMessage,NULL,osWaitForever) != osOK){
			while(1);
		}
		if(sendMessage.txHeader.DLC>8){
			while(1);
		}

		// Extract the bus flag from the RTR field and then clear the flag bits
		can::CAN_BusTypeDef canBus = sendMessage.txHeader.RTR & can::buses::mask;
		sendMessage.txHeader.RTR &= ~(can::buses::mask);

		if(canBus == can::buses::BUS1) {
			hcanModule = &hcan1;
		} else if(canBus == can::buses::BUS2) {
			hcanModule = &hcan2;
		} else {
			// Decide on the ID
			if (sendMessage.txHeader.StdId % 2 == 0){
				hcanModule = &hcan1;
			} else{
				hcanModule = &hcan2;
			}
		}

#ifdef USE_CAN_OVER_UART_INTERFACE
		spp.sendCANMessage(sendMessage);
#endif

#ifndef USE_CAN_OVER_UART_INTERFACE

		// If there is a mailbox free on the requested CAN, just send the message
		if(HAL_CAN_GetTxMailboxesFreeLevel(hcanModule) > 0) {
			if (HAL_CAN_AddTxMessage(hcanModule, &sendMessage.txHeader, sendMessage.txBuf, &TxMailbox) != HAL_OK) {
				/* Transmission request Error */
				Error_Handler();
			}
		} else {	// No mailbox free on requested CAN bus
			// Count delayed messages
			if(hcanModule == &hcan1) {
				OD_CAN1_DelayedTxMessages++;
			} else {
				OD_CAN2_DelayedTxMessages++;
			}

			osDelay(1);		// Use smallest delay possible

			// Try again
			if(HAL_CAN_GetTxMailboxesFreeLevel(hcanModule) > 0) {
				if (HAL_CAN_AddTxMessage(hcanModule, &sendMessage.txHeader, sendMessage.txBuf, &TxMailbox) != HAL_OK) {
					/* Transmission request Error */
					Error_Handler();
				}
			} else {
				// Discard message
				if(hcanModule == &hcan1) {
					OD_CAN1_DiscardedTxMessages++;
				} else {
					OD_CAN2_DiscardedTxMessages++;
				}

				//printDebug("Discarded TX message with ID %lu !!\n", sendMessage.txHeader.StdId);
			}
		}
#endif

	}
}


void cz_interface::cz_receive(void *params) {
	extern osMessageQId czReceiveQueue;


	RxMessage message;

#ifdef USE_CAN_OVER_UART_INTERFACE
	spp.startReceiving();
#endif

#ifndef USE_CAN_OVER_UART_INTERFACE
	cz_interface::getInstance()->init();
#endif

	while (1) {
		osMessageQueueGet(czReceiveQueue, (void*) &message, NULL, osWaitForever);

		// LED_RGB_Write(message.rxBuf[0], message.rxBuf[1], message.rxBuf[2]);

		/*printDebug("received on ID %x:", (unsigned int) message.rxHeader.StdId);
		for (unsigned int i = 0; i < message.rxHeader.DLC; i++) {
			printDebug(" %u", message.rxBuf[i]);
		}
		printDebug("\n");*/

		if (message.rxHeader.RTR == CAN_RTR_DATA) {
			if(can::checkRxMessage<can::messages::CANZERO_BTL_RX>(message)) {
				if(message.rxBuf[0]==0xff) {
					NVIC_SystemReset();
				}
			} else if(can::checkRxMessage<can::messages::CANZERO_SDO_Req_Up>(message)) {
				handleSDORequestUpload(message);
			} else if(can::checkRxMessage<can::messages::CANZERO_SDO_Req_Down>(message)) {
				handleSDORequestDownload(message);
			} else {
				processRX(message);
			}
		} else if (message.rxHeader.RTR == CAN_RTR_REMOTE) {
			printDebug("RTR must not be used!\n");
		}
	}
}
cz_interface* cz_interface::getInstance(){

	if(canInterface==nullptr){
		canInterface = new cz_interface();
	}
	return canInterface;
}
cz_interface::~cz_interface() {

}
/**
 * @}
 */
