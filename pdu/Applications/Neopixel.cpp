/*
 * Neopixel.cpp
 *
 *  Created on: 26 Jun 2023
 *      Author: karl
 */
/**
 * the NEOPIXEL_DRIVER doesn't use continous DMA and requires different configuration.
 */
//#define USE_NEOPIXEL_DRIVER

#include "FreeRTOS.h"
#include "cmsis_os.h"
#include "Neopixel.hpp"
#include <cinttypes>
#include "tim.h"
#include "estdio.hpp"
#include "WS2812BDriver.hpp"
#include "dma.h"
#include "main.h"
#include <stdlib.h>


/**
 * has to be defined this way because the autogenerated solution is in a c file.
 */
namespace neopixel {

constexpr uint16_t MIN_RESET_BITS = 48;
constexpr uint16_t LED_LOGIC_ZERO = 33;
constexpr uint16_t LED_LOGIC_ONE = 67;

static TIM_HandleTypeDef* m_tim;
static uint16_t m_channel;
static uint16_t m_numberOfLeds;

static uint16_t* m_pwmBuffer;
static uint32_t m_pwmBufferCount;
static color_t* m_colorBuffer;
static osSemaphoreId_t m_sem;

void init(TIM_HandleTypeDef* tim, uint16_t channel, uint16_t numberOfLeds){
	m_tim = tim;
	m_channel = channel;
	m_numberOfLeds = numberOfLeds;
	m_pwmBufferCount = numberOfLeds * 24 + MIN_RESET_BITS;
	m_pwmBuffer = reinterpret_cast<uint16_t*>(calloc(m_pwmBufferCount, sizeof(uint16_t)));
	m_colorBuffer = reinterpret_cast<color_t*>(calloc(numberOfLeds, sizeof(color_t)));
	m_sem = osSemaphoreNew(1, 1, NULL);
}

void dispose(){
	free(m_pwmBuffer);
	free(m_colorBuffer);
}

void set(uint16_t index, color_t color){
	m_colorBuffer[index] = color;
}

void set(uint16_t start, uint16_t end, color_t color){
	if(start > end){
		uint16_t tmp = start;
		start = end;
		end = tmp;
	}
	for(size_t i = start; i <= end; i++){
		m_colorBuffer[i] = color;
	}
}

void setAll(color_t color){
	for(size_t i = 0; i < m_numberOfLeds; i++){
		m_colorBuffer[i] = color;
	}
}




void update(){
	osSemaphoreAcquire(neopixel::m_sem, pdMS_TO_TICKS(50));
	//calculate dma buffer.
	for(size_t i = 0; i < m_numberOfLeds; i++){
		for(size_t bit = 0; bit < 8; bit++){
			m_pwmBuffer[i*24 + 0  + bit] = (m_colorBuffer[i].g & (0x80 >> bit)) ? LED_LOGIC_ONE : LED_LOGIC_ZERO;
			m_pwmBuffer[i*24 + 8  + bit] = (m_colorBuffer[i].r & (0x80 >> bit)) ? LED_LOGIC_ONE : LED_LOGIC_ZERO;
			m_pwmBuffer[i*24 + 16  + bit] = (m_colorBuffer[i].b & (0x80 >> bit)) ? LED_LOGIC_ONE : LED_LOGIC_ZERO;
		}
	}
	for(size_t i = 0; i < MIN_RESET_BITS; i++){
		m_pwmBuffer[m_numberOfLeds * 24 + i] = 0;
	}
	HAL_TIM_PWM_Start_DMA(m_tim, m_channel, reinterpret_cast<uint32_t*>(m_pwmBuffer), m_pwmBufferCount);
}

}


void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim) {
	HAL_TIM_PWM_Stop_DMA(&htim3, TIM_CHANNEL_1);
	osSemaphoreRelease(neopixel::m_sem);
}
