/* DO NOT MODIFY. THIS FILE WAS GENERATED AUTOMATICALLY BY DBC2CPP V1.7.7.
 * 
 * This header file was generated from 'pod2023_gen.dbc' on 14:35:37 18.05.2023.
 * It contains all messages and signals as well as value tables and attributes of the DBC file.
 * The STM32 template was used to generate code for STM32 microcontrollers.
 *
 * Florian Keck
 * florian.keck@mu-zero.de
 * Copyright 2023, mu-zero HYPERLOOP e.V.
 */
#ifndef DBCPARSER_POD2022_HPP
#define DBCPARSER_POD2022_HPP

#pragma once

#include <stdint.h>
#include <cmath>
#include "stm32f4xx_hal.h"
#include "typedefinitions.h"
#include "log.h"
extern osMessageQueueId_t czSendQueue;
extern osMessageQueueId_t czReceiveQueue;


// This is needed for the Windows State Machine Simulation Framework (SMSF)
// std::round() is not a constexpr function and the windows compiler throws an error
// Further investigation needed, why ARM-GCC has no problem with it?!
#ifndef _WIN32
#define STD_ROUND std::round
#else
constexpr float custom_round(float x) {
    if(x > 0.0) {
        return x + 0.5;
    } else {
        return x - 0.5;
    }
}
#define STD_ROUND custom_round
#endif


namespace can {

    /**************************************************************************
    * Calculated mask and id for receive fiter.                               *
    ***************************************************************************/
    namespace filters {
        constexpr uint8_t num_ext = 5;      // Number of used receive filters for extended (29-bit) ID messages
        constexpr uint32_t mask_ext[5] = {   // Filter mask for extended (29-bit) ID messages
            0x1FFFFFFF,            0x1FFFFCFE,            0x1FFFFFF8,            0x1FFFFFC0, 
            0x1FFFF0F0 
        };
        constexpr uint32_t id_ext[5] = {     // Filter ID for extended (29-bit) ID messages
            0x10ECE0,            0x19B50010,            0x1FFFFFF8,            0x1FFF0000, 
            0x19B50000 
        };

        constexpr uint8_t num_std = 18;      // Number of used receive filters for standard (11-bit) ID messages
        constexpr uint32_t mask_std[18] = {   // Filter mask for standard (11-bit) ID messages
            0x7FE,            0x7F9,            0x3AF,            0x7F8, 
            0x3EE,            0x57C,            0x6B5,            0x6CE, 
            0x68D,            0x03B,            0x2AD,            0x647, 
            0x496,            0x00F,            0x037,            0x62C, 
            0x036,            0x007 
        };
        constexpr uint32_t id_std[18] = {     // Filter ID for standard (11-bit) ID messages
            0x07A,            0x621,            0x100,            0x5E0, 
            0x362,            0x000,            0x411,            0x202, 
            0x480,            0x023,            0x0A1,            0x201, 
            0x400,            0x001,            0x011,            0x420, 
            0x020,            0x002 
        };
    }

    /**************************************************************************
    * Buses used to send a CAN message on a specific bus.                     *
    * We use the upper 16-bits of the RTR field of CAN_TxHeaderTypeDef to     *
    * transmit the information on which bus a message should be send.         *
    ***************************************************************************/
    typedef uint32_t CAN_BusTypeDef;
    namespace buses {
        constexpr uint32_t mask = 0xFFFF0000;
        constexpr uint32_t shift = 16;

        // Let the CANzero interface decide on which bus this message will be transmitted
        constexpr CAN_BusTypeDef ANY = (0 << shift);

        // Send message on CAN1
        constexpr CAN_BusTypeDef BUS1 = (1 << shift);

        // Send message on CAN2
        constexpr CAN_BusTypeDef BUS2 = (2 << shift);
    }

    /**************************************************************************
    * Function to check which message was received.                           *
    * It supports standard (11-bit) and extended (29-bit) IDs.                *
    ***************************************************************************/
    template <class MESSAGE>
    inline bool checkRxMessage(const RxMessage& message) {
        if (message.rxHeader.IDE == CAN_ID_STD) {
            return (MESSAGE::isExtendedId == false) && (message.rxHeader.StdId == MESSAGE::id);
        } else {
            return (MESSAGE::isExtendedId == true) && (message.rxHeader.ExtId == MESSAGE::id);
        }
    }

        
    /**********************************************************************************************
    * MessageInfo struct, Message class and help functions.                                       *
    ***********************************************************************************************/
    // Function to check if a signal belongs to a message.
    constexpr bool checkIfSignalBelongsToMessage(uint32_t msgId, const uint32_t sigIds[], uint8_t numIds) {
        if (numIds == 0) {
            return true;
        }
        for (int i = 0; i < numIds; i++) {
            if(sigIds[i] == msgId) {
                return true;
            }
        }
        return false;
    }

    // MessageInfo struct holds information about a message.
    /*
    class MessageInfo {
        public:
        const uint32_t id;
        const uint8_t dlc;

        ~MessageInfo() = default;
        constexpr MessageInfo() : id {0}, dlc {0} {}
        constexpr MessageInfo(uint32_t _id, uint8_t _dlc) : id {_id}, dlc{_dlc} {}
    };
    */

    // Using a base class that holds all common function reduces flash usage
    // Otherwise, each function would be in the flash once per used message type, because class templates are used
    class MessageBase {
    public:
        const uint32_t id;
        uint8_t dlc;
        const bool isExtendedId;
        uint64_t intel;
        uint64_t motorola;

        MessageBase(uint32_t _id, uint8_t _dlc, bool _isExt) : id{_id}, dlc{_dlc}, isExtendedId{_isExt}, intel{0}, motorola{0} {}

        MessageBase(uint32_t _id, uint8_t _dlc, bool _isExt, const uint8_t rxBuf[8]) noexcept : id{_id}, dlc{_dlc}, isExtendedId{_isExt} {
            // Using bitshift instead of memcpy because in this way the code does not depend on the endianess of the used microcontroller
            intel = static_cast<uint32_t>(rxBuf[0]) + (static_cast<uint32_t>(rxBuf[1]) << 8) + (static_cast<uint32_t>(rxBuf[2]) << 16) + (static_cast<uint32_t>(rxBuf[3]) << 24);
            intel += (static_cast<uint64_t>(rxBuf[4]) << 32) + (static_cast<uint64_t>(rxBuf[5]) << 40);
            intel += (static_cast<uint64_t>(rxBuf[6]) << 48) + (static_cast<uint64_t>(rxBuf[7]) << 56);
            motorola = static_cast<uint32_t>(rxBuf[7]) + (static_cast<uint32_t>(rxBuf[6]) << 8) + (static_cast<uint32_t>(rxBuf[5]) << 16) + (static_cast<uint32_t>(rxBuf[4]) << 24);
            motorola += (static_cast<uint64_t>(rxBuf[3]) << 32) + (static_cast<uint64_t>(rxBuf[2]) << 40);
            motorola += (static_cast<uint64_t>(rxBuf[1]) << 48) + (static_cast<uint64_t>(rxBuf[0]) << 56);
        };
        ~MessageBase() = default;

        // Reset internal buffers
        void clear() noexcept {
            intel = 0;
            motorola = 0;
        }

        // Convert message to data buffer
        void toBuf(uint8_t txBuf[8]) const noexcept {
            txBuf[0] = (intel & 0xFF) | ((motorola >> 56) & 0xFF);
            txBuf[1] = ((intel >> 8) & 0xFF) | ((motorola >> 48) & 0xFF);
            txBuf[2] = ((intel >> 16) & 0xFF) | ((motorola >> 40) & 0xFF);
            txBuf[3] = ((intel >> 24) & 0xFF) | ((motorola >> 32) & 0xFF);
            txBuf[4] = ((intel >> 32) & 0xFF) | ((motorola >> 24) & 0xFF);
            txBuf[5] = ((intel >> 40) & 0xFF) | ((motorola >> 16) & 0xFF);
            txBuf[6] = ((intel >> 48) & 0xFF) | ((motorola >> 8) & 0xFF);
            txBuf[7] = ((intel >> 56) & 0xFF) | (motorola & 0xFF);
        }


        // Convert message to STM32 CAN_TxHeaderTypeDef and txBuf
        void toBuf(CAN_TxHeaderTypeDef& txHeader, uint8_t txBuf[8], CAN_BusTypeDef bus = buses::ANY) const noexcept {
            if(isExtendedId) {
                txHeader.StdId = 0;
                txHeader.ExtId = id;
                txHeader.IDE = CAN_ID_EXT;
            } else {
                txHeader.StdId = id;
                txHeader.ExtId = 0;
                txHeader.IDE = CAN_ID_STD;
            }
            txHeader.RTR = bus + CAN_RTR_DATA; // Upper 16-bit contain bus. Lower 16-bit contain RTR
            txHeader.DLC = dlc;
            txHeader.TransmitGlobalTime = DISABLE;
            txBuf[0] = (intel & 0xFF) | ((motorola >> 56) & 0xFF);
            txBuf[1] = ((intel >> 8) & 0xFF) | ((motorola >> 48) & 0xFF);
            txBuf[2] = ((intel >> 16) & 0xFF) | ((motorola >> 40) & 0xFF);
            txBuf[3] = ((intel >> 24) & 0xFF) | ((motorola >> 32) & 0xFF);
            txBuf[4] = ((intel >> 32) & 0xFF) | ((motorola >> 24) & 0xFF);
            txBuf[5] = ((intel >> 40) & 0xFF) | ((motorola >> 16) & 0xFF);
            txBuf[6] = ((intel >> 48) & 0xFF) | ((motorola >> 8) & 0xFF);
            txBuf[7] = ((intel >> 56) & 0xFF) | (motorola & 0xFF);
        }

        // Convert message to CANzero TxMessage by reference
        void toBuf(TxMessage& txMsg, CAN_BusTypeDef bus = buses::ANY) const noexcept {
            toBuf(txMsg.txHeader, txMsg.txBuf, bus);
        }

        // Convert message to CANzero TxMessage and return created struct
        TxMessage getTxMessage(CAN_BusTypeDef bus = buses::ANY) const noexcept {
            TxMessage txMsg;
            toBuf(txMsg.txHeader, txMsg.txBuf, bus);
            return txMsg;
        }

        // Use this function to send a message over the queue to the CAN bus
        void send(CAN_BusTypeDef bus = buses::ANY) const noexcept {
            TxMessage sendTxMessage = getTxMessage(bus);
            if(osMessageQueuePut(czSendQueue, &sendTxMessage, 0, 0) != osOK) {
                printDebug("Failed sending message %lu because queue is full!\n", sendTxMessage.txHeader.StdId);
            }
        }

        // Send message and loop it back to receive queue to receive it from another thread in the same ECU
        void sendAndLoopback(CAN_BusTypeDef bus = buses::ANY) const noexcept {
            // Normal send over CAN
            TxMessage sendTxMessage = getTxMessage(bus);
            if(osMessageQueuePut(czSendQueue, &sendTxMessage, 0, 0) != osOK) {
                printDebug("Failed sending message %lu because queue is full!\n", sendTxMessage.txHeader.StdId);
            }

            // Loop message back to receive queue
            RxMessage sendRxMessage;
            sendRxMessage.rxHeader.StdId = sendTxMessage.txHeader.StdId;
            sendRxMessage.rxHeader.ExtId = sendTxMessage.txHeader.ExtId;
            sendRxMessage.rxHeader.IDE = sendTxMessage.txHeader.IDE;
            sendRxMessage.rxHeader.RTR = sendTxMessage.txHeader.RTR;
            sendRxMessage.rxHeader.DLC = sendTxMessage.txHeader.DLC;
            sendRxMessage.rxHeader.Timestamp = 0;
            sendRxMessage.rxHeader.FilterMatchIndex = 0;
            sendRxMessage.rxBuf[0] = sendTxMessage.txBuf[0];
            sendRxMessage.rxBuf[1] = sendTxMessage.txBuf[1];
            sendRxMessage.rxBuf[2] = sendTxMessage.txBuf[2];
            sendRxMessage.rxBuf[3] = sendTxMessage.txBuf[3];
            sendRxMessage.rxBuf[4] = sendTxMessage.txBuf[4];
            sendRxMessage.rxBuf[5] = sendTxMessage.txBuf[5];
            sendRxMessage.rxBuf[6] = sendTxMessage.txBuf[6];
            sendRxMessage.rxBuf[7] = sendTxMessage.txBuf[7];
            osMessageQueuePut(czReceiveQueue, &sendRxMessage, 0, 0);
        }
    };

    // Message class, container for getting and setting signals.
    template <class MESSAGE_T>
    class Message: public MessageBase {
    public:

        ~Message() noexcept = default;

        // Constructor for sending a message
        constexpr Message() : MessageBase{MESSAGE_T::id, MESSAGE_T::dlc, MESSAGE_T::isExtendedId} {}

        // Constructor for receiving a message with a buffer
        constexpr Message(const uint8_t rxBuf[8]) : MessageBase{MESSAGE_T::id, MESSAGE_T::dlc, MESSAGE_T::isExtendedId, rxBuf} {}

        // Constructor for receiving a message with STM CAN_RxHeaderTypeDef and buffer
        constexpr Message(const CAN_RxHeaderTypeDef& rxHeader, const uint8_t rxBuf[8]) noexcept : MessageBase{MESSAGE_T::id, MESSAGE_T::dlc, MESSAGE_T::isExtendedId, rxBuf} {
            // Check if ID matches
            if(MESSAGE_T::isExtendedId) {
                if (rxHeader.ExtId != MESSAGE_T::id) {
                    while(1);
                }
            } else {
                if (rxHeader.StdId != MESSAGE_T::id) {
                    while(1);
                }
            }
        };

        // Constructor for receiving a message with CANzero RxMessage
        constexpr Message(const RxMessage& rxMsg) noexcept : Message{rxMsg.rxHeader, rxMsg.rxBuf} {}

        // Templated function to set a signal to a message
        template <class T>
        void set(typename T::dataType value) {
            static_assert(checkIfSignalBelongsToMessage(MESSAGE_T::id, T::ids, T::numIds), "Cannot set signal because it is not part of the message!");
            T::set(intel, motorola, dlc, value);
        }

        // Templated function to get a signal from a message
        template <class T>
        typename T::dataType get() {
            static_assert(checkIfSignalBelongsToMessage(MESSAGE_T::id, T::ids, T::numIds), "Cannot get signal because it is not part of the message!");
            return T::get(intel, motorola);
        }
    };

    /**********************************************************************************************
    * Signed converters for converting signed signals.                                            *
    ***********************************************************************************************/
    struct SignedConverter8Bits {
        int8_t value : 8;
    };
    struct SignedConverter12Bits {
        int16_t value : 12;
    };
    struct SignedConverter14Bits {
        int16_t value : 14;
    };
    struct SignedConverter15Bits {
        int16_t value : 15;
    };
    struct SignedConverter16Bits {
        int16_t value : 16;
    };
    struct SignedConverter18Bits {
        int32_t value : 18;
    };
    struct SignedConverter20Bits {
        int32_t value : 20;
    };
    struct SignedConverter24Bits {
        int32_t value : 24;
    };

    /**********************************************************************************************
    * Network nodes with attributes                                                               *
    ***********************************************************************************************/
    namespace nodes {
        namespace Bat1 {
            constexpr char comment[] = "";
        }
        namespace OpticalSensor {
            constexpr char comment[] = "Kistler SFP-II optical Sensor.";
        }
        namespace EMUS_BMS {
            constexpr char comment[] = "HV BMS ";
        }
        namespace SCIMO_PE {
            constexpr char comment[] = "";
        }
        namespace TelemetryNode {
            constexpr char comment[] = "Gateway between Pod and Telemetry Node-ID 0x22Gateway between Pod and Telemetry Node-ID 0x22";

            // Attributes of node 'TelemetryNode'
            constexpr uint8_t CANzero_NodeID = 34;
        }
        namespace Master {
            constexpr char comment[] = "CANzero NMT Master Node.";
        }
        namespace SensorF {
            constexpr char comment[] = "SensorECU Node-ID 0x1";

            // Attributes of node 'SensorF'
            constexpr uint8_t CANzero_NodeID = 1;
        }
        namespace SensorR {
            constexpr char comment[] = "SensorECUR Node-ID 0x2";

            // Attributes of node 'SensorR'
            constexpr uint8_t CANzero_NodeID = 2;
        }
        namespace BrakeF {
            constexpr char comment[] = "BrakeECU Front Node-ID 0x11";

            // Attributes of node 'BrakeF'
            constexpr uint8_t CANzero_NodeID = 17;
        }
        namespace BrakeR {
            constexpr char comment[] = "BrakeECUR Node-ID 0x12";

            // Attributes of node 'BrakeR'
            constexpr uint8_t CANzero_NodeID = 18;
        }
        namespace PDU {
            constexpr char comment[] = "PowerD Node-ID 0x1A";

            // Attributes of node 'PDU'
            constexpr uint8_t CANzero_NodeID = 26;
        }
        namespace HVCU {
            constexpr char comment[] = "HVController Node-ID 0xA";

            // Attributes of node 'HVCU'
            constexpr uint8_t CANzero_NodeID = 10;
        }
        namespace HVTU {
            constexpr char comment[] = "High Voltage CAN Translation Unit between BMS and Pod Node-ID 0x19";

            // Attributes of node 'HVTU'
            constexpr uint8_t CANzero_NodeID = 25;
        }
        namespace TestBench {
            constexpr char comment[] = "";
        }
        namespace MDB1 {
            constexpr char comment[] = "ModularLevitationUnit-1 Node-ID 0x21";

            // Attributes of node 'MDB1'
            constexpr uint8_t CANzero_NodeID = 33;
        }
        namespace MDB2 {
            constexpr char comment[] = "ModularLevitationUnit-2 Node-ID 0x23";

            // Attributes of node 'MDB2'
            constexpr uint8_t CANzero_NodeID = 35;
        }
        namespace MDB3 {
            constexpr char comment[] = "ModularLevitationUnit-3 Node-ID 0x27";

            // Attributes of node 'MDB3'
            constexpr uint8_t CANzero_NodeID = 39;
        }
        namespace MDB4 {
            constexpr char comment[] = "ModularLevitationUnit-4 Node-ID 0x28";

            // Attributes of node 'MDB4'
            constexpr uint8_t CANzero_NodeID = 40;
        }
        namespace MDB5 {
            constexpr char comment[] = "ModularLevitationUnit-5 Node-ID 0x29";

            // Attributes of node 'MDB5'
            constexpr uint8_t CANzero_NodeID = 41;
        }
        namespace MDB6 {
            constexpr char comment[] = "ModularLevitationUnit-6 Node-ID 0x31";

            // Attributes of node 'MDB6'
            constexpr uint8_t CANzero_NodeID = 49;
        }
        namespace Track {
            constexpr char comment[] = "TrackECU Node-ID 0x32";

            // Attributes of node 'Track'
            constexpr uint8_t CANzero_NodeID = 50;
        }
    }
    
    /**********************************************************************************************
    * Attribute definitions (only ENUM attributes need extra definition)                          *
    ***********************************************************************************************/
    enum class GenSigSendType_t {
        CYCLIC,
        ONWRITE,
        ONWRITEWITHREPETITION,
        ONCHANGE,
        ONCHANGEWITHREPETITION,
        IFACTIVE,
        IFACTIVEWITHREPETITION,
        NOSIGSENDTYPE
    };
    enum class GenMsgSendType_t {
        CYCLIC,
        NOT_USED,
        NOT_USED_01,
        NOT_USED_02,
        NOT_USED_03,
        CYCLIC_01,
        NOT_USED_04,
        IFACTIVE,
        NOMSGSENDTYPE
    };
    enum class CANzero_SDO_AccessIfOperational_t {
        NO,
        YES
    };
    enum class CANzero_SDO_AccessType_t {
        READ_WRITE,
        READ_ONLY,
        WRITE_ONLY
    };


    /**********************************************************************************************
    * Network attributes                                                                          *
    ***********************************************************************************************/
    constexpr char CANzero_NMTMasterName[] = "Master";
    constexpr char CANzero_SDOClientName[] = "TelemetryNode";
    constexpr uint32_t CANzero_DBCVersion = 178;
    constexpr char CANzero_ProtocolVersion[] = "V1.0";
    constexpr char BusType[] = "CAN";
    constexpr char DBName[] = "pod2022";
    
    /**********************************************************************************************
    * Namespace containing all signals with their value tables and attributes                     *
    ***********************************************************************************************/
    namespace signals {
        class Track_TX_Response {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class Track_RX_Command {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class TEST_GROUND_STATION_COMMAND {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x200 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class MDB_Id {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x100 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class MDB_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x100 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class OpticalSensor_TX_VelLong {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFB };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(400);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.036f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFFull));
                return value * (0.036f);
            }
        };
        class OpticalSensor_TX_VelTrans {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFB };
            constexpr static float min = static_cast<float>(-200);
            constexpr static float max = static_cast<float>(200);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.036f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.036f);
            }
        };
        class OpticalSensor_TX_Angle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFB };
            constexpr static float min = static_cast<float>(-45);
            constexpr static float max = static_cast<float>(45);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.01f);
            }
        };
        class OpticalSensor_TX_Timestamp {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFFull));
                return value;
            }
        };
        class OpticalSensor_TX_Vel {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(400);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.036f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.036f);
            }
        };
        class OpticalSensor_TX_Distance {
            public:
            using dataType = double;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFA };
            constexpr static double min = static_cast<double>(0);
            constexpr static double max = static_cast<double>(4294970);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, double value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint32_t rawValue = static_cast<uint32_t>(STD_ROUND((value) / (0.001)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFFFFFF00000000ull;
            }
            constexpr static inline double get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF00000000ull) >> 32);
                return value * (0.001);
            }
        };
        class OpticalSensor_TX_SerialNo {
            public:
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFFFull;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFull));
                return value;
            }
        };
        class OpticalSensor_TX_SensorNo {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class OpticalSensor_TX_Temp {
            public:
            using dataType = int8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int8_t value) noexcept {
                int8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int8_t value = static_cast<int8_t>((intel & 0xFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter8Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class OpticalSensor_TX_LEDCurrent {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(2.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f);
            }
        };
        class OpticalSensor_TX_STST {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0x1000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000000000ull) >> 48);
                return value;
            }
        };
        class OpticalSensor_TX_SelfTest {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 49) & 0x2000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000000000000ull) >> 49);
                return value;
            }
        };
        class OpticalSensor_TX_SensorOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 50) & 0x4000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000000000000ull) >> 50);
                return value;
            }
        };
        class OpticalSensor_TX_TempOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 51) & 0x8000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000000000000ull) >> 51);
                return value;
            }
        };
        class OpticalSensor_TX_OpticOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 52) & 0x10000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000000000000ull) >> 52);
                return value;
            }
        };
        class OpticalSensor_TX_CurrentLowHigh {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 53) & 0x20000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000000000000ull) >> 53);
                return value;
            }
        };
        class OpticalSensor_TX_CurrentOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 54) & 0x40000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000000000000ull) >> 54);
                return value;
            }
        };
        class OpticalSensor_TX_PowerOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 55) & 0x80000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80000000000000ull) >> 55);
                return value;
            }
        };
        class OpticalSensor_TX_LED_Cal {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0x100000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100000000000000ull) >> 56);
                return value;
            }
        };
        class OpticalSensor_TX_LEDStatus {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 57) & 0x600000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x600000000000000ull) >> 57);
                return value;
            }

            // Value table of signal 'OpticalSensor_TX_LEDStatus'
            constexpr static uint8_t OFF = 0;
            constexpr static uint8_t ON = 1;
            constexpr static uint8_t FLASH = 2;
        };
        class OpticalSensor_TX_V25OK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 59) & 0x800000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800000000000000ull) >> 59);
                return value;
            }
        };
        class OpticalSensor_TX_V33OK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 60) & 0x1000000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000000000000ull) >> 60);
                return value;
            }
        };
        class OpticalSensor_TX_VeeOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 61) & 0x2000000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000000000000000ull) >> 61);
                return value;
            }
        };
        class OpticalSensor_TX_VddOK {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1FFFFFFC };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 62) & 0x4000000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000000000000000ull) >> 62);
                return value;
            }
        };
        class CANzero_NMT_State {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFFull));
                return value;
            }

            // Value table of signal 'CANzero_NMT_State'
            constexpr static uint16_t START_REMOTE_NODE = 1;
            constexpr static uint16_t STOP_REMOTE_NODE = 2;
            constexpr static uint16_t ENTER_PREOPERATIONAL = 128;
            constexpr static uint16_t RESET = 129;
        };
        class CANzero_NMT_Node {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(63);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'CANzero_NMT_Node'
            constexpr static uint16_t ALL = 0;
            constexpr static uint16_t SENSORF = 1;
            constexpr static uint16_t SENSORR = 2;
            constexpr static uint16_t HVCU = 10;
            constexpr static uint16_t BRAKEF = 17;
            constexpr static uint16_t BRAKER = 18;
            constexpr static uint16_t HVTU = 25;
            constexpr static uint16_t PDU = 26;
            constexpr static uint16_t MDB1 = 33;
            constexpr static uint16_t TELEMETRYNODE = 34;
            constexpr static uint16_t MDB2 = 35;
            constexpr static uint16_t MDB3 = 39;
            constexpr static uint16_t MDB4 = 40;
            constexpr static uint16_t MDB5 = 41;
            constexpr static uint16_t MDB6 = 49;
            constexpr static uint16_t TRACK = 50;
        };
        class SensorF_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'SensorF_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorF_W1_StateMTransitionW {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'SensorF_W1_StateMTransitionW'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorF_W2_encoderOORWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'SensorF_W2_encoderOORWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorF_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'SensorF_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E1_StateMTransitionE {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'SensorF_E1_StateMTransitionE'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E2_BrakeFTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'SensorF_E2_BrakeFTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E3_BrakeRTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'SensorF_E3_BrakeRTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E4_PDUTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_E4_PDUTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E5_HVCUTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }

            // Value table of signal 'SensorF_E5_HVCUTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E6_SensorRTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0x40000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000ull) >> 18);
                return value;
            }

            // Value table of signal 'SensorF_E6_SensorRTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E7_TelemetryTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 19) & 0x80000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80000ull) >> 19);
                return value;
            }

            // Value table of signal 'SensorF_E7_TelemetryTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E8_NodeErrorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 20) & 0x100000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100000ull) >> 20);
                return value;
            }

            // Value table of signal 'SensorF_E8_NodeErrorFlag'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E9_SWError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 21) & 0x200000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200000ull) >> 21);
                return value;
            }

            // Value table of signal 'SensorF_E9_SWError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E10_TelemEmergency {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 22) & 0x400000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400000ull) >> 22);
                return value;
            }

            // Value table of signal 'SensorF_E10_TelemEmergency'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E12_encoderError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0x1000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000ull) >> 24);
                return value;
            }

            // Value table of signal 'SensorF_E12_encoderError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E13_encoderSpeedError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 25) & 0x2000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000000ull) >> 25);
                return value;
            }

            // Value table of signal 'SensorF_E13_encoderSpeedError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_E14_fiducialHighOffset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x81 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 26) & 0x4000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000000ull) >> 26);
                return value;
            }

            // Value table of signal 'SensorF_E14_fiducialHighOffset'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorF_TX_PodState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x181 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x7ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x7ull));
                return value;
            }

            // Value table of signal 'SensorF_TX_PodState'
            constexpr static uint8_t POD_OFF = 0;
            constexpr static uint8_t POD_IDLE = 1;
            constexpr static uint8_t POD_LAUNCH_PREPARATION = 2;
            constexpr static uint8_t POD_FAULT = 3;
            constexpr static uint8_t POD_READY_TO_LAUNCH = 4;
            constexpr static uint8_t POD_LAUNCHING = 5;
            constexpr static uint8_t POD_PUSHABLE = 6;
            constexpr static uint8_t POD_SAFE_TO_APPROACH = 7;
            constexpr static uint8_t POD_START_LEVITATION = 8;
            constexpr static uint8_t POD_STOP_LEVITATION = 9;
            constexpr static uint8_t POD_LEVITATING = 10;
            constexpr static uint8_t POD_BREAKING = 11;
            constexpr static uint8_t POD_STOP = 12;
        };
        class SensorF_TX_PodState_Last {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x181 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x38ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x38ull) >> 3);
                return value;
            }

            // Value table of signal 'SensorF_TX_PodState_Last'
            constexpr static uint8_t POD_OFF = 0;
            constexpr static uint8_t POD_IDLE = 1;
            constexpr static uint8_t POD_LAUNCH_PREPARATION = 2;
            constexpr static uint8_t POD_FAULT = 3;
            constexpr static uint8_t POD_READY_TO_LAUNCH = 4;
            constexpr static uint8_t POD_LAUNCHING = 5;
            constexpr static uint8_t POD_PUSHABLE = 6;
            constexpr static uint8_t POD_SAFE_TO_APPROACH = 7;
        };
        class SensorF_TX_PodState_Target {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x181 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x700ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x700ull) >> 8);
                return value;
            }

            // Value table of signal 'SensorF_TX_PodState_Target'
            constexpr static uint8_t POD_OFF = 0;
            constexpr static uint8_t POD_IDLE = 1;
            constexpr static uint8_t POD_LAUNCH_PREPARATION = 2;
            constexpr static uint8_t POD_FAULT = 3;
            constexpr static uint8_t POD_READY_TO_LAUNCH = 4;
            constexpr static uint8_t POD_LAUNCHING = 5;
            constexpr static uint8_t POD_PUSHABLE = 6;
            constexpr static uint8_t POD_SAFE_TO_APPROACH = 7;
        };
        class SensorF_TX_BrakesTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'SensorF_TX_BrakesTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_EnableTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'SensorF_TX_EnableTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_ErrorResetTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'SensorF_TX_ErrorResetTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_HWEnableTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'SensorF_TX_HWEnableTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_LaunchSetupTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }

            // Value table of signal 'SensorF_TX_LaunchSetupTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_LaunchStartTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }

            // Value table of signal 'SensorF_TX_LaunchStartTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_PreopTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }

            // Value table of signal 'SensorF_TX_PreopTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_SetHVTransition {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 7) & 0x80ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80ull) >> 7);
                return value;
            }

            // Value table of signal 'SensorF_TX_SetHVTransition'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_EnableBrakeFT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }

            // Value table of signal 'SensorF_TX_EnableBrakeFT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_EnableBrakeRT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 9) & 0x200ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200ull) >> 9);
                return value;
            }

            // Value table of signal 'SensorF_TX_EnableBrakeRT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_EnableHVCUT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x400ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400ull) >> 10);
                return value;
            }

            // Value table of signal 'SensorF_TX_EnableHVCUT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_EnablePDUT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 11) & 0x800ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800ull) >> 11);
                return value;
            }

            // Value table of signal 'SensorF_TX_EnablePDUT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_EnableSensorRT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'SensorF_TX_EnableSensorRT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_PreopSensorRT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'SensorF_TX_PreopSensorRT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_PreopBrakeFT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'SensorF_TX_PreopBrakeFT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_PreopBrakeRT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'SensorF_TX_PreopBrakeRT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_PreopPDUT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_TX_PreopPDUT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_TX_PreopHVCUT {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x201 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0x1000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000ull) >> 24);
                return value;
            }

            // Value table of signal 'SensorF_TX_PreopHVCUT'
            constexpr static bool NO_TRANSITIONS = 0;
            constexpr static bool TRANSITION = 1;
        };
        class SensorF_Pos_EncoderFront {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x401 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.355);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int32_t rawValue = static_cast<int32_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3FFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int32_t value = static_cast<int32_t>((intel & 0x3FFFFull));
                // Convert raw bits to signed value
                SignedConverter18Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f);
            }
        };
        class SensorF_Vel_EncoderFront {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x401 };
            constexpr static float min = static_cast<float>(-65.536);
            constexpr static float max = static_cast<float>(65.534);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF000000ull) >> 24);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.002f);
            }
        };
        class SensorF_GyroFront_X {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x401 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFFFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000000000ull) >> 40);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorF_TX_BatteryTemp {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x441 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(174.75);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.05f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.05f) + (-30.0f);
            }

            // Attributes of signal 'SensorF_TX_BatteryTemp'
            constexpr static float GenSigStartValue = 600.0f;
        };
        class SensorF_LIMT_Stator_1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x481 };
            constexpr static float min = static_cast<float>(-20);
            constexpr static float max = static_cast<float>(287.125);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-20.0f)) / (0.075f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.075f) + (-20.0f);
            }

            // Attributes of signal 'SensorF_LIMT_Stator_1'
            constexpr static float GenSigStartValue = 266.666666666667f;
        };
        class SensorF_LIMT_Stator_2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x481 };
            constexpr static float min = static_cast<float>(-20);
            constexpr static float max = static_cast<float>(287.125);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-20.0f)) / (0.075f)));
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xFFF000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000ull) >> 12);
                return value * (0.075f) + (-20.0f);
            }

            // Attributes of signal 'SensorF_LIMT_Stator_2'
            constexpr static float GenSigStartValue = 266.666666666667f;
        };
        class SensorF_LIMT_Stator_3 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x481 };
            constexpr static float min = static_cast<float>(-20);
            constexpr static float max = static_cast<float>(287.125);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-20.0f)) / (0.075f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000ull) >> 24);
                return value * (0.075f) + (-20.0f);
            }

            // Attributes of signal 'SensorF_LIMT_Stator_3'
            constexpr static float GenSigStartValue = 266.666666666667f;
        };
        class SensorF_LIMT_Stator_4 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x481 };
            constexpr static float min = static_cast<float>(-20);
            constexpr static float max = static_cast<float>(287.125);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-20.0f)) / (0.075f)));
                intel |= (static_cast<uint64_t>(rawValue) << 36) & 0xFFF000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000ull) >> 36);
                return value * (0.075f) + (-20.0f);
            }

            // Attributes of signal 'SensorF_LIMT_Stator_4'
            constexpr static float GenSigStartValue = 266.666666666667f;
        };
        class SensorF_Cooling_Temp {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x481 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(174.75);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.05f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000000ull) >> 48);
                return value * (0.05f) + (-30.0f);
            }

            // Attributes of signal 'SensorF_Cooling_Temp'
            constexpr static float GenSigStartValue = 600.0f;
        };
        class SensorF_AccFront_X {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C1 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorF_AccFront_Y {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C1 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorF_AccFront_Z {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C1 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorF_GyroFront_Z {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C1 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorF_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1, 0x601 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'SensorF_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
            constexpr static uint16_t SAMPLINGINTERVAL = 2048;
            constexpr static uint16_t TELEMETRYCOMMANDS = 2304;
            constexpr static uint16_t STATEMACHINEINTERVAL = 2305;
            constexpr static uint16_t STATEMACHINEACTIVATE = 2306;
            constexpr static uint16_t HVBATTERYMODE = 2307;
            constexpr static uint16_t ENCODERWHEELDIAMETER = 2308;
            constexpr static uint16_t ENCODERRESETPOSITION = 2309;
            constexpr static uint16_t SETRESET = 2320;
            constexpr static uint16_t IMU_NUMBER = 2592;
            constexpr static uint16_t IMU1_TEMPERATURE = 2597;
            constexpr static uint16_t IMU2_TEMPERATURE = 2598;
            constexpr static uint16_t IMU3_TEMPERATURE = 2599;
            constexpr static uint16_t IMU_ACCELX = 2600;
            constexpr static uint16_t IMU_ACCELY = 2601;
            constexpr static uint16_t IMU_ACCELZ = 2608;
            constexpr static uint16_t IMU_GYROX = 2609;
            constexpr static uint16_t IMU_GYROY = 2610;
            constexpr static uint16_t IMU_GYROZ = 2611;
            constexpr static uint16_t COOLINGPRESSURE = 2816;
            constexpr static uint16_t FIDUCIALRIGHTCOUNTER = 3072;
            constexpr static uint16_t FIDUCIALLEFTCOUNTER = 3073;
            constexpr static uint16_t POSITION = 3328;
            constexpr static uint16_t VELOCITY = 3329;
        };
        class SensorF_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x581 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'SensorF_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class SensorF_OD_SetReset {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2320            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2320);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2320) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_SetReset'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t RESET = 1;

            // Attributes of signal 'SensorF_OD_SetReset'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::WRITE_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_Velocity {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 3329            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 3329);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 3329) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_Velocity'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_Position {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 3328            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 3328);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 3328) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_Position'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_FiducialLeftCounter {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 3073            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 3073);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 3073) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_FiducialLeftCounter'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_FiducialRightCounter {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 3072            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 3072);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 3072) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_FiducialRightCounter'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CoolingPressure {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2816            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2816);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2816) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_CoolingPressure'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 9810.0f;
            constexpr static float CANzero_SDO_Default = -1.9f;
        };
        class SensorF_OD_IMU_GyroZ {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2611            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2611);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2611) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU_GyroZ'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU_GyroY {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2610            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2610);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2610) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU_GyroY'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU_GyroX {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2609            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2609);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2609) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU_GyroX'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU_AccelZ {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2608            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2608);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2608) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU_AccelZ'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU_AccelY {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2601            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2601);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2601) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU_AccelY'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU_AccelX {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2600            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2600);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2600) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU_AccelX'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU3_Temperature {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2599            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2599);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2599) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU3_Temperature'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU2_Temperature {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2598            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2598);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2598) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU2_Temperature'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU1_Temperature {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2597            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2597);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2597) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorF_OD_IMU1_Temperature'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_IMU_number {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2592            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2592);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2592) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_IMU_number'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_EncoderResetPosition {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2309            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2309);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2309) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_EncoderResetPosition'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t RESET = 1;

            // Attributes of signal 'SensorF_OD_EncoderResetPosition'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::WRITE_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_EncoderWheelDiameter {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2308            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(1);
            constexpr static float max = static_cast<float>(300);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2308);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2308) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'SensorF_OD_EncoderWheelDiameter'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 15000.0f;
            constexpr static float CANzero_SDO_Default = 75.0f;
        };
        class SensorF_OD_HVBatteryMode {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2307            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2307);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2307) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_HVBatteryMode'
            constexpr static uint8_t DISCHARGING = 0;
            constexpr static uint8_t CHARGING = 1;

            // Attributes of signal 'SensorF_OD_HVBatteryMode'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_StateMachineActivate {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2306            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2306);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2306) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_StateMachineActivate'
            constexpr static uint8_t ACTIVATE = 0;
            constexpr static uint8_t DEACTIVATE = 1;

            // Attributes of signal 'SensorF_OD_StateMachineActivate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_StateMachineInterval {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2305            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint8_t min = static_cast<uint8_t>(5);
            constexpr static uint8_t max = static_cast<uint8_t>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2305);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2305) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_StateMachineInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10.0f;
            constexpr static float CANzero_SDO_Default = 10.0f;
        };
        class SensorF_OD_TelemetryCommands {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2304            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2304);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2304) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_TelemetryCommands'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t LAUNCH_PREPARATION = 1;
            constexpr static uint8_t HV_ACTIVATION = 2;
            constexpr static uint8_t PUSHING_START = 3;
            constexpr static uint8_t PUSHING_END = 4;
            constexpr static uint8_t LAUNCH_START = 5;
            constexpr static uint8_t LAUNCH_ABORT = 6;
            constexpr static uint8_t IDLE = 7;
            constexpr static uint8_t ERROR_RESOLVED = 8;
            constexpr static uint8_t EMERGENCY = 9;

            // Attributes of signal 'SensorF_OD_TelemetryCommands'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_samplingInterval {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2048            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(0.01);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 2048);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2048) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorF_OD_samplingInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 10.0f;
        };
        class SensorF_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorF_OD_CAN2_DelayedTxMessages";
        };
        class SensorF_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'SensorF_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorF_OD_CAN2_DiscardedTxMessages";
        };
        class SensorF_OD_CAN2_Status {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'SensorF_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class SensorF_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'SensorF_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorF_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'SensorF_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorF_OD_CAN1_DelayedTxMessages";
        };
        class SensorF_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'SensorF_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorF_OD_CAN1_DiscardedTxMessages";
        };
        class SensorF_OD_CAN1_Status {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'SensorF_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class SensorF_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'SensorF_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorF_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'SensorF_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_BuildTime {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_BuildDate {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_ChipUID2 {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_ChipUID1 {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_SdcOut {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_SdcIn {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_runtime {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_InputVoltage {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'SensorF_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_BoardTemp {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'SensorF_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_MemFree {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'SensorF_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_CpuUsage {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorF_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'SensorF_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class SensorF_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'SensorF_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class SensorF_OD_DbcVersion {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_StackVersion {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorF_OD_NodeStatus {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorF_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'SensorF_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_OD_NodeID {
            public:
            // This signal is multiplexed by SensorF_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x581, 0x5C1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorF_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorF_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorF_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorF_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x701 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'SensorF_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class SensorR_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'SensorR_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorR_W1_stripeWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'SensorR_W1_stripeWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorR_W2_stateEstimationVelWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'SensorR_W2_stateEstimationVelWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'SensorR_W2_stateEstimationVelWarning'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_W2_stateEstimationVelWarning";
        };
        class SensorR_W3_stateEstimationPosWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'SensorR_W3_stateEstimationPosWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'SensorR_W3_stateEstimationPosWarning'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_W3_stateEstimationPosWarning";
        };
        class SensorR_W4_stateEstimationAccWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }

            // Value table of signal 'SensorR_W4_stateEstimationAccWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'SensorR_W4_stateEstimationAccWarning'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_W4_stateEstimationAccWarning";
        };
        class SensorR_W5_sciMoPEwarning069CPUtemp {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }

            // Value table of signal 'SensorR_W5_sciMoPEwarning069CPUtemp'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'SensorR_W5_sciMoPEwarning069CPUtemp'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_W5_sciMoPEwarning069CPUtemp";
        };
        class SensorR_W6_sciMoPEwarning104FETtemp {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }

            // Value table of signal 'SensorR_W6_sciMoPEwarning104FETtemp'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'SensorR_W6_sciMoPEwarning104FETtemp'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_W6_sciMoPEwarning104FETtemp";
        };
        class SensorR_W7_highOscillations {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 7) & 0x80ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80ull) >> 7);
                return value;
            }

            // Value table of signal 'SensorR_W7_highOscillations'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorR_W8_outOfLimModelBoundaries {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }

            // Value table of signal 'SensorR_W8_outOfLimModelBoundaries'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'SensorR_W8_outOfLimModelBoundaries'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_W8_outOfLimModelBoundaries";
        };
        class SensorR_W9_restrictingVelocity {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 9) & 0x200ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200ull) >> 9);
                return value;
            }

            // Value table of signal 'SensorR_W9_restrictingVelocity'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorR_W10_highLIMTemperature {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x400ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400ull) >> 10);
                return value;
            }

            // Value table of signal 'SensorR_W10_highLIMTemperature'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class SensorR_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'SensorR_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E1_trajectoryError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'SensorR_E1_trajectoryError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E2_stripeEmergencyStop {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'SensorR_E2_stripeEmergencyStop'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E3_posEmergencyStop {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'SensorR_E3_posEmergencyStop'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E4_velEmergencyStop {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_E4_velEmergencyStop'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E5_accEmergencyStop {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }

            // Value table of signal 'SensorR_E5_accEmergencyStop'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E6_scimoPEerror009Pulslock {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0x40000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000ull) >> 18);
                return value;
            }

            // Value table of signal 'SensorR_E6_scimoPEerror009Pulslock'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'SensorR_E6_scimoPEerror009Pulslock'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_E6_scimoPEerror009Pulslock";
        };
        class SensorR_E7_scimoPEerror020uZKmin {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 19) & 0x80000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80000ull) >> 19);
                return value;
            }

            // Value table of signal 'SensorR_E7_scimoPEerror020uZKmin'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_E8_scimoPEerror024motTemp {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 20) & 0x100000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100000ull) >> 20);
                return value;
            }

            // Value table of signal 'SensorR_E8_scimoPEerror024motTemp'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'SensorR_E8_scimoPEerror024motTemp'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_E8_scimoPEerror024motTemp";
        };
        class SensorR_E9_scimoPEerror102overcurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 21) & 0x200000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200000ull) >> 21);
                return value;
            }

            // Value table of signal 'SensorR_E9_scimoPEerror102overcurrent'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'SensorR_E9_scimoPEerror102overcurrent'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_E9_scimoPEerror102overcurrent";
        };
        class SensorR_E10_scimoPEerror103sumcurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 22) & 0x400000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400000ull) >> 22);
                return value;
            }

            // Value table of signal 'SensorR_E10_scimoPEerror103sumcurrent'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'SensorR_E10_scimoPEerror103sumcurrent'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_E10_scimoPEerror103sumcurrent";
        };
        class SensorR_E11_scimoPEerror101overcurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 23) & 0x800000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800000ull) >> 23);
                return value;
            }

            // Value table of signal 'SensorR_E11_scimoPEerror101overcurrent'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'SensorR_E11_scimoPEerror101overcurrent'
            constexpr static char SystemSignalLongSymbol[] = "SensorR_E11_scimoPEerror101overcurrent";
        };
        class SensorR_E12_highLIMTemperature {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x82 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0x1000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000ull) >> 24);
                return value;
            }

            // Value table of signal 'SensorR_E12_highLIMTemperature'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SensorR_TX_AccFront_X {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x182 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_AccFront_Y {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x182 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_AccFront_Z {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x182 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_GyroFront_Z {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x182 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorR_TX_RunState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x202 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3ull));
                return value;
            }

            // Value table of signal 'SensorR_TX_RunState'
            constexpr static uint8_t LAUNCHING = 0;
            constexpr static uint8_t READY_TO_LAUNCH = 1;
            constexpr static uint8_t FINISHED = 2;
            constexpr static uint8_t LAUNCH_ABORT = 3;
            constexpr static uint8_t IDLE_NOT_READY = 4;
        };
        class SensorR_TX_TrajectorySet {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x202 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }

            // Value table of signal 'SensorR_TX_TrajectorySet'
            constexpr static bool NOT_SET = 0;
            constexpr static bool SET = 1;
            constexpr static bool INVALID_SET = 2;
        };
        class SensorR_TX_Enabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x202 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }

            // Value table of signal 'SensorR_TX_Enabled'
            constexpr static bool DISABLED = 0;
            constexpr static bool ENABLED = 1;
        };
        class SensorR_TX_ErrorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x202 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }

            // Value table of signal 'SensorR_TX_ErrorFlag'
            constexpr static bool NO_ERROR = 0;
            constexpr static bool ERROR = 1;
        };
        class SensorR_TX_Acc {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x282 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_Vel {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x282 };
            constexpr static float min = static_cast<float>(-65.536);
            constexpr static float max = static_cast<float>(65.534);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.002f);
            }
        };
        class SensorR_TX_Pos {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x282 };
            constexpr static float min = static_cast<float>(-524.288);
            constexpr static float max = static_cast<float>(524.287);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int32_t rawValue = static_cast<int32_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int32_t value = static_cast<int32_t>((intel & 0xFFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter20Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.001f);
            }
        };
        class SensorR_RX_LaunchComm {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3ull));
                return value;
            }

            // Value table of signal 'SensorR_RX_LaunchComm'
            constexpr static uint8_t START_LAUNCH = 0;
            constexpr static uint8_t ABORT_LAUNCH = 1;
            constexpr static uint8_t NO_START = 2;
        };
        class SensorR_RX_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'SensorR_RX_Enable'
            constexpr static bool DISABLE = 0;
            constexpr static bool ENABLE = 1;
        };
        class SensorR_RX_ErrorReset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'SensorR_RX_ErrorReset'
            constexpr static bool NO_RESET = 0;
            constexpr static bool RESET = 1;
        };
        class SensorR_TX_Vel_EncoderFront {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x302 };
            constexpr static float min = static_cast<float>(-65.536);
            constexpr static float max = static_cast<float>(65.534);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.002f);
            }
        };
        class SensorR_TX_Vel_EncoderRear {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x302 };
            constexpr static float min = static_cast<float>(-65.536);
            constexpr static float max = static_cast<float>(65.534);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.002f);
            }
        };
        class SensorR_TX_Vel_Optical {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x302 };
            constexpr static float min = static_cast<float>(-65.536);
            constexpr static float max = static_cast<float>(65.534);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.002f);
            }
        };
        class SensorR_TX_GyroFront_X {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x382 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorR_TX_GyroFront_Y {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x382 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorR_TX_GyroRear_X {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x382 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorR_TX_GyroRear_Y {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x382 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorR_TX_TargetVelocity {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x3C2 };
            constexpr static float min = static_cast<float>(-81.92);
            constexpr static float max = static_cast<float>(81.91);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3FFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0x3FFFull));
                // Convert raw bits to signed value
                SignedConverter14Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.01f);
            }
        };
        class SensorR_TX_GapHeight_Left {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x402 };
            constexpr static float min = static_cast<float>(-25.6);
            constexpr static float max = static_cast<float>(25.5875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.0125f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFull));
                // Convert raw bits to signed value
                SignedConverter12Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.0125f);
            }
        };
        class SensorR_TX_GapHeight_Right {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x402 };
            constexpr static float min = static_cast<float>(-25.6);
            constexpr static float max = static_cast<float>(25.5875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.0125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xFFF000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFF000ull) >> 12);
                // Convert raw bits to signed value
                SignedConverter12Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.0125f);
            }
        };
        class SensorR_LIMT_Coil_1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x482 };
            constexpr static float min = static_cast<float>(-5);
            constexpr static float max = static_cast<float>(199.7);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-5.0f)) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0x7FFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0x7FFull));
                return value * (0.1f) + (-5.0f);
            }

            // Attributes of signal 'SensorR_LIMT_Coil_1'
            constexpr static float GenSigStartValue = 50.0f;
        };
        class SensorR_LIMT_Coil_2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x482 };
            constexpr static float min = static_cast<float>(-5);
            constexpr static float max = static_cast<float>(199.7);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-5.0f)) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x7FF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0x7FF0000ull) >> 16);
                return value * (0.1f) + (-5.0f);
            }

            // Attributes of signal 'SensorR_LIMT_Coil_2'
            constexpr static float GenSigStartValue = 50.0f;
        };
        class SensorR_LIMT_Coil_3 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x482 };
            constexpr static float min = static_cast<float>(-5);
            constexpr static float max = static_cast<float>(199.7);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-5.0f)) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0x7FF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0x7FF00000000ull) >> 32);
                return value * (0.1f) + (-5.0f);
            }

            // Attributes of signal 'SensorR_LIMT_Coil_3'
            constexpr static float GenSigStartValue = 50.0f;
        };
        class SensorR_TX_AccRear_X {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C2 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_AccRear_Y {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C2 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_AccRear_Z {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C2 };
            constexpr static float min = static_cast<float>(-40.96);
            constexpr static float max = static_cast<float>(40.95875);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.00125f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.00125f);
            }
        };
        class SensorR_TX_GyroRear_Z {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4C2 };
            constexpr static float min = static_cast<float>(-557.056);
            constexpr static float max = static_cast<float>(557.039);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.017f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.017f);
            }
        };
        class SensorR_TX_Pos_EncoderFront {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x502 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.355);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int32_t rawValue = static_cast<int32_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3FFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int32_t value = static_cast<int32_t>((intel & 0x3FFFFull));
                // Convert raw bits to signed value
                SignedConverter18Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f);
            }
        };
        class SensorR_TX_Pos_EncoderRear {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x502 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.355);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int32_t rawValue = static_cast<int32_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0xFFFFC0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int32_t value = static_cast<int32_t>((intel & 0xFFFFC0000ull) >> 18);
                // Convert raw bits to signed value
                SignedConverter18Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f);
            }
        };
        class SensorR_TX_Pos_Optical {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x502 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.355);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int32_t rawValue = static_cast<int32_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 36) & 0x3FFFF000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int32_t value = static_cast<int32_t>((intel & 0x3FFFF000000000ull) >> 36);
                // Convert raw bits to signed value
                SignedConverter18Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f);
            }
        };
        class SensorR_TX_StripeCounter_Left {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x502 };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(31);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 54) & 0x7C0000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x7C0000000000000ull) >> 54);
                return value;
            }
        };
        class SensorR_TX_StripeCounter_Right {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x502 };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(31);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 59) & 0xF800000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF800000000000000ull) >> 59);
                return value;
            }
        };
        class SensorR_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2, 0x602 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'SensorR_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
            constexpr static uint16_t SAMPLINGINTERVAL = 2048;
            constexpr static uint16_t ENCODERWHEELDIAMETER = 2576;
            constexpr static uint16_t ENCODERRESETPOSITION = 2586;
            constexpr static uint16_t IMU_NUMBER = 2592;
            constexpr static uint16_t IMU1_TEMPERATURE = 2597;
            constexpr static uint16_t IMU2_TEMPERATURE = 2598;
            constexpr static uint16_t IMU3_TEMPERATURE = 2599;
            constexpr static uint16_t EXECTIMEOVERALL = 2608;
            constexpr static uint16_t EXECTIMESTATEEST = 2609;
            constexpr static uint16_t EXECTIMECONTROL = 2610;
            constexpr static uint16_t EXECTIMEREADSENSORS = 2611;
            constexpr static uint16_t OPCKP = 2624;
            constexpr static uint16_t OPCKI = 2625;
            constexpr static uint16_t CTRLMODE = 2626;
            constexpr static uint16_t CURRENTREQ = 2627;
            constexpr static uint16_t PODMASS = 2628;
            constexpr static uint16_t FMAXCTRL = 2629;
            constexpr static uint16_t FMINCTRL = 2630;
            constexpr static uint16_t MAXCTRLERROR = 2631;
            constexpr static uint16_t MAXCTRLERRORDURATION = 2632;
            constexpr static uint16_t WARNINGTHRESHHOLDFORLIMMODELOUTOFBOUNDARIES = 2633;
            constexpr static uint16_t MAXREQUIREDVELOCITY = 2634;
            constexpr static uint16_t VDCREDUCEFACTOR = 2635;
            constexpr static uint16_t RUNMODE = 2636;
            constexpr static uint16_t SETFINISH = 2637;
            constexpr static uint16_t RUNPROFILE_T0 = 2816;
            constexpr static uint16_t RUNPROFILE_V0 = 2817;
            constexpr static uint16_t RUNPROFILE_T1 = 2818;
            constexpr static uint16_t RUNPROFILE_V1 = 2819;
            constexpr static uint16_t RUNPROFILE_T2 = 2820;
            constexpr static uint16_t RUNPROFILE_V2 = 2821;
            constexpr static uint16_t RUNPROFILE_T3 = 2822;
            constexpr static uint16_t RUNPROFILE_V3 = 2823;
            constexpr static uint16_t RUNPROFILE_T4 = 2824;
            constexpr static uint16_t RUNPROFILE_V4 = 2825;
            constexpr static uint16_t ESTIMATEDRUNLENGTH = 2826;
            constexpr static uint16_t TC_I = 3072;
            constexpr static uint16_t TC_F = 3073;
            constexpr static uint16_t VELOCITYCONTROLLER = 3074;
            constexpr static uint16_t CVOPCIMAX = 3075;
            constexpr static uint16_t CVOPCTCF = 3076;
            constexpr static uint16_t CVOPCTCI = 3077;
            constexpr static uint16_t CVOPCSMOOTHINGDELTAVELOCITY = 3078;
            constexpr static uint16_t CVOPCDELTAVELHIGHERCURRENT = 3079;
            constexpr static uint16_t CVOPCREDUCECURRENTWHILECRUISING = 3080;
            constexpr static uint16_t CVOPCHYSTERESEF = 3081;
            constexpr static uint16_t ACCATCURRENTMEASURED = 3088;
            constexpr static uint16_t CURRENTFORCONSTANTVELOCITY = 3089;
            constexpr static uint16_t CASCADEDMAXSETFORCEDELTA = 3090;
            constexpr static uint16_t CASCADEDFREQCURUPDATE = 3091;
            constexpr static uint16_t CASCADEDKPINCREASECURRENT = 3092;
            constexpr static uint16_t CASCADEDKPDECREASECURRENT = 3093;
            constexpr static uint16_t CVOPCIMIN = 3094;
            constexpr static uint16_t CVOPCTCFREQ = 3095;
            constexpr static uint16_t ADAPTMODELBYCURRENT = 3096;
            constexpr static uint16_t CURRENT4STOPPING = 3097;
            constexpr static uint16_t FINISHEDDELAY = 3104;
            constexpr static uint16_t MAXRUNDISTANCE = 3105;
            constexpr static uint16_t OPC_RATELIMITER_F = 3106;
            constexpr static uint16_t DEBUGCASCADEDIREQ = 3107;
            constexpr static uint16_t DEBUGCVOPCFREQ = 3108;
            constexpr static uint16_t OPC_BRAKEFLAG = 3109;
            constexpr static uint16_t OPC_T_RUN_MAX = 3110;
            constexpr static uint16_t OPC_F_MAX = 3111;
            constexpr static uint16_t OPC_T_ACC = 3112;
            constexpr static uint16_t OPC_V_MAX = 3113;
            constexpr static uint16_t OPC_V_THRESHOLD = 3120;
            constexpr static uint16_t OPC_F_DECREASE = 3121;
            constexpr static uint16_t OPC_LOWPASS_TCF = 3122;
            constexpr static uint16_t OPC_LOWPASS_TCI = 3123;
            constexpr static uint16_t STRIPEMODE = 3329;
            constexpr static uint16_t REFLECTORDISTANCE = 3330;
            constexpr static uint16_t POSITIONGLITCH = 3331;
            constexpr static uint16_t ENABLESIGNALGENERATION = 3332;
            constexpr static uint16_t ACCDEVIATION = 3585;
            constexpr static uint16_t VELDEVIATIONENCODER = 3586;
            constexpr static uint16_t VELDEVIATIONOPTIC = 3587;
            constexpr static uint16_t POSDEVIATIONENCODER = 3588;
            constexpr static uint16_t POSDEVIATIONOPTIC = 3589;
        };
        class SensorR_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x582 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'SensorR_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class SensorR_OD_posDeviationOptic {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3589            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3589);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3589) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_posDeviationOptic'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 40.0f;
            constexpr static float CANzero_SDO_Default = 4.0f;
        };
        class SensorR_OD_posDeviationEncoder {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3588            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3588);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3588) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_posDeviationEncoder'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 40.0f;
            constexpr static float CANzero_SDO_Default = 4.0f;
        };
        class SensorR_OD_velDeviationOptic {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3587            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3587);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3587) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_velDeviationOptic'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 20.0f;
            constexpr static float CANzero_SDO_Default = 2.0f;
        };
        class SensorR_OD_velDeviationEncoder {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3586            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3586);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3586) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_velDeviationEncoder'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 20.0f;
            constexpr static float CANzero_SDO_Default = 2.0f;
        };
        class SensorR_OD_accDeviation {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3585            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3585);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3585) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_accDeviation'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 40.0f;
            constexpr static float CANzero_SDO_Default = 4.0f;
        };
        class SensorR_OD_EnableSignalGeneration {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3332            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3332);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3332) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_EnableSignalGeneration'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_EnableSignalGeneration";
        };
        class SensorR_OD_PositionGlitch {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3331            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3331);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3331) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_PositionGlitch'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 5.0f;
        };
        class SensorR_OD_ReflectorDistance {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3330            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3330);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3330) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_ReflectorDistance'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 200.0f;
            constexpr static float CANzero_SDO_Default = 20.0f;
        };
        class SensorR_OD_StripeMode {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3329            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3329);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3329) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_StripeMode'
            constexpr static uint8_t LEFT = 0;
            constexpr static uint8_t RIGHT = 1;
            constexpr static uint8_t BOTH = 2;

            // Attributes of signal 'SensorR_OD_StripeMode'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_opc_lowpass_TcI {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3123            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3123);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3123) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_opc_lowpass_TcI'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2.0f;
            constexpr static float CANzero_SDO_Default = 0.02f;
        };
        class SensorR_OD_opc_lowpass_Tcf {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3122            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3122);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3122) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_opc_lowpass_Tcf'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2.0f;
            constexpr static float CANzero_SDO_Default = 0.02f;
        };
        class SensorR_OD_opc_F_decrease {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3121            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3121);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3121) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_opc_F_decrease'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 25.0f;
            constexpr static float CANzero_SDO_Default = 0.25f;
        };
        class SensorR_OD_opc_v_threshold {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3120            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3120);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3120) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_opc_v_threshold'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 25.0f;
            constexpr static float CANzero_SDO_Default = 0.25f;
        };
        class SensorR_OD_opc_v_max {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3113            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3113);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3113) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_opc_v_max'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 200.0f;
            constexpr static float CANzero_SDO_Default = 2.0f;
        };
        class SensorR_OD_opc_T_acc {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3112            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3112);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3112) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_opc_T_acc'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 20.0f;
            constexpr static float CANzero_SDO_Default = 2.0f;
        };
        class SensorR_OD_opc_F_max {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3111            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3111);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3111) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_opc_F_max'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 90.0f;
            constexpr static float CANzero_SDO_Default = 90.0f;
        };
        class SensorR_OD_opc_t_run_max {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3110            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3110);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3110) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_opc_t_run_max'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 40.0f;
            constexpr static float CANzero_SDO_Default = 4.0f;
        };
        class SensorR_OD_opc_brakeFlag {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3109            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3109);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3109) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_opc_brakeFlag'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t BRAKED = 1;

            // Attributes of signal 'SensorR_OD_opc_brakeFlag'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_DebugCVOPCfreq {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3108            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-3200);
            constexpr static float max = static_cast<float>(3353.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3108);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-3200.0f)) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f) + (-3200.0f);
            }

            // Attributes of signal 'SensorR_OD_DebugCVOPCfreq'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_DebugCascadedIreq {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3107            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-3200);
            constexpr static float max = static_cast<float>(3353.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3107);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-3200.0f)) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3107) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f) + (-3200.0f);
            }

            // Attributes of signal 'SensorR_OD_DebugCascadedIreq'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_opc_ratelimiter_f {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3106            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-3200);
            constexpr static float max = static_cast<float>(3353.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3106);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-3200.0f)) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3106) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f) + (-3200.0f);
            }

            // Attributes of signal 'SensorR_OD_opc_ratelimiter_f'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 37000.0f;
            constexpr static float CANzero_SDO_Default = 500.0f;
        };
        class SensorR_OD_maxRunDistance {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3105            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-1600);
            constexpr static float max = static_cast<float>(1676.75);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3105);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-1600.0f)) / (0.05f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3105) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.05f) + (-1600.0f);
            }

            // Attributes of signal 'SensorR_OD_maxRunDistance'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 38000.0f;
            constexpr static float CANzero_SDO_Default = 300.0f;
        };
        class SensorR_OD_FinishedDelay {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3104            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3104);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3104) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_FinishedDelay'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2500.0f;
            constexpr static float CANzero_SDO_Default = 2500.0f;
        };
        class SensorR_OD_Current4Stopping {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3097            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3097);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3097) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_Current4Stopping'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 500.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class SensorR_OD_AdaptModelByCurrent {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3096            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3096);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3096) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_AdaptModelByCurrent'
            constexpr static uint8_t CONST = 0;
            constexpr static uint8_t USECURRENT = 1;

            // Attributes of signal 'SensorR_OD_AdaptModelByCurrent'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CVOPCTcFreq {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3095            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3095);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3095) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CVOPCTcFreq'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 100.0f;
            constexpr static float CANzero_SDO_Default = 100.0f;
        };
        class SensorR_OD_CVOPCImin {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3094            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3094);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3094) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CVOPCImin'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class SensorR_OD_CascadedKpDecreaseCurrent {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3093            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3093);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3093) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_CascadedKpDecreaseCurrent'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 400.0f;
            constexpr static float CANzero_SDO_Default = 40.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CascadedKpDecreaseCurrent";
        };
        class SensorR_OD_CascadedKpIncreaseCurrent {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3092            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3092);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3092) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_CascadedKpIncreaseCurrent'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 400.0f;
            constexpr static float CANzero_SDO_Default = 40.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CascadedKpIncreaseCurrent";
        };
        class SensorR_OD_CascadedFreqCurUpdate {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3091            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3091);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3091) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'SensorR_OD_CascadedFreqCurUpdate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 100.0f;
            constexpr static float CANzero_SDO_Default = 0.1f;
        };
        class SensorR_OD_CascadedMaxSetForceDelta {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3090            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3090);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3090) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_CascadedMaxSetForceDelta'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 100.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CascadedMaxSetForceDelta";
        };
        class SensorR_OD_CurrentForConstantVelocity {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3089            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3089);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3089) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_CurrentForConstantVelocity'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 8000.0f;
            constexpr static float CANzero_SDO_Default = 80.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CurrentForConstantVelocity";
        };
        class SensorR_OD_AccAtCurrentMeasured {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3088            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3088);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3088) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_AccAtCurrentMeasured'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 7700.0f;
            constexpr static float CANzero_SDO_Default = 77.0f;
        };
        class SensorR_OD_CVOPCHystereseF {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3081            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3081);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3081) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_CVOPCHystereseF'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 4000.0f;
            constexpr static float CANzero_SDO_Default = 400.0f;
        };
        class SensorR_OD_CVOPCReduceCurrentWhileCruising {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3080            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3080);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3080) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_CVOPCReduceCurrentWhileCruising'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 90.0f;
            constexpr static float CANzero_SDO_Default = 0.9f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CVOPCReduceCurrentWhileCruising";
        };
        class SensorR_OD_CVOPCDeltaVelHigherCurrent {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3079            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3079);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3079) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_CVOPCDeltaVelHigherCurrent'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 30.0f;
            constexpr static float CANzero_SDO_Default = 0.3f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CVOPCDeltaVelHigherCurrent";
        };
        class SensorR_OD_CVOPCSmoothingDeltaVelocity {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3078            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 3078);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3078) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_CVOPCSmoothingDeltaVelocity'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 5.0f;
            constexpr static float CANzero_SDO_Default = 0.05f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CVOPCSmoothingDeltaVelocity";
        };
        class SensorR_OD_CVOPCTcI {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3077            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3077);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3077) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CVOPCTcI'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 300.0f;
            constexpr static float CANzero_SDO_Default = 300.0f;
        };
        class SensorR_OD_CVOPCTcf {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3076            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3076);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3076) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CVOPCTcf'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class SensorR_OD_CVOPCImax {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3075            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3075);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3075) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CVOPCImax'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 200.0f;
            constexpr static float CANzero_SDO_Default = 200.0f;
        };
        class SensorR_OD_VelocityController {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3074            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3074);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3074) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_VelocityController'
            constexpr static uint8_t CC = 0;
            constexpr static uint8_t CVFF = 1;
            constexpr static uint8_t CVFB = 2;
            constexpr static uint8_t CAS = 3;
            constexpr static uint8_t FAST = 4;

            // Attributes of signal 'SensorR_OD_VelocityController'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_TC_f {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3073            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3073);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3073) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_TC_f'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 150.0f;
            constexpr static float CANzero_SDO_Default = 150.0f;
        };
        class SensorR_OD_TC_I {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3072            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3072);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3072) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_TC_I'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 150.0f;
            constexpr static float CANzero_SDO_Default = 150.0f;
        };
        class SensorR_OD_EstimatedRunLength {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2826            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-1600);
            constexpr static float max = static_cast<float>(1676.75);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2826);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-1600.0f)) / (0.05f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2826) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.05f) + (-1600.0f);
            }

            // Attributes of signal 'SensorR_OD_EstimatedRunLength'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_RunProfile_V4 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2825            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-327);
            constexpr static float max = static_cast<float>(328.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2825);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-327.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2825) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-327.0f);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_V4'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32700.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_RunProfile_T4 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2824            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(655350);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2824);
                uint32_t rawValue = static_cast<uint32_t>((value) / (10));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2824) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (10);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_T4'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 450.0f;
            constexpr static float CANzero_SDO_Default = 4500.0f;
        };
        class SensorR_OD_RunProfile_V3 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2823            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-327);
            constexpr static float max = static_cast<float>(328.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2823);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-327.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2823) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-327.0f);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_V3'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32800.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_RunProfile_T3 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2822            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(655350);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2822);
                uint32_t rawValue = static_cast<uint32_t>((value) / (10));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2822) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (10);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_T3'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 350.0f;
            constexpr static float CANzero_SDO_Default = 3500.0f;
        };
        class SensorR_OD_RunProfile_V2 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2821            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-327);
            constexpr static float max = static_cast<float>(328.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2821);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-327.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2821) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-327.0f);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_V2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32800.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_RunProfile_T2 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2820            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(655350);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2820);
                uint32_t rawValue = static_cast<uint32_t>((value) / (10));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2820) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (10);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_T2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 300.0f;
            constexpr static float CANzero_SDO_Default = 3000.0f;
        };
        class SensorR_OD_RunProfile_V1 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2819            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-327);
            constexpr static float max = static_cast<float>(328.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2819);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-327.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2819) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-327.0f);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_V1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32705.0f;
            constexpr static float CANzero_SDO_Default = 0.05f;
        };
        class SensorR_OD_RunProfile_T1 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2818            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(655350);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2818);
                uint32_t rawValue = static_cast<uint32_t>((value) / (10));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2818) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (10);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_T1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 100.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class SensorR_OD_RunProfile_V0 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2817            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-327);
            constexpr static float max = static_cast<float>(328.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2817);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-327.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2817) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-327.0f);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_V0'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 32700.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_RunProfile_T0 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2816            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(655350);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2816);
                uint32_t rawValue = static_cast<uint32_t>((value) / (10));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2816) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (10);
            }

            // Attributes of signal 'SensorR_OD_RunProfile_T0'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_SetFinish {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2637            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 2637);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2637) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_SetFinish'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t FINISH = 1;

            // Attributes of signal 'SensorR_OD_SetFinish'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_RunMode {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2636            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 2636);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2636) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_RunMode'
            constexpr static uint8_t DYNAMIC = 0;
            constexpr static uint8_t LEVITATION = 1;
            constexpr static uint8_t MANUAL = 2;

            // Attributes of signal 'SensorR_OD_RunMode'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_VdcReduceFactor {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2635            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2635);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2635) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_VdcReduceFactor'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 9.499999999999998f;
            constexpr static float CANzero_SDO_Default = 0.95f;
        };
        class SensorR_OD_MaxRequiredVelocity {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2634            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2634);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2634) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_MaxRequiredVelocity'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 190.0f;
            constexpr static float CANzero_SDO_Default = 19.0f;
        };
        class SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2633            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2633);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2633) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 900.0f;
            constexpr static float CANzero_SDO_Default = 0.9f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries";
        };
        class SensorR_OD_MaxCtrlErrorDuration {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2632            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2632);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2632) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_MaxCtrlErrorDuration'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 0.5f;
        };
        class SensorR_OD_MaxCtrlError {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2631            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2631);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2631) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_MaxCtrlError'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 150.0f;
            constexpr static float CANzero_SDO_Default = 1.5f;
        };
        class SensorR_OD_FminCtrl {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2630            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65535.0);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2630);
                uint16_t rawValue = static_cast<uint16_t>(value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2630) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_FminCtrl'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 922.0f;
            constexpr static float CANzero_SDO_Default = 922.0f;
        };
        class SensorR_OD_FmaxCtrl {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2629            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65535.0);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2629);
                uint16_t rawValue = static_cast<uint16_t>(value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2629) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_FmaxCtrl'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1004.0f;
            constexpr static float CANzero_SDO_Default = 1004.0f;
        };
        class SensorR_OD_PodMass {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2628            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2628);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2628) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_PodMass'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2300.0f;
            constexpr static float CANzero_SDO_Default = 230.0f;
        };
        class SensorR_OD_CurrentReq {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2627            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2627);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2627) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'SensorR_OD_CurrentReq'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1050.0f;
            constexpr static float CANzero_SDO_Default = 105.0f;
        };
        class SensorR_OD_CtrlMode {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2626            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 2626);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2626) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CtrlMode'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_OpcKi {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2625            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2625);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2625) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_OpcKi'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 0.5f;
        };
        class SensorR_OD_OpcKp {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2624            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2624);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2624) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_OpcKp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 600.0f;
            constexpr static float CANzero_SDO_Default = 6.0f;
        };
        class SensorR_OD_ExecTimeReadSensors {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2611            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2611);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2611) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_ExecTimeReadSensors'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_ExecTimeControl {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2610            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2610);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2610) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_ExecTimeControl'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_ExecTimeStateEst {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2609            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2609);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2609) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_ExecTimeStateEst'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_ExecTimeOverall {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2608            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2608);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2608) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_ExecTimeOverall'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_IMU3_Temperature {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2599            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2599);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2599) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorR_OD_IMU3_Temperature'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_IMU2_Temperature {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2598            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2598);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2598) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorR_OD_IMU2_Temperature'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_IMU1_Temperature {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2597            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-100);
            constexpr static float max = static_cast<float>(555.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2597);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-100.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2597) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-100.0f);
            }

            // Attributes of signal 'SensorR_OD_IMU1_Temperature'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_IMU_number {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2592            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 2592);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2592) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_IMU_number'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_EncoderResetPosition {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2586            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 2586);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2586) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_EncoderResetPosition'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t RESET = 1;

            // Attributes of signal 'SensorR_OD_EncoderResetPosition'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::WRITE_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_EncoderWheelDiameter {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2576            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(1);
            constexpr static float max = static_cast<float>(300);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2576);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2576) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'SensorR_OD_EncoderWheelDiameter'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 15000.0f;
            constexpr static float CANzero_SDO_Default = 75.0f;
        };
        class SensorR_OD_samplingInterval {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2048            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0.01);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 2048);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2048) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'SensorR_OD_samplingInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 10.0f;
        };
        class SensorR_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CAN2_DelayedTxMessages";
        };
        class SensorR_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'SensorR_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CAN2_DiscardedTxMessages";
        };
        class SensorR_OD_CAN2_Status {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'SensorR_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class SensorR_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'SensorR_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'SensorR_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CAN1_DelayedTxMessages";
        };
        class SensorR_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'SensorR_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "SensorR_OD_CAN1_DiscardedTxMessages";
        };
        class SensorR_OD_CAN1_Status {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'SensorR_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class SensorR_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'SensorR_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'SensorR_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_BuildTime {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_BuildDate {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_ChipUID2 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_ChipUID1 {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_SdcOut {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_SdcIn {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_runtime {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_InputVoltage {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'SensorR_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_BoardTemp {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'SensorR_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_MemFree {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'SensorR_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_CpuUsage {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                SensorR_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'SensorR_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class SensorR_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'SensorR_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class SensorR_OD_DbcVersion {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_StackVersion {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class SensorR_OD_NodeStatus {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'SensorR_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'SensorR_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_OD_NodeID {
            public:
            // This signal is multiplexed by SensorR_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x582, 0x5C2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                SensorR_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (SensorR_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'SensorR_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class SensorR_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x702 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'SensorR_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class BrakeF_W0_highPressureActingChamber {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'BrakeF_W0_highPressureActingChamber'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'BrakeF_W0_highPressureActingChamber'
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_W0_highPressureActingChamber";
        };
        class BrakeF_W1_highPressureRetractingChamber {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'BrakeF_W1_highPressureRetractingChamber'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'BrakeF_W1_highPressureRetractingChamber'
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_W1_highPressureRetractingChamber";
        };
        class BrakeF_W2_enableWithAnError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'BrakeF_W2_enableWithAnError'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class BrakeF_W3_externalError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'BrakeF_W3_externalError'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class BrakeF_E0_pressureTooHigh {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'BrakeF_E0_pressureTooHigh'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class BrakeF_E1_pressureTooLow {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'BrakeF_E1_pressureTooLow'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class BrakeF_E2_commWatchdogTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'BrakeF_E2_commWatchdogTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class BrakeF_E3_retractUnsuccesful_errorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'BrakeF_E3_retractUnsuccesful_errorFlag'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'BrakeF_E3_retractUnsuccesful_errorFlag'
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_E3_retractUnsuccesful_errorFlag";
        };
        class BrakeF_E4_retractUnsuccesful_notEnabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_E4_retractUnsuccesful_notEnabled'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'BrakeF_E4_retractUnsuccesful_notEnabled'
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_E4_retractUnsuccesful_notEnabled";
        };
        class BrakeF_E5_retractUnsuccesful_openSDC {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x91 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }

            // Value table of signal 'BrakeF_E5_retractUnsuccesful_openSDC'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'BrakeF_E5_retractUnsuccesful_openSDC'
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_E5_retractUnsuccesful_openSDC";
        };
        class BrakeF_TX_Status {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x191 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3ull));
                return value;
            }

            // Value table of signal 'BrakeF_TX_Status'
            constexpr static uint8_t DISENGAGED = 0;
            constexpr static uint8_t ENGAGEDEMERGENCY = 1;
            constexpr static uint8_t ENGAGEDSERVICE = 2;
        };
        class BrakeF_TX_Enabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x191 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'BrakeF_TX_Enabled'
            constexpr static bool DISABLED = 0;
            constexpr static bool ENABLED = 1;
        };
        class BrakeF_TX_ErrorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x191 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'BrakeF_TX_ErrorFlag'
            constexpr static bool NO_ERROR = 0;
            constexpr static bool ERROR = 1;
        };
        class BrakeF_TX_SDC_Input {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x191 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }

            // Value table of signal 'BrakeF_TX_SDC_Input'
            constexpr static bool OPEN = 0;
            constexpr static bool CLOSED = 1;
        };
        class BrakeF_TX_DeltaTime_Control {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x191 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class BrakeF_TX_MaxDeltaTime_Control {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x191 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class BrakeF_RX_ErrorReset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'BrakeF_RX_ErrorReset'
            constexpr static bool NO_RESET = 0;
            constexpr static bool RESET = 1;
        };
        class BrakeF_RX_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'BrakeF_RX_Enable'
            constexpr static bool DISABLE = 0;
            constexpr static bool ENABLE = 1;
        };
        class BrakeF_RX_Engage {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0xCull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xCull) >> 2);
                return value;
            }

            // Value table of signal 'BrakeF_RX_Engage'
            constexpr static uint8_t DISENGAGE = 0;
            constexpr static uint8_t ENGAGEEMERGENCY = 1;
            constexpr static uint8_t ENGAGESERVICE = 2;
        };
        class BrakeF_TX_Pressure_Act {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x411 };
            constexpr static float min = static_cast<float>(-2);
            constexpr static float max = static_cast<float>(18.475);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-2.0f)) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFFull));
                return value * (0.005f) + (-2.0f);
            }

            // Attributes of signal 'BrakeF_TX_Pressure_Act'
            constexpr static float GenSigStartValue = 400.0f;
        };
        class BrakeF_TX_Pressure_Retract {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x411 };
            constexpr static float min = static_cast<float>(-2);
            constexpr static float max = static_cast<float>(18.475);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-2.0f)) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f) + (-2.0f);
            }

            // Attributes of signal 'BrakeF_TX_Pressure_Retract'
            constexpr static float GenSigStartValue = 400.0f;
        };
        class BrakeF_TX_Pressure_Tank {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x411 };
            constexpr static float min = static_cast<float>(-2);
            constexpr static float max = static_cast<float>(18.475);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-2.0f)) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF00000000ull) >> 32);
                return value * (0.005f) + (-2.0f);
            }

            // Attributes of signal 'BrakeF_TX_Pressure_Tank'
            constexpr static float GenSigStartValue = 400.0f;
        };
        class BrakeF_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1, 0x611 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'BrakeF_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
            constexpr static uint16_t TANKLOWERCONTROLLIMIT = 2048;
            constexpr static uint16_t TANKUPPERCONTROLLIMIT = 2049;
            constexpr static uint16_t DELAY = 2050;
            constexpr static uint16_t COUNTERLIMIT = 2051;
            constexpr static uint16_t COMMWATCHDOG = 2052;
            constexpr static uint16_t VALVEUPPERTOLERANCE = 2053;
        };
        class BrakeF_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x591 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'BrakeF_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class BrakeF_OD_valveUpperTolerance {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2053            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(327.675);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2053);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2053) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'BrakeF_OD_valveUpperTolerance'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2000.0f;
            constexpr static float CANzero_SDO_Default = 10.0f;
        };
        class BrakeF_OD_commWatchdog {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2052            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2052);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2052) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_commWatchdog'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 60.0f;
            constexpr static float CANzero_SDO_Default = 60.0f;
        };
        class BrakeF_OD_counterLimit {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2051            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2051);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2051) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_counterLimit'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 5.0f;
            constexpr static float CANzero_SDO_Default = 5.0f;
        };
        class BrakeF_OD_delay {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2050            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(127.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2050);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2050) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'BrakeF_OD_delay'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10.0f;
            constexpr static float CANzero_SDO_Default = 5.0f;
        };
        class BrakeF_OD_tankUpperControlLimit {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2049            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(327.675);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2049);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2049) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'BrakeF_OD_tankUpperControlLimit'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3800.0f;
            constexpr static float CANzero_SDO_Default = 19.0f;
        };
        class BrakeF_OD_tankLowerControlLimit {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2048            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(327.675);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2048);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2048) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'BrakeF_OD_tankLowerControlLimit'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1400.0f;
            constexpr static float CANzero_SDO_Default = 7.0f;
        };
        class BrakeF_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'BrakeF_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_OD_CAN2_DiscardedTxMessages";
        };
        class BrakeF_OD_CAN2_Status {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'BrakeF_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class BrakeF_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'BrakeF_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class BrakeF_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'BrakeF_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'BrakeF_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "BrakeF_OD_CAN1_DiscardedTxMessages";
        };
        class BrakeF_OD_CAN1_Status {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'BrakeF_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class BrakeF_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'BrakeF_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class BrakeF_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'BrakeF_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_BuildTime {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_BuildDate {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_ChipUID2 {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_ChipUID1 {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_SdcOut {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_SdcIn {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_runtime {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_InputVoltage {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'BrakeF_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_BoardTemp {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'BrakeF_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_MemFree {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'BrakeF_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_CpuUsage {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'BrakeF_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class BrakeF_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'BrakeF_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 100.0f;
            constexpr static float CANzero_SDO_Default = 100.0f;
        };
        class BrakeF_OD_DbcVersion {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_StackVersion {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class BrakeF_OD_NodeStatus {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeF_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'BrakeF_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_OD_NodeID {
            public:
            // This signal is multiplexed by BrakeF_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x591, 0x5D1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeF_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeF_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeF_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeF_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x711 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'BrakeF_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class BrakeR_W0_highPressureActingChamber {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'BrakeR_W0_highPressureActingChamber'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'BrakeR_W0_highPressureActingChamber'
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_W0_highPressureActingChamber";
        };
        class BrakeR_W1_highPressureRetractingChamber {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'BrakeR_W1_highPressureRetractingChamber'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;

            // Attributes of signal 'BrakeR_W1_highPressureRetractingChamber'
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_W1_highPressureRetractingChamber";
        };
        class BrakeR_W2_enableWithAnError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'BrakeR_W2_enableWithAnError'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class BrakeR_W3_externalError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'BrakeR_W3_externalError'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class BrakeR_E0_pressureTooHigh {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'BrakeR_E0_pressureTooHigh'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class BrakeR_E1_pressureTooLow {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'BrakeR_E1_pressureTooLow'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class BrakeR_E2_commWatchdogTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'BrakeR_E2_commWatchdogTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class BrakeR_E3_retractUnsuccesful_errorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'BrakeR_E3_retractUnsuccesful_errorFlag'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'BrakeR_E3_retractUnsuccesful_errorFlag'
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_E3_retractUnsuccesful_errorFlag";
        };
        class BrakeR_E4_retractUnsuccesful_notEnabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_E4_retractUnsuccesful_notEnabled'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'BrakeR_E4_retractUnsuccesful_notEnabled'
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_E4_retractUnsuccesful_notEnabled";
        };
        class BrakeR_E5_retractUnsuccesful_openSDC {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x92 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }

            // Value table of signal 'BrakeR_E5_retractUnsuccesful_openSDC'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;

            // Attributes of signal 'BrakeR_E5_retractUnsuccesful_openSDC'
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_E5_retractUnsuccesful_openSDC";
        };
        class BrakeR_TX_Status {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x192 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3ull));
                return value;
            }

            // Value table of signal 'BrakeR_TX_Status'
            constexpr static uint8_t DISENGAGED = 0;
            constexpr static uint8_t ENGAGEDEMERGENCY = 1;
            constexpr static uint8_t ENGAGEDSERVICE = 2;
        };
        class BrakeR_TX_Enabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x192 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'BrakeR_TX_Enabled'
            constexpr static bool DISABLED = 0;
            constexpr static bool ENABLED = 1;
        };
        class BrakeR_TX_ErrorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x192 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'BrakeR_TX_ErrorFlag'
            constexpr static bool NO_ERROR = 0;
            constexpr static bool ERROR = 1;
        };
        class BrakeR_TX_SDC_Input {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x192 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }

            // Value table of signal 'BrakeR_TX_SDC_Input'
            constexpr static bool OPEN = 0;
            constexpr static bool CLOSED = 1;
        };
        class BrakeR_TX_DeltaTime_Control {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x192 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class BrakeR_TX_MaxDeltaTime_Control {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x192 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class BrakeR_RX_ErrorReset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'BrakeR_RX_ErrorReset'
            constexpr static bool NO_RESET = 0;
            constexpr static bool RESET = 1;
        };
        class BrakeR_RX_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'BrakeR_RX_Enable'
            constexpr static bool DISABLE = 0;
            constexpr static bool ENABLE = 1;
        };
        class BrakeR_RX_Engage {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0xCull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xCull) >> 2);
                return value;
            }

            // Value table of signal 'BrakeR_RX_Engage'
            constexpr static uint8_t DISENGAGE = 0;
            constexpr static uint8_t ENGAGEEMERGENCY = 1;
            constexpr static uint8_t ENGAGESERVICE = 2;
        };
        class BrakeR_TX_Pressure_Act {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x452 };
            constexpr static float min = static_cast<float>(-2);
            constexpr static float max = static_cast<float>(18.475);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-2.0f)) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.005f) + (-2.0f);
            }

            // Attributes of signal 'BrakeR_TX_Pressure_Act'
            constexpr static float GenSigStartValue = 400.0f;
        };
        class BrakeR_TX_Pressure_Retract {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x452 };
            constexpr static float min = static_cast<float>(-2);
            constexpr static float max = static_cast<float>(18.475);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-2.0f)) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xFFF000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000ull) >> 12);
                return value * (0.005f) + (-2.0f);
            }

            // Attributes of signal 'BrakeR_TX_Pressure_Retract'
            constexpr static float GenSigStartValue = 400.0f;
        };
        class BrakeR_TX_Pressure_Tank {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x452 };
            constexpr static float min = static_cast<float>(-2);
            constexpr static float max = static_cast<float>(18.475);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-2.0f)) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000ull) >> 24);
                return value * (0.005f) + (-2.0f);
            }

            // Attributes of signal 'BrakeR_TX_Pressure_Tank'
            constexpr static float GenSigStartValue = 400.0f;
        };
        class BrakeR_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2, 0x612 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'BrakeR_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
            constexpr static uint16_t TANKLOWERCONTROLLIMIT = 2048;
            constexpr static uint16_t TANKUPPERCONTROLLIMIT = 2049;
            constexpr static uint16_t DELAY = 2050;
            constexpr static uint16_t COUNTERLIMIT = 2051;
            constexpr static uint16_t COMMWATCHDOG = 2052;
            constexpr static uint16_t VALVEUPPERTOLERANCE = 2053;
        };
        class BrakeR_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x592 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'BrakeR_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class BrakeR_OD_valveUpperTolerance {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2053            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(327.675);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2053);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2053) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'BrakeR_OD_valveUpperTolerance'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2000.0f;
            constexpr static float CANzero_SDO_Default = 10.0f;
        };
        class BrakeR_OD_commWatchdog {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2052            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2052);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2052) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_commWatchdog'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 60.0f;
            constexpr static float CANzero_SDO_Default = 60.0f;
        };
        class BrakeR_OD_counterLimit {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2051            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2051);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2051) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_counterLimit'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 5.0f;
            constexpr static float CANzero_SDO_Default = 5.0f;
        };
        class BrakeR_OD_delay {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2050            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(127.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2050);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2050) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'BrakeR_OD_delay'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10.0f;
            constexpr static float CANzero_SDO_Default = 5.0f;
        };
        class BrakeR_OD_tankUpperControlLimit {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2049            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(327.675);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2049);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2049) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'BrakeR_OD_tankUpperControlLimit'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3800.0f;
            constexpr static float CANzero_SDO_Default = 19.0f;
        };
        class BrakeR_OD_tankLowerControlLimit {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2048            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(327.675);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2048);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.005f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2048) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.005f);
            }

            // Attributes of signal 'BrakeR_OD_tankLowerControlLimit'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1400.0f;
            constexpr static float CANzero_SDO_Default = 7.0f;
        };
        class BrakeR_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'BrakeR_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_OD_CAN2_DiscardedTxMessages";
        };
        class BrakeR_OD_CAN2_Status {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'BrakeR_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class BrakeR_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'BrakeR_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class BrakeR_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'BrakeR_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'BrakeR_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "BrakeR_OD_CAN1_DiscardedTxMessages";
        };
        class BrakeR_OD_CAN1_Status {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'BrakeR_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class BrakeR_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'BrakeR_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class BrakeR_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'BrakeR_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_BuildTime {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_BuildDate {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_ChipUID2 {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_ChipUID1 {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_SdcOut {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_SdcIn {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_runtime {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_InputVoltage {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'BrakeR_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_BoardTemp {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'BrakeR_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_MemFree {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'BrakeR_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_CpuUsage {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'BrakeR_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class BrakeR_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'BrakeR_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 100.0f;
            constexpr static float CANzero_SDO_Default = 100.0f;
        };
        class BrakeR_OD_DbcVersion {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_StackVersion {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class BrakeR_OD_NodeStatus {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'BrakeR_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'BrakeR_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_OD_NodeID {
            public:
            // This signal is multiplexed by BrakeR_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x592, 0x5D2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                BrakeR_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (BrakeR_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'BrakeR_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class BrakeR_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x712 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'BrakeR_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class PDU_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'PDU_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class PDU_W1_batterVoltageLow {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'PDU_W1_batterVoltageLow'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class PDU_W2_batterTempHigh {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'PDU_W2_batterTempHigh'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class PDU_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'PDU_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class PDU_E1_batterVoltageCritical {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'PDU_E1_batterVoltageCritical'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class PDU_E2_batteryOvercurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'PDU_E2_batteryOvercurrent'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class PDU_E3_batterTempCritical {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'PDU_E3_batterTempCritical'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class PDU_E4_watchdogStateMachine {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x9A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_E4_watchdogStateMachine'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class PDU_TX_Enabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'PDU_TX_Enabled'
            constexpr static bool DISABLED = 0;
            constexpr static bool ENABLED = 1;
        };
        class PDU_TX_ErrorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'PDU_TX_ErrorFlag'
            constexpr static bool NO_ERROR = 0;
            constexpr static bool ERROR = 1;
        };
        class PDU_TX_PEHWEnabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'PDU_TX_PEHWEnabled'
            constexpr static bool DISABLED = 0;
            constexpr static bool ENABLED = 1;
        };
        class PDU_RX_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'PDU_RX_Enable'
            constexpr static bool DISABLE = 0;
            constexpr static bool ENABLE = 1;
        };
        class PDU_RX_ErrorReset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'PDU_RX_ErrorReset'
            constexpr static bool NO_RESET = 0;
            constexpr static bool RESET = 1;
        };
        class PDU_RX_PEHWEnable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'PDU_RX_PEHWEnable'
            constexpr static bool DISABLE = 0;
            constexpr static bool ENABLE = 1;
        };
        class PDU_HPCh1_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x21A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(16.38);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.004f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.004f);
            }
        };
        class PDU_HPCh2_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x21A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(16.38);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.004f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF0000ull) >> 16);
                return value * (0.004f);
            }
        };
        class PDU_HPCh3_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x21A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(16.38);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.004f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF00000000ull) >> 32);
                return value * (0.004f);
            }
        };
        class PDU_HPCh4_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x21A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(16.38);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.004f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000000ull) >> 48);
                return value * (0.004f);
            }
        };
        class PDU_LPCh1_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x25A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_LPCh1_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_LPCh10_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x25A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_LPCh10_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_LPCh2_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x25A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_LPCh2_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_LPCh3_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x25A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_LPCh3_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_LPCh8_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x25A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_LPCh8_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_LPCh9_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x25A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_LPCh9_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_HPCh1_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFull));
                return value;
            }
        };
        class PDU_HPCh1_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x30ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x30ull) >> 4);
                return value;
            }
        };
        class PDU_HPCh2_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0xC0ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC0ull) >> 6);
                return value;
            }
        };
        class PDU_HPCh2_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF00ull) >> 8);
                return value;
            }
        };
        class PDU_HPCh3_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }
        };
        class PDU_HPCh3_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x30000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x30000ull) >> 16);
                return value;
            }
        };
        class PDU_HPCh4_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0x3C0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3C0000ull) >> 18);
                return value;
            }
        };
        class PDU_HPCh4_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x29A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 22) & 0xC00000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC00000ull) >> 22);
                return value;
            }
        };
        class PDU_HPCh1_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_HPCh1_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_HPCh2_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_HPCh2_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_D1_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_D1_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_D2_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_D2_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_D3_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_D3_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_D4_Dutycycle {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x2DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_D4_Dutycycle'
            constexpr static float GenSigStartValue = 200.0f;
        };
        class PDU_LPCh1_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }
        };
        class PDU_LPCh2_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }
        };
        class PDU_LPCh3_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }
        };
        class PDU_LPCh4_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }
        };
        class PDU_LPCh5_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }
        };
        class PDU_LPCh6_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }
        };
        class PDU_LPCh7_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }
        };
        class PDU_LPCh8_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 7) & 0x80ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80ull) >> 7);
                return value;
            }
        };
        class PDU_LPCh9_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }
        };
        class PDU_LPCh10_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 9) & 0x200ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200ull) >> 9);
                return value;
            }
        };
        class PDU_HPCh1_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x400ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400ull) >> 10);
                return value;
            }
        };
        class PDU_HPCh2_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 11) & 0x800ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800ull) >> 11);
                return value;
            }
        };
        class PDU_HPCh3_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }
        };
        class PDU_HPCh4_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }
        };
        class PDU_D1_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }
        };
        class PDU_D2_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }
        };
        class PDU_D3_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }
        };
        class PDU_D4_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }
        };
        class PDU_SDC_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x35A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0x40000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000ull) >> 18);
                return value;
            }
        };
        class PDU_LPCh10_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFull));
                return value;
            }
        };
        class PDU_LPCh1_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0xF0ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF0ull) >> 4);
                return value;
            }
        };
        class PDU_LPCh2_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF00ull) >> 8);
                return value;
            }
        };
        class PDU_LPCh3_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }
        };
        class PDU_LPCh4_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF0000ull) >> 16);
                return value;
            }
        };
        class PDU_LPCh5_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 20) & 0xF00000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF00000ull) >> 20);
                return value;
            }
        };
        class PDU_LPCh6_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000000ull) >> 24);
                return value;
            }
        };
        class PDU_LPCh7_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 28) & 0xF0000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF0000000ull) >> 28);
                return value;
            }
        };
        class PDU_LPCh8_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF00000000ull) >> 32);
                return value;
            }
        };
        class PDU_LPCh9_ShortCnt {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(15);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 36) & 0xF000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000000000ull) >> 36);
                return value;
            }
        };
        class PDU_LPCh10_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0x30000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x30000000000ull) >> 40);
                return value;
            }
        };
        class PDU_LPCh1_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 42) & 0xC0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC0000000000ull) >> 42);
                return value;
            }

            // Value table of signal 'PDU_LPCh1_State'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t STATUS_CHANGE_PENDING = 1;
            constexpr static uint8_t OUTPUT_SHORT_CIRCUIT = 2;
            constexpr static uint8_t EXTERNAL_VOLTAGE = 3;
        };
        class PDU_LPCh2_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 44) & 0x300000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x300000000000ull) >> 44);
                return value;
            }
        };
        class PDU_LPCh3_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 46) & 0xC00000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC00000000000ull) >> 46);
                return value;
            }
        };
        class PDU_LPCh4_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0x3000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3000000000000ull) >> 48);
                return value;
            }
        };
        class PDU_LPCh5_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 50) & 0xC000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC000000000000ull) >> 50);
                return value;
            }
        };
        class PDU_LPCh6_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 52) & 0x30000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x30000000000000ull) >> 52);
                return value;
            }
        };
        class PDU_LPCh7_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 54) & 0xC0000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC0000000000000ull) >> 54);
                return value;
            }
        };
        class PDU_LPCh8_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0x300000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x300000000000000ull) >> 56);
                return value;
            }
        };
        class PDU_LPCh9_State {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x49A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 58) & 0xC00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xC00000000000000ull) >> 58);
                return value;
            }
        };
        class PDU_LV_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(40.95);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.01f);
            }
        };
        class PDU_LV_Voltage {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(40.95);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xFFF000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000ull) >> 12);
                return value * (0.01f);
            }
        };
        class PDU_LV_SOC {
            public:
            using dataType = int8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x4DA };
            constexpr static int8_t min = static_cast<int8_t>(0);
            constexpr static int8_t max = static_cast<int8_t>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int8_t value = static_cast<int8_t>((intel & 0xFF000000ull) >> 24);
                // Convert raw bits to signed value
                SignedConverter8Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class PDU_LPCh1_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x51A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.002f);
            }
        };
        class PDU_LPCh2_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x51A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xFFF000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000ull) >> 12);
                return value * (0.002f);
            }
        };
        class PDU_LPCh3_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x51A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000ull) >> 24);
                return value * (0.002f);
            }
        };
        class PDU_LPCh4_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x51A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 36) & 0xFFF000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000ull) >> 36);
                return value * (0.002f);
            }
        };
        class PDU_LPCh5_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x51A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000000ull) >> 48);
                return value * (0.002f);
            }
        };
        class PDU_LPCh10_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x55A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value * (0.002f);
            }
        };
        class PDU_LPCh6_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x55A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xFFF000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000ull) >> 12);
                return value * (0.002f);
            }
        };
        class PDU_LPCh7_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x55A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000ull) >> 24);
                return value * (0.002f);
            }
        };
        class PDU_LPCh8_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x55A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 36) & 0xFFF000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000ull) >> 36);
                return value * (0.002f);
            }
        };
        class PDU_LPCh9_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x55A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(8.19);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.002f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFF000000000000ull) >> 48);
                return value * (0.002f);
            }
        };
        class PDU_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA, 0x61A };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'PDU_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
            constexpr static uint16_t BATTERVOLTAGELOW = 2048;
            constexpr static uint16_t BATTERVOLTAGECRITICAL = 2049;
            constexpr static uint16_t OVERTEMPWARN = 2050;
            constexpr static uint16_t OVERTEMPCRITICAL = 2051;
            constexpr static uint16_t BATTERYOVERCURRENT = 2128;
            constexpr static uint16_t CURRENTREADINTERVAL = 2304;
            constexpr static uint16_t STATUSSENDINTERVAL = 2305;
            constexpr static uint16_t WATCHDOGTIMEOUT = 2306;
            constexpr static uint16_t PROJECTXXENABLED = 2560;
            constexpr static uint16_t LEDCOMMANDS = 2562;
            constexpr static uint16_t COOLINGPUMPENABLED = 2816;
        };
        class PDU_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x59A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'PDU_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class PDU_OD_CoolingPumpEnabled {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2816            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2816);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2816) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CoolingPumpEnabled'
            constexpr static uint8_t DISABLE = 0;
            constexpr static uint8_t ENABLE = 1;

            // Attributes of signal 'PDU_OD_CoolingPumpEnabled'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class PDU_OD_LedCommands {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2562            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2562);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2562) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_LedCommands'
            constexpr static uint16_t NONE = 0;
            constexpr static uint16_t WHIPEANIMATION = 1;
            constexpr static uint16_t MUGREENANIMATION = 2;
            constexpr static uint16_t RAINBOWANIMATION = 3;
            constexpr static uint16_t FLASHLIGHTS = 4;
            constexpr static uint16_t SNAKEANIMATION = 5;
            constexpr static uint16_t BLINKPINK = 6;
            constexpr static uint16_t MULTIWHIPE = 7;
            constexpr static uint16_t EMERGENCY = 8;

            // Attributes of signal 'PDU_OD_LedCommands'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class PDU_OD_projectXXEnabled {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2560            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2560);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2560) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_projectXXEnabled'
            constexpr static uint8_t DISABLE = 0;
            constexpr static uint8_t ENABLE = 1;

            // Attributes of signal 'PDU_OD_projectXXEnabled'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class PDU_OD_watchdogTimeout {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2306            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2306);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2306) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_watchdogTimeout'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 25.0f;
            constexpr static float CANzero_SDO_Default = 25.0f;
        };
        class PDU_OD_statusSendInterval {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2305            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2305);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2305) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_statusSendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 20.0f;
            constexpr static float CANzero_SDO_Default = 20.0f;
        };
        class PDU_OD_currentReadInterval {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2304            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2304);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2304) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_currentReadInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 100.0f;
            constexpr static float CANzero_SDO_Default = 100.0f;
        };
        class PDU_OD_batteryOvercurrent {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2128            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 2128);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2128) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'PDU_OD_batteryOvercurrent'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1500.0f;
            constexpr static float CANzero_SDO_Default = 15.0f;
        };
        class PDU_OD_overTempCritical {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2051            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 2051);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2051) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'PDU_OD_overTempCritical'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 700.0f;
            constexpr static float CANzero_SDO_Default = 70.0f;
        };
        class PDU_OD_overTempWarn {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2050            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 2050);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2050) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }

            // Attributes of signal 'PDU_OD_overTempWarn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 400.0f;
            constexpr static float CANzero_SDO_Default = 40.0f;
        };
        class PDU_OD_batterVoltageCritical {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2049            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 2049);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2049) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'PDU_OD_batterVoltageCritical'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2100.0f;
            constexpr static float CANzero_SDO_Default = 21.0f;
        };
        class PDU_OD_batterVoltageLow {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2048            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 2048);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2048) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f);
            }

            // Attributes of signal 'PDU_OD_batterVoltageLow'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 2220.0f;
            constexpr static float CANzero_SDO_Default = 22.2f;
        };
        class PDU_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'PDU_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN2_Status {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'PDU_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class PDU_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'PDU_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class PDU_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'PDU_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'PDU_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_Status {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'PDU_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class PDU_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'PDU_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class PDU_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'PDU_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_BuildTime {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_BuildDate {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_ChipUID2 {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_ChipUID1 {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_SdcOut {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_SdcIn {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_runtime {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_InputVoltage {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'PDU_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_BoardTemp {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'PDU_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_MemFree {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'PDU_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_CpuUsage {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                PDU_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'PDU_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class PDU_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'PDU_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class PDU_OD_DbcVersion {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_StackVersion {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class PDU_OD_NodeStatus {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'PDU_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'PDU_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_OD_NodeID {
            public:
            // This signal is multiplexed by PDU_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x59A, 0x5DA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                PDU_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (PDU_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'PDU_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class PDU_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x71A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'PDU_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class HVCU_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'HVCU_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W1_HighVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'HVCU_W1_HighVoltage'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W2_PreChargeOn {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'HVCU_W2_PreChargeOn'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W3_Bir1On {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'HVCU_W3_Bir1On'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W4_Bir2On {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }

            // Value table of signal 'HVCU_W4_Bir2On'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W5_Bir3On {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }

            // Value table of signal 'HVCU_W5_Bir3On'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W6_Bir4On {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }

            // Value table of signal 'HVCU_W6_Bir4On'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W7_IsolationResistanceLow {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 7) & 0x80ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80ull) >> 7);
                return value;
            }

            // Value table of signal 'HVCU_W7_IsolationResistanceLow'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_W8_ChargingMode {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }

            // Value table of signal 'HVCU_W8_ChargingMode'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVCU_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'HVCU_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E1_IMDError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }

            // Value table of signal 'HVCU_E1_IMDError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E2_BMSError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'HVCU_E2_BMSError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E3_PrechargeError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }

            // Value table of signal 'HVCU_E3_PrechargeError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E4_BMSPermissionMissing {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_E4_BMSPermissionMissing'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E5_DischargeTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }

            // Value table of signal 'HVCU_E5_DischargeTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E6_DischargeError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0x40000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000ull) >> 18);
                return value;
            }

            // Value table of signal 'HVCU_E6_DischargeError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E7_BALError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 19) & 0x80000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80000ull) >> 19);
                return value;
            }

            // Value table of signal 'HVCU_E7_BALError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E8_VoltageMeasuring {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 20) & 0x100000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100000ull) >> 20);
                return value;
            }

            // Value table of signal 'HVCU_E8_VoltageMeasuring'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E9_HVSLError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 21) & 0x200000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200000ull) >> 21);
                return value;
            }

            // Value table of signal 'HVCU_E9_HVSLError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E10_BIR1Error {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 22) & 0x400000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400000ull) >> 22);
                return value;
            }

            // Value table of signal 'HVCU_E10_BIR1Error'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E11_BIR2Error {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 23) & 0x800000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800000ull) >> 23);
                return value;
            }

            // Value table of signal 'HVCU_E11_BIR2Error'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E12_BIR3Error {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0x1000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000ull) >> 24);
                return value;
            }

            // Value table of signal 'HVCU_E12_BIR3Error'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E13_BIR4Error {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 25) & 0x2000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000000ull) >> 25);
                return value;
            }

            // Value table of signal 'HVCU_E13_BIR4Error'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E14_HVMPError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 26) & 0x4000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000000ull) >> 26);
                return value;
            }

            // Value table of signal 'HVCU_E14_HVMPError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E15_SDCOpen {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 27) & 0x8000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000000ull) >> 27);
                return value;
            }

            // Value table of signal 'HVCU_E15_SDCOpen'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E16_NoEnable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 28) & 0x10000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000000ull) >> 28);
                return value;
            }

            // Value table of signal 'HVCU_E16_NoEnable'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E17_ControlMessageTimeout {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 29) & 0x20000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000000ull) >> 29);
                return value;
            }

            // Value table of signal 'HVCU_E17_ControlMessageTimeout'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E18_SDCSwitchError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 30) & 0x40000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000000ull) >> 30);
                return value;
            }

            // Value table of signal 'HVCU_E18_SDCSwitchError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_E19_ChargingModeError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x8A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 31) & 0x80000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80000000ull) >> 31);
                return value;
            }

            // Value table of signal 'HVCU_E19_ChargingModeError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class HVCU_TX_InternalStatus {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x18A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x7ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x7ull));
                return value;
            }

            // Value table of signal 'HVCU_TX_InternalStatus'
            constexpr static uint8_t STARTUP = 0;
            constexpr static uint8_t IDLE = 1;
            constexpr static uint8_t ENABLE_SDC = 2;
            constexpr static uint8_t PRECHARGING = 3;
            constexpr static uint8_t ACTIVE = 4;
            constexpr static uint8_t DISCHARGING = 5;
            constexpr static uint8_t DISABLE_SDC = 6;
            constexpr static uint8_t ERROR = 7;
        };
        class HVCU_TX_Status {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x18A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x38ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x38ull) >> 3);
                return value;
            }

            // Value table of signal 'HVCU_TX_Status'
            constexpr static uint8_t DEACTIVATED = 0;
            constexpr static uint8_t ACTIVATED = 1;
            constexpr static uint8_t STARTUP = 2;
            constexpr static uint8_t SHUTDOWN = 3;
            constexpr static uint8_t ERROR = 4;
        };
        class HVCU_TX_ErrorFlag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x18A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }

            // Value table of signal 'HVCU_TX_ErrorFlag'
            constexpr static bool NO_ERROR = 0;
            constexpr static bool ERROR = 1;
        };
        class HVCU_TX_Enabled {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x18A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 7) & 0x80ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80ull) >> 7);
                return value;
            }

            // Value table of signal 'HVCU_TX_Enabled'
            constexpr static bool DISABLED = 0;
            constexpr static bool ENABLED = 1;
        };
        class HVCU_RX_Enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'HVCU_RX_Enable'
            constexpr static bool DISABLE = 0;
            constexpr static bool ENABLE = 1;
        };
        class HVCU_RX_Activate {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'HVCU_RX_Activate'
            constexpr static bool DEACTIVATE = 0;
            constexpr static bool ACTIVATE = 1;
        };
        class HVCU_RX_ErrorReset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'HVCU_RX_ErrorReset'
            constexpr static bool NO_RESET = 0;
            constexpr static bool RESET = 1;
        };
        class HVCU_RX_Charging {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'HVCU_RX_Charging'
            constexpr static bool NOT_CHARGING = 0;
            constexpr static bool CHARGING = 1;
        };
        class HVCU_IMD_DutyCycle {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x28A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class HVCU_IMD_Frequency {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x28A };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(60);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class HVCU_IMD_Isolation_Resistance {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x28A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }
        };
        class HVCU_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA, 0x60A };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'HVCU_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class HVCU_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x58A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'HVCU_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class HVCU_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'HVCU_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN2_Status {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'HVCU_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class HVCU_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'HVCU_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class HVCU_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'HVCU_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'HVCU_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_Status {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'HVCU_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class HVCU_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'HVCU_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class HVCU_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'HVCU_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_BuildTime {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_BuildDate {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_ChipUID2 {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_ChipUID1 {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_SdcOut {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_SdcIn {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_runtime {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_InputVoltage {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'HVCU_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_BoardTemp {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'HVCU_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_MemFree {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'HVCU_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_CpuUsage {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVCU_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'HVCU_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 10.0f;
            constexpr static float CANzero_SDO_Default = 10.0f;
        };
        class HVCU_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'HVCU_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class HVCU_OD_DbcVersion {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_StackVersion {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class HVCU_OD_NodeStatus {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVCU_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'HVCU_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_OD_NodeID {
            public:
            // This signal is multiplexed by HVCU_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x58A, 0x5CA };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVCU_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVCU_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVCU_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVCU_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x70A };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'HVCU_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class HVTU_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x99 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'HVTU_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class HVTU_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x99 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'HVTU_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class SCIMO_V_SET_U_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E5 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.34);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.02f);
            }
        };
        class SCIMO_V_SET_V_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E5 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.34);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.02f);
            }
        };
        class SCIMO_V_SET_W_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E5 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.34);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.02f);
            }
        };
        class SCIMO_I_MES_U_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E4 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.34);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.02f);
            }
        };
        class SCIMO_I_MES_V_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E4 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.34);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.02f);
            }
        };
        class SCIMO_I_MES_W_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E4 };
            constexpr static float min = static_cast<float>(-655.36);
            constexpr static float max = static_cast<float>(655.34);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.02f);
            }
        };
        class SCIMO_Temp_RotorAmbient_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5D0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_ADS_Ambient_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5D0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_ThermocoupleK_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5D0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_ThermocoupleJ_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5D0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_RotorAmbient_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5C0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_ADS_Ambient_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5C0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_ThermocoupleK_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5C0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_ThermocoupleJ_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5C0 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_NumOfSamples {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5B0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                uint16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                return value;
            }
        };
        class SCIMO_I_D_MOT {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A0 };
            constexpr static float min = static_cast<float>(-819.2);
            constexpr static float max = static_cast<float>(819.175);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.025f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.025f);
            }
        };
        class SCIMO_I_Q_MOT {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A0 };
            constexpr static float min = static_cast<float>(-819.2);
            constexpr static float max = static_cast<float>(819.175);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.025f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.025f);
            }
        };
        class SCIMO_U_D_MOT {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A0 };
            constexpr static float min = static_cast<float>(-819.2);
            constexpr static float max = static_cast<float>(819.175);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.025f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.025f);
            }
        };
        class SCIMO_U_Q_MOT {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A0 };
            constexpr static float min = static_cast<float>(-819.2);
            constexpr static float max = static_cast<float>(819.175);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.025f)));
                motorola |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.025f);
            }
        };
        class SCIMO_Temp_Rotor_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x540 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_PT100A_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x540 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_PT100B_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x540 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_Rotor_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x530 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_PT100A_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x530 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_Temp_PT100B_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x530 };
            constexpr static float min = static_cast<float>(-13.84);
            constexpr static float max = static_cast<float>(313.835);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value - (150.0f)) / (0.005f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.005f) + (150.0f);
            }
        };
        class SCIMO_tempPCB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5F0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF00000000000000ull) >> 56);
                return value;
            }
        };
        class SCIMO_tempAUX1 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5F0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF000000000000ull) >> 48);
                return value;
            }
        };
        class SCIMO_tempAUX2 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5F0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class SCIMO_I_LV {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5F0 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(2.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.01f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF00000000ull) >> 32);
                return value * (0.01f);
            }
        };
        class SCIMO_VCC_LV {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5F0 };
            constexpr static float min = static_cast<float>(6);
            constexpr static float max = static_cast<float>(69.75);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (6.0f)) / (0.25f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF000000ull) >> 24);
                return value * (0.25f) + (6.0f);
            }
        };
        class SCIMO_tempCPU {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5F0 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(127.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }
        };
        class SCIMO_T_FET_MOT2 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF00000000000000ull) >> 56);
                return value;
            }
        };
        class SCIMO_FSM_State_MOT2 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 53) & 0xE0000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xE0000000000000ull) >> 53);
                return value;
            }

            // Value table of signal 'SCIMO_FSM_State_MOT2'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t INITIAL_FAULT = 1;
            constexpr static uint8_t DISABLED = 2;
            constexpr static uint8_t READY = 3;
            constexpr static uint8_t SYSTEM_CHECK = 4;
            constexpr static uint8_t ACTIVE = 5;
            constexpr static uint8_t FAULT = 6;
            constexpr static uint8_t PERMANENT_FAULT = 7;
        };
        class SCIMO_ctrlMode_MOT2 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 50) & 0x1C000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0x1C000000000000ull) >> 50);
                return value;
            }
        };
        class SCIMO_enable_MOT2 {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 49) & 0x2000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x2000000000000ull) >> 49);
                return value;
            }
        };
        class SCIMO_extPulsEnable_MOT2 {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0x1000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x1000000000000ull) >> 48);
                return value;
            }
        };
        class SCIMO_pulsEnable_MOT2 {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 47) & 0x800000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x800000000000ull) >> 47);
                return value;
            }
        };
        class SCIMO_uZK_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.1f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0x7FFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0x7FFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter15Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.1f);
            }
        };
        class SCIMO_temp_MOT2 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class SCIMO_temp_MOT1_ {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x580 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class SCIMO_T_FET_MOT1 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF00000000000000ull) >> 56);
                return value;
            }
        };
        class SCIMO_FSM_State_MOT1 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 53) & 0xE0000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xE0000000000000ull) >> 53);
                return value;
            }

            // Value table of signal 'SCIMO_FSM_State_MOT1'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t INITIAL_FAULT = 1;
            constexpr static uint8_t DISABLED = 2;
            constexpr static uint8_t READY = 3;
            constexpr static uint8_t SYSTEM_CHECK = 4;
            constexpr static uint8_t ACTIVE = 5;
            constexpr static uint8_t FAULT = 6;
            constexpr static uint8_t PERMANENT_FAULT = 7;
        };
        class SCIMO_ctrlMode_MOT1 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 50) & 0x1C000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0x1C000000000000ull) >> 50);
                return value;
            }
        };
        class SCIMO_enable_MOT1 {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 49) & 0x2000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x2000000000000ull) >> 49);
                return value;
            }
        };
        class SCIMO_extPulsEnable_MOT1 {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0x1000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x1000000000000ull) >> 48);
                return value;
            }
        };
        class SCIMO_pulsEnable_MOT1 {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 47) & 0x800000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x800000000000ull) >> 47);
                return value;
            }
        };
        class SCIMO_uZK_MOT1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.1f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0x7FFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0x7FFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter15Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.1f);
            }
        };
        class SCIMO_temp_MOT1 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class SCIMO_I_AUX_MOT1 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x570 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 8) & 0xFFFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00ull) >> 8);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class I_D_MOT1 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class I_Q_MOT1 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class I_D_MOT2 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class I_Q_MOT2 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E0 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_I_REQ_LOWPASS_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E6 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(409.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.05f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 51) & 0xFFF8000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0xFFF8000000000000ull) >> 51);
                return value * (0.05f);
            }
        };
        class SCIMO_f_REQ_LOWPASS_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E6 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(409.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.05f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 35) & 0xFFF800000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0xFFF800000000ull) >> 35);
                return value * (0.05f);
            }
        };
        class SCIMO_I_D_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E6 };
            constexpr static float min = static_cast<float>(-1638.4);
            constexpr static float max = static_cast<float>(1638.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.05f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.05f);
            }
        };
        class SCIMO_I_Q_MOT2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5E6 };
            constexpr static float min = static_cast<float>(-1638.4);
            constexpr static float max = static_cast<float>(1638.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.05f)));
                motorola |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.05f);
            }
        };
        class SCIMO_errNum_MOT1 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x520 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF00000000000000ull) >> 56);
                return value;
            }

            // Value table of signal 'SCIMO_errNum_MOT1'
            constexpr static uint8_t KEIN_FEHLER_AKTIV = 0;
            constexpr static uint8_t PARAMETER_FEHLER = 1;
            constexpr static uint8_t INTERPOLOATOR_FEHLER = 2;
            constexpr static uint8_t VERSORGUNG = 3;
            constexpr static uint8_t PS_WATCHDOG = 4;
            constexpr static uint8_t PS_ERROR = 5;
            constexpr static uint8_t COMMUTATION = 6;
            constexpr static uint8_t VERSION = 7;
            constexpr static uint8_t PULSLOCK_FEHLER = 9;
            constexpr static uint8_t ENCODER_FEHLER = 10;
            constexpr static uint8_t U_ZK_ZU_KLEIN = 20;
            constexpr static uint8_t U_ZK_ZU_GROSS = 21;
            constexpr static uint8_t MOTOR_TEMP = 24;
            constexpr static uint8_t WATCHDOG = 26;
            constexpr static uint8_t PHASENUEBERSTROM_4_SAMPLE = 101;
            constexpr static uint8_t PHASENUEBERSTROM = 102;
            constexpr static uint8_t SUMMENUEBERSTROM = 103;
            constexpr static uint8_t UEBERTEMPERATUR = 104;
            constexpr static uint8_t ENCODERFEHLER = 110;
            constexpr static uint8_t UEBERDREHZAHL = 120;
            constexpr static uint8_t UNTERDREHZAHL = 121;
        };
        class SCIMO_errNum_MOT2 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x520 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xFF000000000000ull) >> 48);
                return value;
            }

            // Value table of signal 'SCIMO_errNum_MOT2'
            constexpr static uint8_t KEIN_FEHLER_AKTIV = 0;
            constexpr static uint8_t PARAMETER_FEHLER = 1;
            constexpr static uint8_t INTERPOLOATOR_FEHLER = 2;
            constexpr static uint8_t VERSORGUNG = 3;
            constexpr static uint8_t PS_WATCHDOG = 4;
            constexpr static uint8_t PS_ERROR = 5;
            constexpr static uint8_t COMMUTATION = 6;
            constexpr static uint8_t VERSION = 7;
            constexpr static uint8_t PULSLOCK_FEHLER = 9;
            constexpr static uint8_t ENCODER_FEHLER = 10;
            constexpr static uint8_t U_ZK_ZU_KLEIN = 20;
            constexpr static uint8_t U_ZK_ZU_GROSS = 21;
            constexpr static uint8_t MOTOR_TEMP = 24;
            constexpr static uint8_t WATCHDOG = 26;
            constexpr static uint8_t PHASENUEBERSTROM_4_SAMPLE = 101;
            constexpr static uint8_t PHASENUEBERSTROM = 102;
            constexpr static uint8_t SUMMENUEBERSTROM = 103;
            constexpr static uint8_t UEBERTEMPERATUR = 104;
            constexpr static uint8_t ENCODERFEHLER = 110;
            constexpr static uint8_t UEBERDREHZAHL = 120;
            constexpr static uint8_t UNTERDREHZAHL = 121;
        };
        class SCIMO_warnNum_MOT1 {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x520 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(1023);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 34) & 0xFFC00000000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0xFFC00000000ull) >> 34);
                return value;
            }

            // Value table of signal 'SCIMO_warnNum_MOT1'
            constexpr static uint16_t KEIN_WARNING = 0;
            constexpr static uint16_t COMM = 1;
            constexpr static uint16_t COMMUTATION_SUCCEDDED = 2;
            constexpr static uint16_t COMM1 = 10;
            constexpr static uint16_t COMM1_01 = 11;
            constexpr static uint16_t COMM1_02 = 12;
            constexpr static uint16_t COMM1_03 = 13;
            constexpr static uint16_t COMM1_04 = 14;
            constexpr static uint16_t COMM1_05 = 15;
            constexpr static uint16_t COMM1_06 = 16;
            constexpr static uint16_t COMM1_07 = 17;
            constexpr static uint16_t COMM1_08 = 18;
            constexpr static uint16_t COMM1_09 = 19;
            constexpr static uint16_t COMM1_10 = 20;
            constexpr static uint16_t COMM1_11 = 21;
            constexpr static uint16_t GENAUIGKEIT = 30;
            constexpr static uint16_t POWERMAX = 31;
            constexpr static uint16_t POWERMIN = 32;
            constexpr static uint16_t DREHZAHLLIMIT = 33;
            constexpr static uint16_t MAX_TORQUE = 50;
            constexpr static uint16_t TORQUE_CHANGE = 51;
            constexpr static uint16_t SPANNUNGSGRENZE = 52;
            constexpr static uint16_t KENNFELD_GRENZE = 53;
            constexpr static uint16_t U_ZK_ZU_GROSS = 60;
            constexpr static uint16_t COMM2 = 101;
            constexpr static uint16_t COMM2_01 = 102;
            constexpr static uint16_t UEBERTEMPERATUR = 104;
            constexpr static uint16_t COMM3 = 201;
            constexpr static uint16_t COMM3_01 = 202;
            constexpr static uint16_t COMM4 = 301;
            constexpr static uint16_t COMM4_01 = 302;
            constexpr static uint16_t COMM5 = 401;
            constexpr static uint16_t COMM5_01 = 402;
            constexpr static uint16_t PARAMETER_VERSION = 1001;
            constexpr static uint16_t VERSION = 1002;
        };
        class SCIMO_warnNum_MOT2 {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x520 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                uint16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0x3FF000000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0x3FF000000ull) >> 24);
                return value;
            }

            // Value table of signal 'SCIMO_warnNum_MOT2'
            constexpr static uint16_t KEIN_WARNING = 0;
            constexpr static uint16_t COMM = 1;
            constexpr static uint16_t COMMUTATION_SUCCEDDED = 2;
            constexpr static uint16_t COMM1 = 10;
            constexpr static uint16_t COMM1_01 = 11;
            constexpr static uint16_t COMM1_02 = 12;
            constexpr static uint16_t COMM1_03 = 13;
            constexpr static uint16_t COMM1_04 = 14;
            constexpr static uint16_t COMM1_05 = 15;
            constexpr static uint16_t COMM1_06 = 16;
            constexpr static uint16_t COMM1_07 = 17;
            constexpr static uint16_t COMM1_08 = 18;
            constexpr static uint16_t COMM1_09 = 19;
            constexpr static uint16_t COMM1_10 = 20;
            constexpr static uint16_t COMM1_11 = 21;
            constexpr static uint16_t GENAUIGKEIT = 30;
            constexpr static uint16_t POWERMAX = 31;
            constexpr static uint16_t POWERMIN = 32;
            constexpr static uint16_t DREHZAHLLIMIT = 33;
            constexpr static uint16_t MAX_TORQUE = 50;
            constexpr static uint16_t TORQUE_CHANGE = 51;
            constexpr static uint16_t SPANNUNGSGRENZE = 52;
            constexpr static uint16_t KENNFELD_GRENZE = 53;
            constexpr static uint16_t U_ZK_ZU_GROSS = 60;
            constexpr static uint16_t COMM2 = 101;
            constexpr static uint16_t COMM2_01 = 102;
            constexpr static uint16_t UEBERTEMPERATUR = 104;
            constexpr static uint16_t COMM3 = 201;
            constexpr static uint16_t COMM3_01 = 202;
            constexpr static uint16_t COMM4 = 301;
            constexpr static uint16_t COMM4_01 = 302;
            constexpr static uint16_t COMM5 = 401;
            constexpr static uint16_t COMM5_01 = 402;
            constexpr static uint16_t PARAMETER_VERSION = 1001;
            constexpr static uint16_t VERSION = 1002;
        };
        class SCIMO_n_gw_MOT1 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x550 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 48) & 0xFFFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000000000ull) >> 48);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_M_ist_gw_MOT1 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x550 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 32) & 0xFFFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF00000000ull) >> 32);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_n_gw_MOT2 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x550 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_M_ist_gw_MOT2 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x550 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_MOT2_ctrlMode_mz {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 61) & 0xE000000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0xE000000000000000ull) >> 61);
                return value;
            }
        };
        class SCIMO_MOT2_f_dir {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 60) & 0x1000000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x1000000000000000ull) >> 60);
                return value;
            }
        };
        class SCIMO_MOT2_freqSp {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(1310.7);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.02f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 40) & 0xFFFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0xFFFF0000000000ull) >> 40);
                return value * (0.02f);
            }
        };
        class SCIMO_MOT2_VISp {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(655.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.01f)));
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((motorola & 0xFFFF000000ull) >> 24);
                return value * (0.01f);
            }
        };
        class SCIMO_MOT2_A1 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(2.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f);
            }

            // Attributes of signal 'SCIMO_MOT2_A1'
            constexpr static float GenSigStartValue = 100.0f;
        };
        class SCIMO_MOT2_A2 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(2.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f);
            }

            // Attributes of signal 'SCIMO_MOT2_A2'
            constexpr static float GenSigStartValue = 100.0f;
        };
        class SCIMO_MOT2_A3 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x513 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(2.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f);
            }

            // Attributes of signal 'SCIMO_MOT2_A3'
            constexpr static float GenSigStartValue = 100.0f;
        };
        class SCIMO_MOT1_enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 63) & 0x8000000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x8000000000000000ull) >> 63);
                return value;
            }
        };
        class SCIMO_MOT1_ctrlMode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 60) & 0x7000000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0x7000000000000000ull) >> 60);
                return value;
            }
        };
        class SCIMO_MOT1_reset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 59) & 0x800000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x800000000000000ull) >> 59);
                return value;
            }
        };
        class SCIMO_MOT1_targetSp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 40) & 0xFFFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000000000ull) >> 40);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_MOT1_limitSp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000ull) >> 24);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_MOT2_enable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x510 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 63) & 0x8000000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x8000000000000000ull) >> 63);
                return value;
            }
        };
        class SCIMO_MOT2_ctrlMode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x510 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 60) & 0x7000000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((motorola & 0x7000000000000000ull) >> 60);
                return value;
            }
        };
        class SCIMO_MOT2_reset {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x510 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                motorola |= (static_cast<uint64_t>(rawValue) << 59) & 0x800000000000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((motorola & 0x800000000000000ull) >> 59);
                return value;
            }
        };
        class SCIMO_MOT2_targetSp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x510 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 40) & 0xFFFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF0000000000ull) >> 40);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class SCIMO_MOT2_limitSp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x510 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                int16_t rawValue = (value);
                motorola |= (static_cast<uint64_t>(rawValue) << 24) & 0xFFFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((motorola & 0xFFFF000000ull) >> 24);
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value;
            }
        };
        class EMUS_VoltOverallParam_MinCellVol {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_VoltOverallParam_MaxCellVol {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_VoltOverallParam_AvrgCellVo {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_VoltOverallParams_TVoltSecB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class EMUS_VoltOverallParams_TVoltLSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class EMUS_VoltOverallParams_TVoltMSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class EMUS_VoltOverallParams_TVoltThir {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50001 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value;
            }
        };
        class EMUS_OverallParams_IgnitionKey {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_IgnitionKey'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_ChargerMains {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_ChargerMains'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_FastCharge {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_FastCharge'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_LeakageSensor {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_LeakageSensor'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_ChargerEnable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_ChargerEnable'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_HeaterEnable {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 9) & 0x200ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200ull) >> 9);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_HeaterEnable'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_BatteryContac {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x400ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400ull) >> 10);
                return value;
            }
        };
        class EMUS_OverallParams_BatteryFan {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 11) & 0x800ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800ull) >> 11);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_BatteryFan'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_PowerReductio {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }
        };
        class EMUS_OverallParams_ChargingInter {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }
        };
        class EMUS_OverallParams_DCDC_Control {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_DCDC_Control'
            constexpr static bool OFF = 0;
            constexpr static bool ON = 1;
        };
        class EMUS_OverallParams_ContactorPreC {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }
        };
        class EMUS_OverallParams_NumberOfCells {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class EMUS_OverallParams_ChargingStage {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }

            // Value table of signal 'EMUS_OverallParams_ChargingStage'
            constexpr static uint8_t OFF = 0;
            constexpr static uint8_t ON = 1;
        };
        class EMUS_OverallParams_ChrgStageDura {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class EMUS_OverallParams_ChrgStag_0000 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class EMUS_OverallParams_LastChargingE {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value;
            }
        };
        class EMUS_OverallParams_NumberOf_0000 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50000 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_UnderVoltag {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }
        };
        class EMUS_DiagnosticCodes_OverVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_DchrgOvrCur {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_ChrgOverCur {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_CellModOver {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_Leakage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_NoCellComm {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_LowVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_HighCurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 9) & 0x200ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200ull) >> 9);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_HighTempera {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x400ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400ull) >> 10);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_CellOverHea {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 19) & 0x80000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80000ull) >> 19);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_NoCurrentSe {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 20) & 0x100000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100000ull) >> 20);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_PackUnderVo {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 21) & 0x200000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200000ull) >> 21);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_CellVoltVal {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0x1000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000000ull) >> 24);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_CellModTemp {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 25) & 0x2000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000000ull) >> 25);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_CellBalancV {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 26) & 0x4000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000000ull) >> 26);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_NumOfCellsV {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 27) & 0x8000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000000ull) >> 27);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_BatChrgFini {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 28) & 0x10000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000000ull) >> 28);
                return value;
            }
        };
        class EMUS_DiagnosticCodes_CellTempVal {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50007 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 29) & 0x20000000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000000ull) >> 29);
                return value;
            }
        };
        class EMUS_CellModOverallPar_MinCellMo {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50002 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_CellModOverallPar_MaxCellMo {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50002 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_CellModOverallPar_AvgCellMo {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50002 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_CellOverallPar_MinCellTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50008 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_CellOverallPar_MaxCellTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50008 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_CellOverallPar_AvgCellTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50008 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_CellBalancPar_MinCellBalanc {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50003 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_CellBalancPar_MaxCellBalanc {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50003 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_CellBalancPar_AvgCellBalanc {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50003 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_ConfigParams_ParameterID_MS {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_ConfigParams_ParameterID_LS {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class EMUS_ConfigParams_ParameterSize {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class EMUS_ConfigParams_ParameterData_ {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class EMUS_ConfigParams_ParamData_Thir {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class EMUS_ConfigParams_ParamData_SecB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class EMUS_ConfigParams_Parameter_0000 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50400 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value;
            }
        };
        class EMUS_LoginLevel {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50402 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'EMUS_LoginLevel'
            constexpr static uint8_t GUEST = 0;
            constexpr static uint8_t USER = 1;
            constexpr static uint8_t ADMIN = 2;
        };
        class EMUS_ContactorControl_ContactorState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50401 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Attributes of signal 'EMUS_ContactorControl_ContactorState'
            constexpr static char SystemSignalLongSymbol[] = "EMUS_ContactorControl_ContactorState";
        };
        class EMUS_Energy_EstimatedConsumption {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_Energy_EstimatedConsum_0000 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class EMUS_Energy_EstimatedEnergy_MSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class EMUS_Energy_EstimatedEnergy_LSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class EMUS_Energy_EstimatedDistanceLef {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class EMUS_Energy_EstimatedDistan_0000 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class EMUS_Energy_DistanceTraveled_MSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value;
            }
        };
        class EMUS_Energy_DistanceTraveled_LSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50600 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value;
            }
        };
        class EMUS_SOCParams_Current_MSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_SOCParams_Current_LSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }
        };
        class EMUS_SOCParams_EstimatedCharge_M {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class EMUS_SOCParams_EstimatedCharge_L {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class EMUS_SOCParams_EstimatedSOC {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50500 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value;
            }
        };
        class EMUS_Statistics_Identifier {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50404 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'EMUS_Statistics_Identifier'
            constexpr static uint8_t TOTAL_DISHARGE = 0;
            constexpr static uint8_t TOTAL_CHARGE = 1;
            constexpr static uint8_t TOTAL_DISCHARGE_ENERGY = 2;
            constexpr static uint8_t TOTAL_CHARGE_ENERGY = 3;
            constexpr static uint8_t TOTAL_DISCHARGE_TIME = 4;
            constexpr static uint8_t TOTAL_CHARGE_TIME = 5;
            constexpr static uint8_t TOTAL_DISTANCE = 6;
            constexpr static uint8_t MASTER_CLEAR_COUNT = 7;
            constexpr static uint8_t MAX_DISCHARGE_CURRENT = 8;
            constexpr static uint8_t MAX_CHARGE_CURRENT = 9;
            constexpr static uint8_t MIN_CELL_VOLTAGE = 10;
            constexpr static uint8_t MAX_CELL_VOLTAGE = 11;
            constexpr static uint8_t MAX_CELL_VOLTAGE_DIFFERENCE = 12;
            constexpr static uint8_t MIN_PACK_VOLTAGE = 13;
            constexpr static uint8_t MAX_PACK_VOLTAGE = 14;
            constexpr static uint8_t MIN_CELL_MODULE_TEMPERATURE = 15;
            constexpr static uint8_t MAX_CELL_MODULE_TEMPERATURE = 16;
            constexpr static uint8_t MAX_CELL_MODULE_TEMPERATURE_DIFFERENCE = 17;
            constexpr static uint8_t BMS_STARTS_COUNT = 18;
            constexpr static uint8_t UNDER_VOLTAGE_PROTECTION_COUNT = 19;
            constexpr static uint8_t OVER_VOLTAGE_PROTECTION_COUNT = 20;
            constexpr static uint8_t DISCHARGE_OVER_CURRENT_PROTECTION_COUNT = 21;
            constexpr static uint8_t CHARGE_OVER_CURRENT_PROTECTION_COUNT = 22;
            constexpr static uint8_t CELL_MODULE_OVER_HEAT_PROTECTION_COUNT = 23;
            constexpr static uint8_t LEAKAGE_PROTECTION_COUNT = 24;
            constexpr static uint8_t NO_CELL_COMMUNICATION_PROTECTION_COUNT = 25;
            constexpr static uint8_t LOW_VOLTAGE_POWER_REDUCTION_COUNT = 26;
            constexpr static uint8_t HIGH_CURRENT_POWER_REDUCTION_COUNT = 27;
            constexpr static uint8_t HIGH_CELL_MODULE_TEMP_POWER_REDUCTION_COUNT = 28;
            constexpr static uint8_t CHARGER_CONNECTED_COUNT = 29;
            constexpr static uint8_t CHARGER_DISCONNECTED_COUNT = 30;
            constexpr static uint8_t PRE_HEAT_STAGE_COUNT = 31;
            constexpr static uint8_t PRE_CHARGE_STAGE_COUNT = 32;
            constexpr static uint8_t MAIN_CHARGE_STAGE_COUNT = 33;
            constexpr static uint8_t BALANCING_STAGE_COUNT = 34;
            constexpr static uint8_t CHARGING_FINISHED_COUNT = 35;
            constexpr static uint8_t CHARGING_ERROR_COUNT = 36;
            constexpr static uint8_t CHARGING_RETRY_COUNT = 37;
            constexpr static uint8_t TRIPS_COUNT = 38;
            constexpr static uint8_t CHARGE_RESTARTS_COUNT = 39;
            constexpr static uint8_t CELL_OVER_HEAT_PROTECTION_COUNT = 40;
            constexpr static uint8_t HIGH_CELL_TEMPERATURE_POWER_REDUCTION_COUNT = 41;
            constexpr static uint8_t MIN_CELL_TEMPERATURE = 42;
            constexpr static uint8_t MAX_CELL_TEMPERATURE_COUNT = 43;
            constexpr static uint8_t MAX_CELL_TEMPERATURE_DIFFERENCE = 44;
        };
        class EMUS_Statistics_DataType {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50404 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }

            // Value table of signal 'EMUS_Statistics_DataType'
            constexpr static uint8_t STATISTICS_VALUE = 0;
            constexpr static uint8_t ADDITIONAL_VALUE = 1;
            constexpr static uint8_t STATISTICS_TIMESTAMP = 2;
        };
        class EMUS_Statistics_Data_MSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50404 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }
        };
        class EMUS_Statistics_Data_ThirdByte {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50404 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class EMUS_Statistics_Data_SecondByte {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50404 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class EMUS_Statistics_Data_LSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50404 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class EMUS_Events_EntryNumber {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50405 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_Events_DataType {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50405 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value;
            }

            // Value table of signal 'EMUS_Events_DataType'
            constexpr static uint8_t EVENT_INFO_ = 0;
            constexpr static uint8_t EVENT_TIMESTAMP = 1;
        };
        class EMUS_Events_Data_MSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50405 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'EMUS_Events_Data_MSB'
            constexpr static uint8_t NO_EVENT = 0;
            constexpr static uint8_t BMS_STARTED = 1;
            constexpr static uint8_t LOST_COMMUNICATION_TO_CELLS = 2;
            constexpr static uint8_t ESTABLISHED_COMMUNICATION_TO_CELLS = 3;
            constexpr static uint8_t CELLS_VOLTAGE_CRITICALLY_LOW = 4;
            constexpr static uint8_t CRITICAL_LOW_VOLTAGE_RECOVERED = 5;
            constexpr static uint8_t CELLS_VOLTAGE_CRITICALLY_HIGH_ = 6;
            constexpr static uint8_t CRITICAL_HIGH_VOLTAGE_RECOVERED = 7;
            constexpr static uint8_t DISCHARGE_CURRENT_CRITICALLY_HIGH = 8;
            constexpr static uint8_t DISCHARGE_CRITICALLY_HIGH_CURRENT_RECOVERED = 9;
            constexpr static uint8_t CHARGE_CURRENT_CRITICALLY_HIGH = 10;
            constexpr static uint8_t CHARGE_CRITICALLY_HIGH_CURRENT_RECOVERED = 11;
            constexpr static uint8_t CELL_MODULE_TEMPERATURE_CRITICALLY_HIGH = 12;
            constexpr static uint8_t CRITICAL_HIGH_CELL_MODULE_TEMPERATURE_RECOVERED = 13;
            constexpr static uint8_t LEAKAGE_DETECTED = 14;
            constexpr static uint8_t LEAKAGE_RECOVERED = 15;
            constexpr static uint8_t WARNING_LOW_VOLTAGE__REDUCING_POWER = 16;
            constexpr static uint8_t POWER_REDUCTION_DUE_TO_LOW_VOLTAGE_RECOVERED = 17;
            constexpr static uint8_t WARNING_HIGH_CURRENT__REDUCING_POWER = 18;
            constexpr static uint8_t POWER_REDUCTION_DUE_TO_HIGH_CURRENT_RECOVERED = 19;
            constexpr static uint8_t WARNING_HIGH_CELL_MODULE_TEMPERATURE__REDUCING_POWER = 20;
            constexpr static uint8_t POWER_REDUCTION_DUE_TO_HIGH_CELL_MODULE_TEMPERATURE_RECOVERED = 21;
            constexpr static uint8_t CHARGER_CONNECTED = 22;
            constexpr static uint8_t CHARGER_DISCONNECTED = 23;
            constexpr static uint8_t STARTED_PREHEATING_STAGE = 24;
            constexpr static uint8_t STARTED_PRECHARGING_STAGE = 25;
            constexpr static uint8_t STARTED_MAINCHARGING_STAGE = 26;
            constexpr static uint8_t STARTED_BALANCING_STAGE = 27;
            constexpr static uint8_t CHARGING_FINISHED = 28;
            constexpr static uint8_t CHARGING_ERROR_OCCURED = 29;
            constexpr static uint8_t RETRYING_CHARGING = 30;
            constexpr static uint8_t RESTARTING_CHARGING = 31;
            constexpr static uint8_t CELL_TEMPERATURE_CRITICALLY_HIGH = 32;
            constexpr static uint8_t CRITICALLY_HIGH_CELL_TEMPERATURE_RECOVERED = 33;
            constexpr static uint8_t WARNING_HIGH_CELL_TEMPERATURE__REDUCING_POWER = 34;
            constexpr static uint8_t POWER_REDUCTION_DUE_TO_HIGH_CELL_TEMPERATURE_RECOVERED = 35;
        };
        class EMUS_Events_Data_ThirdByte {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50405 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value;
            }
        };
        class EMUS_Events_Data_SecondByte {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50405 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class EMUS_Events_Data_LSB {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50405 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value;
            }
        };
        class EMUS_IndividualCellVoltage_Data_ {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0000 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0001 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0002 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0003 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0004 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0005 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0006 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50100 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0007 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0008 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0009 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0010 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0011 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0012 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0013 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0014 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50101 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0015 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0016 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0017 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0018 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0019 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0020 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0021 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0022 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50102 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0023 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0024 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0025 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0026 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0027 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0028 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0029 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0030 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50103 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0031 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0032 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0033 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0034 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0035 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0036 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0037 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0038 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50104 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0039 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0040 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0041 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0042 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0043 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0044 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0045 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0046 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50105 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0047 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0048 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0049 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0050 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0051 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0052 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0053 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0054 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50106 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0055 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0056 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0057 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0058 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0059 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0060 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0061 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0062 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50107 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0063 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0064 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0065 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0066 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0067 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0068 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0069 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0070 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50108 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0071 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0072 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0073 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0074 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0075 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0076 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0077 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0078 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50109 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0079 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0080 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0081 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0082 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0083 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0084 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0085 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0086 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010A };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0087 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0088 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0089 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0090 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0091 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0092 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0093 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0094 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0095 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0096 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0097 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0098 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0099 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0100 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0101 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0102 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010C };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0103 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0104 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0105 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0106 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0107 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0108 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0109 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0110 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010D };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0111 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0112 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0113 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0114 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0115 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0116 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0117 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0118 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010E };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0119 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0120 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0121 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0122 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0123 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0124 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0125 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0126 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5010F };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0127 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0128 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0129 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0130 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0131 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0132 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0133 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0134 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50110 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0135 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0136 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0137 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0138 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0139 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0140 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0141 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0142 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50111 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellModTemp_Data_ {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0000 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0001 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0002 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0003 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0004 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0005 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0006 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50200 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0007 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0008 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0009 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0010 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0011 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0012 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0013 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0014 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50201 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0015 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0016 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0017 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0018 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0019 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0020 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0021 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0022 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50202 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0023 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0024 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0025 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0026 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0027 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0028 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0029 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0030 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50203 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0031 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0032 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0033 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0034 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0035 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0036 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0037 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0038 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50204 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0039 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0040 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0041 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0042 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0043 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0044 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0045 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0046 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50205 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0047 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0048 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0049 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0050 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0051 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0052 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0053 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0054 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50206 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0055 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0056 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0057 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0058 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0059 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0060 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0061 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0062 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50207 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0063 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0064 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0065 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0066 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0067 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0068 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0069 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0070 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50208 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0071 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0072 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0073 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0074 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0075 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0076 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0077 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0078 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50209 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0079 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0080 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0081 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0082 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0083 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0084 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0085 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0086 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0087 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0088 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0089 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0090 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0091 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0092 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0093 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0094 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020B };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0095 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0096 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0097 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0098 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0099 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0100 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0101 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0102 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0103 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0104 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0105 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0106 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0107 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0108 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0109 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0110 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020D };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0111 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0112 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0113 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0114 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0115 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0116 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0117 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0118 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0119 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0120 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0121 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0122 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0123 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0124 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0125 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0126 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5020F };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0127 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0128 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0129 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0130 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0131 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0132 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0133 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0134 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50210 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0135 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0136 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0137 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0138 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0139 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0140 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0141 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0142 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50211 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperature_D {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0000 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0001 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0002 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0003 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0004 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0005 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0006 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50800 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0007 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0008 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0009 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0010 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0011 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0012 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0013 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0014 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50801 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0015 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0016 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0017 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0018 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0019 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0020 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0021 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0022 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50802 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0023 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0024 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0025 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0026 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0027 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0028 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0029 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0030 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50803 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0031 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0032 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0033 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0034 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0035 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0036 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0037 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0038 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50804 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0039 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0040 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0041 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0042 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0043 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0044 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0045 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0046 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50805 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0047 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0048 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0049 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0050 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0051 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0052 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0053 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0054 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50806 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0055 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0056 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0057 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0058 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0059 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0060 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0061 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0062 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50807 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0063 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0064 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0065 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0066 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0067 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0068 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0069 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0070 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50808 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0071 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0072 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0073 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0074 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0075 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0076 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0077 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0078 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50809 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0079 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0080 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0081 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0082 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0083 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0084 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0085 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0086 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5080A };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_Individual_Cells_Group_Opt_ {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_IndividualCellVoltage__0143 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0144 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0145 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0146 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0147 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0148 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_IndividualCellVoltage__0149 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000B };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.01f) + (2.0f);
            }
        };
        class EMUS_Individual_Cells_Group_0000 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_IndividualCellBalancRate_Da {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0000 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0001 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0002 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0003 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0004 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0005 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0006 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0007 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0008 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0009 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0010 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0011 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0012 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0013 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50300 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0014 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0015 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0016 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0017 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0018 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0019 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0020 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0021 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50301 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0022 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0023 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0024 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0025 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0026 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0027 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0028 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0029 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50302 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0030 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0031 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0032 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0033 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0034 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0035 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0036 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0037 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50303 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0038 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0039 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0040 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0041 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0042 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0043 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0044 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0045 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50304 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0046 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0047 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0048 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0049 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0050 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0051 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0052 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0053 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50305 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0054 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0055 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0056 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0057 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0058 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0059 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0060 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0061 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50306 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0062 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0063 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0064 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0065 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0066 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0067 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0068 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0069 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50307 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0070 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0071 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0072 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0073 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0074 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0075 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0076 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0077 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50308 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0078 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0079 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0080 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0081 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0082 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0083 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0084 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0085 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50309 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0086 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0087 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0088 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0089 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0090 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0091 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0092 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0093 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030A };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0094 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0095 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0096 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0097 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0098 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0099 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0100 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0101 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030B };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0102 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0103 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0104 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0105 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0106 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0107 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0108 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0109 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030C };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0110 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0111 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0112 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0113 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0114 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0115 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0116 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0117 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030D };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0118 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0119 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0120 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0121 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0122 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0123 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0124 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0125 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030E };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0126 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0127 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0128 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0129 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0130 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0131 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0132 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0133 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5030F };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0134 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0135 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0136 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0137 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0138 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0139 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0140 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0141 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50310 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0142 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0143 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0144 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0145 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000ull) >> 24);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0146 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0147 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0148 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF000000000000ull) >> 48);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_IndividualCellBalancRa_0149 {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50311 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000000000ull) >> 56);
                return value * (0.392156862745098f);
            }
        };
        class EMUS_Individual_Cells_Group_0001 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_IndividualCellModTemp__0143 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0144 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0145 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0146 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0147 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0148 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellModTemp__0149 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000C };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_Individual_Cells_Group_0002 {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class EMUS_IndividualCellTemperat_0143 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0144 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0145 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0xFF000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000ull) >> 24);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0146 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000ull) >> 32);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0147 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000000000ull) >> 40);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0148 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 48) & 0xFF000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF000000000000ull) >> 48);
                return value + (-100);
            }
        };
        class EMUS_IndividualCellTemperat_0149 {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B5000E };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 56) & 0xFF00000000000000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00000000000000ull) >> 56);
                return value + (-100);
            }
        };
        class EMUS_LoginSetPasswordStatus {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x19B50403 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }
        };
        class HVTU_EMUS_MinCellVoltage {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x199 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.01f) + (2.0f);
            }
        };
        class HVTU_EMUS_AvgCellVoltage {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x199 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.01f) + (2.0f);
            }
        };
        class HVTU_EMUS_Pack_Voltage {
            public:
            using dataType = double;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x199 };
            constexpr static double min = static_cast<double>(-83886.08);
            constexpr static double max = static_cast<double>(83886.07);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, double value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int32_t rawValue = static_cast<int32_t>(STD_ROUND((value) / (0.01)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
            }
            constexpr static inline double get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int32_t value = static_cast<int32_t>((intel & 0xFFFFFF0000ull) >> 16);
                // Convert raw bits to signed value
                SignedConverter24Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.01);
            }
        };
        class HVTU_EMUS_MaxCellVoltage {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x199 };
            constexpr static float min = static_cast<float>(2);
            constexpr static float max = static_cast<float>(4.55);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (2.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 40) & 0xFF0000000000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000000000ull) >> 40);
                return value * (0.01f) + (2.0f);
            }
        };
        class HVTU_EMUS_AvgCellBalanceRate {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x219 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value * (0.392156862745098f);
            }
        };
        class HVTU_EMUS_MaxCellBalanceRate {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x219 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00ull) >> 8);
                return value * (0.392156862745098f);
            }
        };
        class HVTU_EMUS_MinCellBalanceRate {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x219 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.392156862745098f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.392156862745098f);
            }
        };
        class HVTU_EMUS_MaxCellModTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x299 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class HVTU_EMUS_AvgCellModTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x299 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class HVTU_EMUS_MinCellModTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x299 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class HVTU_EMUS_AvgCellTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x319 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFull));
                return value + (-100);
            }
        };
        class HVTU_EMUS_MaxCellTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x319 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0xFF00ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF00ull) >> 8);
                return value + (-100);
            }
        };
        class HVTU_EMUS_MinCellTemp {
            public:
            using dataType = int16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x319 };
            constexpr static int16_t min = static_cast<int16_t>(-100);
            constexpr static int16_t max = static_cast<int16_t>(155);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, int16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>((value - (-100)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
            }
            constexpr static inline int16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFF0000ull) >> 16);
                return value + (-100);
            }
        };
        class HVTU_EMUS_Diag_BatChargeFinish {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }
        };
        class HVTU_EMUS_Diag_CellBalanceValid {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 1) & 0x2ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2ull) >> 1);
                return value;
            }
        };
        class HVTU_EMUS_Diag_CellModOverHeat {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 2) & 0x4ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4ull) >> 2);
                return value;
            }
        };
        class HVTU_EMUS_Diag_CellModTempValid {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 3) & 0x8ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8ull) >> 3);
                return value;
            }
        };
        class HVTU_EMUS_Diag_CellOverHeat {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 4) & 0x10ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10ull) >> 4);
                return value;
            }
        };
        class HVTU_EMUS_Diag_CellTempValid {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 5) & 0x20ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20ull) >> 5);
                return value;
            }
        };
        class HVTU_EMUS_Diag_CellVoltValid {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 6) & 0x40ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40ull) >> 6);
                return value;
            }
        };
        class HVTU_EMUS_Diag_ChargeOverCurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 7) & 0x80ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x80ull) >> 7);
                return value;
            }
        };
        class HVTU_EMUS_Diag_DchrgOverCurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 8) & 0x100ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x100ull) >> 8);
                return value;
            }
        };
        class HVTU_EMUS_Diag_HighCurrent {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 9) & 0x200ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x200ull) >> 9);
                return value;
            }
        };
        class HVTU_EMUS_Diag_HighTemp {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x400ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x400ull) >> 10);
                return value;
            }
        };
        class HVTU_EMUS_Diag_Leackage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 11) & 0x800ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x800ull) >> 11);
                return value;
            }
        };
        class HVTU_EMUS_Diag_LowVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }
        };
        class HVTU_EMUS_Diag_NoCellComm {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 13) & 0x2000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x2000ull) >> 13);
                return value;
            }
        };
        class HVTU_EMUS_Diag_NumOfCellsVal {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0x4000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x4000ull) >> 14);
                return value;
            }
        };
        class HVTU_EMUS_Diag_NoCurrentSensor {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 15) & 0x8000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x8000ull) >> 15);
                return value;
            }
        };
        class HVTU_EMUS_Diag_OverVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0x10000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x10000ull) >> 16);
                return value;
            }
        };
        class HVTU_EMUS_Diag_Pack_UnderVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 17) & 0x20000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x20000ull) >> 17);
                return value;
            }
        };
        class HVTU_EMUS_Diag_UnderVoltage {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x399 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0x40000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x40000ull) >> 18);
                return value;
            }
        };
        class HVTU_EMUS_Pack_Current {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x3D9 };
            constexpr static float min = static_cast<float>(-3276.8);
            constexpr static float max = static_cast<float>(3276.7);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                int16_t rawValue = static_cast<int16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                int16_t value = static_cast<int16_t>((intel & 0xFFFFull));
                // Convert raw bits to signed value
                SignedConverter16Bits signedConverter{value};
                value = signedConverter.value;
                return value * (0.1f);
            }
        };
        class HVTU_EMUS_Pack_Est_Charge {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x3D9 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(6553.5);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.1f);
            }
        };
        class HVTU_EMUS_Pack_SOC {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x3D9 };
            constexpr static uint8_t min = static_cast<uint8_t>(0);
            constexpr static uint8_t max = static_cast<uint8_t>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 32) & 0xFF00000000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFF00000000ull) >> 32);
                return value;
            }
        };
        class HVTU_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9, 0x619 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'HVTU_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class HVTU_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x599 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'HVTU_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class HVTU_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'HVTU_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN2_Status {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'HVTU_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class HVTU_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'HVTU_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class HVTU_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'HVTU_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'HVTU_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_Status {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'HVTU_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class HVTU_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'HVTU_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class HVTU_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'HVTU_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_BuildTime {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_BuildDate {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_ChipUID2 {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_ChipUID1 {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_SdcOut {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_SdcIn {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_runtime {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_InputVoltage {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'HVTU_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_BoardTemp {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'HVTU_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_MemFree {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'HVTU_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_CpuUsage {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                HVTU_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'HVTU_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class HVTU_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'HVTU_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class HVTU_OD_DbcVersion {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_StackVersion {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class HVTU_OD_NodeStatus {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'HVTU_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'HVTU_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_OD_NodeID {
            public:
            // This signal is multiplexed by HVTU_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x599, 0x5D9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                HVTU_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (HVTU_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'HVTU_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class HVTU_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x719 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'HVTU_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class TelemetryNode_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'TelemetryNode_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class TelemetryNode_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'TelemetryNode_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class TelemetryNode_RX_Shutdown {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x1E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'TelemetryNode_RX_Shutdown'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t SHUTDOWN = 1;
            constexpr static uint8_t REBOOT = 2;
        };
        class TelemetryNode_CAN1_RxErrors {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x522 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(16383);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3FFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0x3FFFull));
                return value;
            }
        };
        class TelemetryNode_CAN1_TxErrors {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x522 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 14) & 0xFFC000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFC000ull) >> 14);
                return value;
            }
        };
        class TelemetryNode_CAN2_RxErrors {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x522 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(16383);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 24) & 0x3FFF000000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0x3FFF000000ull) >> 24);
                return value;
            }
        };
        class TelemetryNode_CAN2_TxErrors {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x522 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 38) & 0xFFC000000000ull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFC000000000ull) >> 38);
                return value;
            }
        };
        class TelemetryNode_CpuUsage {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x562 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(102.3);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.1f)));
                intel |= (static_cast<uint64_t>(rawValue)) & 0x3FFull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0x3FFull));
                return value * (0.1f);
            }
        };
        class TelemetryNode_Temperature {
            public:
            using dataType = float;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x562 };
            constexpr static float min = static_cast<float>(-10);
            constexpr static float max = static_cast<float>(92);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value - (-10.0f)) / (0.4f)));
                intel |= (static_cast<uint64_t>(rawValue) << 10) & 0x3FC00ull;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0x3FC00ull) >> 10);
                return value * (0.4f) + (-10.0f);
            }
        };
        class TelemetryNode_Time {
            public:
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x562 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262143);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 18) & 0xFFFFC0000ull;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFC0000ull) >> 18);
                return value;
            }
        };
        class TelemetryNode_Date {
            public:
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x562 };
            constexpr static uint32_t min = static_cast<uint32_t>(20200000);
            constexpr static uint32_t max = static_cast<uint32_t>(20462143);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint32_t rawValue = static_cast<uint32_t>((value - (20200000)));
                intel |= (static_cast<uint64_t>(rawValue) << 36) & 0x3FFFF000000000ull;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint32_t value = static_cast<uint32_t>((intel & 0x3FFFF000000000ull) >> 36);
                return value + (20200000);
            }
        };
        class TelemetryNode_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2, 0x622 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'TelemetryNode_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
            constexpr static uint16_t SHUTDOWN = 2048;
            constexpr static uint16_t REBOOT = 2049;
            constexpr static uint16_t CANRESTART = 2050;
        };
        class TelemetryNode_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'TelemetryNode_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class TelemetryNode_OD_CanRestart {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 2050            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 2050);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 2050) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CanRestart'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t RESTART_CAN = 1;

            // Attributes of signal 'TelemetryNode_OD_CanRestart'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::WRITE_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_Reboot {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 2049            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 2049);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 2049) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_Reboot'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t REBOOT = 1;

            // Attributes of signal 'TelemetryNode_OD_Reboot'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::WRITE_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_Shutdown {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 2048            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 2048);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 2048) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_Shutdown'
            constexpr static uint8_t NONE = 0;
            constexpr static uint8_t SHUTDOWN = 1;

            // Attributes of signal 'TelemetryNode_OD_Shutdown'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::WRITE_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN2_DelayedTxMessages";
        };
        class TelemetryNode_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'TelemetryNode_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN2_ErrorStatus";
        };
        class TelemetryNode_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN2_DiscardedTxMessages";
        };
        class TelemetryNode_OD_CAN2_Status {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'TelemetryNode_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class TelemetryNode_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'TelemetryNode_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN2_autoErrorReset";
        };
        class TelemetryNode_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'TelemetryNode_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN2_lastErrorCode";
        };
        class TelemetryNode_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN1_DelayedTxMessages";
        };
        class TelemetryNode_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'TelemetryNode_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN1_ErrorStatus";
        };
        class TelemetryNode_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN1_DiscardedTxMessages";
        };
        class TelemetryNode_OD_CAN1_Status {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'TelemetryNode_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class TelemetryNode_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'TelemetryNode_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN1_autoErrorReset";
        };
        class TelemetryNode_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'TelemetryNode_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_CAN1_lastErrorCode";
        };
        class TelemetryNode_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_BuildTime {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_BuildDate {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_ChipUID2 {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_ChipUID1 {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_SdcOut {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_SdcIn {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_runtime {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_InputVoltage {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'TelemetryNode_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_BoardTemp {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'TelemetryNode_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_MemFree {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'TelemetryNode_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_CpuUsage {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'TelemetryNode_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_OdEntrySendInterval";
        };
        class TelemetryNode_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'TelemetryNode_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
            constexpr static char SystemSignalLongSymbol[] = "TelemetryNode_OD_HeartbeatInterval";
        };
        class TelemetryNode_OD_DbcVersion {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_StackVersion {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class TelemetryNode_OD_NodeStatus {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'TelemetryNode_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'TelemetryNode_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_OD_NodeID {
            public:
            // This signal is multiplexed by TelemetryNode_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A2, 0x5E2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                TelemetryNode_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (TelemetryNode_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'TelemetryNode_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class TelemetryNode_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x722 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'TelemetryNode_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class MDB1_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'MDB1_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class MDB1_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB1_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class MDB1_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1, 0x621 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'MDB1_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class MDB1_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB1_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class MDB1_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB1_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN2_Status {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB1_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB1_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB1_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB1_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB1_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB1_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_Status {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB1_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB1_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB1_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB1_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB1_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_BuildTime {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_BuildDate {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_ChipUID2 {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_ChipUID1 {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_SdcOut {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_SdcIn {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_runtime {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_InputVoltage {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'MDB1_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_BoardTemp {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'MDB1_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_MemFree {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'MDB1_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_CpuUsage {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB1_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'MDB1_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class MDB1_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB1_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class MDB1_OD_DbcVersion {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_StackVersion {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB1_OD_NodeStatus {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB1_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'MDB1_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_OD_NodeID {
            public:
            // This signal is multiplexed by MDB1_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A1, 0x5E1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB1_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB1_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB1_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB1_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x721 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'MDB1_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class MDB2_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'MDB2_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class MDB2_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB2_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class MDB2_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3, 0x623 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'MDB2_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class MDB2_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB2_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class MDB2_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB2_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN2_Status {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB2_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB2_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB2_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB2_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB2_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB2_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_Status {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB2_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB2_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB2_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB2_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB2_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_BuildTime {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_BuildDate {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_ChipUID2 {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_ChipUID1 {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_SdcOut {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_SdcIn {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_runtime {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_InputVoltage {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'MDB2_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_BoardTemp {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'MDB2_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_MemFree {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'MDB2_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_CpuUsage {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB2_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'MDB2_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class MDB2_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB2_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class MDB2_OD_DbcVersion {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_StackVersion {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB2_OD_NodeStatus {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB2_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'MDB2_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_OD_NodeID {
            public:
            // This signal is multiplexed by MDB2_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A3, 0x5E3 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB2_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB2_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB2_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB2_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x723 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'MDB2_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class MDB3_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'MDB3_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class MDB3_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB3_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class MDB3_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7, 0x627 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'MDB3_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class MDB3_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB3_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class MDB3_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB3_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN2_Status {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB3_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB3_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB3_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB3_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB3_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB3_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_Status {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB3_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB3_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB3_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB3_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB3_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_BuildTime {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_BuildDate {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_ChipUID2 {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_ChipUID1 {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_SdcOut {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_SdcIn {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_runtime {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_InputVoltage {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'MDB3_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_BoardTemp {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'MDB3_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_MemFree {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'MDB3_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_CpuUsage {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB3_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'MDB3_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class MDB3_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB3_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class MDB3_OD_DbcVersion {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_StackVersion {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB3_OD_NodeStatus {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB3_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'MDB3_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_OD_NodeID {
            public:
            // This signal is multiplexed by MDB3_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A7, 0x5E7 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB3_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB3_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB3_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB3_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x727 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'MDB3_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class MDB4_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'MDB4_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class MDB4_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB4_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class MDB4_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8, 0x628 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'MDB4_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class MDB4_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB4_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class MDB4_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB4_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN2_Status {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB4_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB4_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB4_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB4_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB4_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB4_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_Status {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB4_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB4_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB4_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB4_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB4_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_BuildTime {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_BuildDate {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_ChipUID2 {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_ChipUID1 {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_SdcOut {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_SdcIn {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_runtime {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_InputVoltage {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'MDB4_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_BoardTemp {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'MDB4_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_MemFree {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'MDB4_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_CpuUsage {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB4_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'MDB4_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class MDB4_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB4_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class MDB4_OD_DbcVersion {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_StackVersion {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB4_OD_NodeStatus {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB4_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'MDB4_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_OD_NodeID {
            public:
            // This signal is multiplexed by MDB4_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A8, 0x5E8 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB4_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB4_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB4_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB4_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x728 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'MDB4_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class MDB5_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'MDB5_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class MDB5_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xA9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB5_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class MDB5_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9, 0x629 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'MDB5_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class MDB5_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5A9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB5_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class MDB5_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB5_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN2_Status {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB5_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB5_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB5_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB5_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB5_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB5_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_Status {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB5_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB5_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB5_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB5_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB5_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_BuildTime {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_BuildDate {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_ChipUID2 {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_ChipUID1 {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_SdcOut {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_SdcIn {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_runtime {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_InputVoltage {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'MDB5_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_BoardTemp {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'MDB5_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_MemFree {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'MDB5_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_CpuUsage {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB5_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'MDB5_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class MDB5_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB5_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class MDB5_OD_DbcVersion {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_StackVersion {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB5_OD_NodeStatus {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB5_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'MDB5_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_OD_NodeID {
            public:
            // This signal is multiplexed by MDB5_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5A9, 0x5E9 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB5_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB5_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB5_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB5_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x729 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'MDB5_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class MDB6_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xB1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'MDB6_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class MDB6_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xB1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB6_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class MDB6_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1, 0x631 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'MDB6_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class MDB6_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5B1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'MDB6_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class MDB6_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB6_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN2_Status {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB6_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB6_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB6_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB6_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB6_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'MDB6_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_Status {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'MDB6_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class MDB6_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB6_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB6_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'MDB6_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_BuildTime {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_BuildDate {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_ChipUID2 {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_ChipUID1 {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_SdcOut {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_SdcIn {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_runtime {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_InputVoltage {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'MDB6_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_BoardTemp {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'MDB6_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_MemFree {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'MDB6_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_CpuUsage {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                MDB6_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'MDB6_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class MDB6_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'MDB6_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class MDB6_OD_DbcVersion {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_StackVersion {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class MDB6_OD_NodeStatus {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'MDB6_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'MDB6_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_OD_NodeID {
            public:
            // This signal is multiplexed by MDB6_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B1, 0x5F1 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                MDB6_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (MDB6_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'MDB6_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class MDB6_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x731 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'MDB6_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
        class Track_W0_OtherWarning {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xB2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue)) & 0x1ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1ull));
                return value;
            }

            // Value table of signal 'Track_W0_OtherWarning'
            constexpr static bool OK = 0;
            constexpr static bool WARN = 1;
        };
        class Track_E0_OtherError {
            public:
            using dataType = bool;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0xB2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, bool value) noexcept {
                bool rawValue = value;
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0x1000ull;
            }
            constexpr static inline bool get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                bool value = static_cast<bool>((intel & 0x1000ull) >> 12);
                return value;
            }

            // Value table of signal 'Track_E0_OtherError'
            constexpr static bool OK = 0;
            constexpr static bool ERR = 1;
        };
        class Track_SDO_ID {
            public:
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 3;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2, 0x632 };
            constexpr static uint16_t min = static_cast<uint16_t>(0);
            constexpr static uint16_t max = static_cast<uint16_t>(4095);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFFull;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFull));
                return value;
            }

            // Value table of signal 'Track_SDO_ID'
            constexpr static uint16_t RESERVED = 0;
            constexpr static uint16_t NODEID = 1;
            constexpr static uint16_t NODESTATUS = 2;
            constexpr static uint16_t PROTOCOLVERSION = 3;
            constexpr static uint16_t STACKVERSION = 4;
            constexpr static uint16_t DBCVERSION = 5;
            constexpr static uint16_t HEARTBEATINTERVAL = 16;
            constexpr static uint16_t SENDODONBOOTUP = 32;
            constexpr static uint16_t ODENTRYSENDINTERVAL = 33;
            constexpr static uint16_t CPUUSAGE = 1040;
            constexpr static uint16_t MEMFREE = 1041;
            constexpr static uint16_t BOARDTEMP = 1042;
            constexpr static uint16_t INPUTVOLTAGE = 1043;
            constexpr static uint16_t RUNTIME = 1044;
            constexpr static uint16_t SDCIN = 1045;
            constexpr static uint16_t SDCOUT = 1046;
            constexpr static uint16_t CHIPUID1 = 1056;
            constexpr static uint16_t CHIPUID2 = 1057;
            constexpr static uint16_t BUILDDATE = 1072;
            constexpr static uint16_t BUILDTIME = 1073;
            constexpr static uint16_t CAN1_TXERRCNT = 1104;
            constexpr static uint16_t CAN1_RXERRCNT = 1105;
            constexpr static uint16_t CAN1_LASTERRORCODE = 1106;
            constexpr static uint16_t CAN1_AUTOERRORRESET = 1107;
            constexpr static uint16_t CAN1_BAUDRATE = 1108;
            constexpr static uint16_t CAN1_STATUS = 1110;
            constexpr static uint16_t CAN1_DISCARDEDTXMESSAGES = 1111;
            constexpr static uint16_t CAN1_ERRORSTATUS = 1112;
            constexpr static uint16_t CAN1_DELAYEDTXMESSAGES = 1113;
            constexpr static uint16_t CAN2_TXERRCNT = 1120;
            constexpr static uint16_t CAN2_RXERRCNT = 1121;
            constexpr static uint16_t CAN2_LASTERRORCODE = 1122;
            constexpr static uint16_t CAN2_AUTOERRORRESET = 1123;
            constexpr static uint16_t CAN2_BAUDRATE = 1124;
            constexpr static uint16_t CAN2_STATUS = 1126;
            constexpr static uint16_t CAN2_DISCARDEDTXMESSAGES = 1127;
            constexpr static uint16_t CAN2_ERRORSTATUS = 1128;
            constexpr static uint16_t CAN2_DELAYEDTXMESSAGES = 1129;
        };
        class Track_SDO_RespCode {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x5B2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 12) & 0xF000ull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xF000ull) >> 12);
                return value;
            }

            // Value table of signal 'Track_SDO_RespCode'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t ERR_NON_EXISTING_OBJECT = 1;
            constexpr static uint8_t ERR_WRITE_ONLY_OBJECT = 2;
            constexpr static uint8_t ERR_READ_ONLY_OBJECT = 3;
            constexpr static uint8_t ERR_NO_ACCESS_IN_THIS_STATE = 4;
            constexpr static uint8_t ERR_OUT_OF_RANGE = 5;
        };
        class Track_OD_CAN2_DelayedTxMessages {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1129            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1129);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1129) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN2_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN2_ErrorStatus {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1128            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1128);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1128) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN2_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'Track_OD_CAN2_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN2_DiscardedTxMessages {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1127            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1127);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1127) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN2_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "Track_OD_CAN2_DiscardedTxMessages";
        };
        class Track_OD_CAN2_Status {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1126            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1126);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1126) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN2_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'Track_OD_CAN2_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN2_Baudrate {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1124            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1124);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1124) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN2_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class Track_OD_CAN2_autoErrorReset {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1123            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1123);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1123) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN2_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'Track_OD_CAN2_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class Track_OD_CAN2_lastErrorCode {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1122            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1122);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1122) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN2_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'Track_OD_CAN2_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN2_RxErrCnt {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1121            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1121);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1121) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN2_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN2_TxErrCnt {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1120            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1120);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1120) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN2_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN1_DelayedTxMessages {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1113            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1113);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1113) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN1_DelayedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN1_ErrorStatus {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1112            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1112);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1112) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN1_ErrorStatus'
            constexpr static uint8_t OK = 0;
            constexpr static uint8_t WARN = 1;
            constexpr static uint8_t ERROR_PASSIVE = 2;
            constexpr static uint8_t BUS_OFF = 3;

            // Attributes of signal 'Track_OD_CAN1_ErrorStatus'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN1_DiscardedTxMessages {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1111            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1111);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1111) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN1_DiscardedTxMessages'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
            constexpr static char SystemSignalLongSymbol[] = "Track_OD_CAN1_DiscardedTxMessages";
        };
        class Track_OD_CAN1_Status {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1110            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1110);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1110) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN1_Status'
            constexpr static uint8_t RESET = 0;
            constexpr static uint8_t READY = 1;
            constexpr static uint8_t LISTENING = 2;
            constexpr static uint8_t SLEEP_PENDING = 3;
            constexpr static uint8_t SLEEP_ACTIVE = 4;
            constexpr static uint8_t ERROR = 5;

            // Attributes of signal 'Track_OD_CAN1_Status'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN1_Baudrate {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1108            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint16_t min = static_cast<uint16_t>(125);
            constexpr static uint16_t max = static_cast<uint16_t>(1000);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1108);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1108) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN1_Baudrate'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1000.0f;
            constexpr static float CANzero_SDO_Default = 1000.0f;
        };
        class Track_OD_CAN1_autoErrorReset {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1107            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1107);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1107) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN1_autoErrorReset'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'Track_OD_CAN1_autoErrorReset'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class Track_OD_CAN1_lastErrorCode {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1106            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1106);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1106) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_CAN1_lastErrorCode'
            constexpr static uint32_t NO_ERROR = 0;
            constexpr static uint32_t STUFF_ERROR = 1;
            constexpr static uint32_t FORM_ERROR = 2;
            constexpr static uint32_t ACK_ERROR = 3;
            constexpr static uint32_t BIT_RECESSIVE_ERROR = 4;
            constexpr static uint32_t BIT_DOMINANT_ERROR = 5;
            constexpr static uint32_t CRC_ERROR = 6;

            // Attributes of signal 'Track_OD_CAN1_lastErrorCode'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN1_RxErrCnt {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1105            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1105);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1105) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN1_RxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CAN1_TxErrCnt {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1104            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1104);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1104) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_CAN1_TxErrCnt'
            constexpr static char CANzero_SDO_Group[] = "CAN";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_BuildTime {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1073            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1073);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1073) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_BuildTime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_BuildDate {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1072            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1072);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFF0000ull;
                dlc = 6;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1072) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_BuildDate'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_ChipUID2 {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1057            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1057);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1057) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_ChipUID2'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_ChipUID1 {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1056            
            using dataType = uint64_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint64_t min = static_cast<uint64_t>(0);
            constexpr static uint64_t max = static_cast<uint64_t>(281474976710655);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint64_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1056);
                uint64_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFFFFFFFF0000ull;
                dlc = 8;
            }
            constexpr static inline uint64_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1056) {
                    while(1);
                }
                uint64_t value = static_cast<uint64_t>((intel & 0xFFFFFFFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_ChipUID1'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_SdcOut {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1046            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1046);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1046) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_SdcOut'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_SdcIn {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1045            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1045);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1045) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_SdcIn'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_runtime {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1044            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(16777215);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1044);
                uint32_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFFFF0000ull;
                dlc = 5;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1044) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_runtime'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_InputVoltage {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1043            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(65.535);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1043);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value) / (0.001f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1043) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.001f);
            }

            // Attributes of signal 'Track_OD_InputVoltage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_BoardTemp {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1042            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static float min = static_cast<float>(-30);
            constexpr static float max = static_cast<float>(625.35);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1042);
                uint16_t rawValue = static_cast<uint16_t>(STD_ROUND((value - (-30.0f)) / (0.01f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1042) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (0.01f) + (-30.0f);
            }

            // Attributes of signal 'Track_OD_BoardTemp'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 3000.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_MemFree {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1041            
            using dataType = uint32_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static uint32_t min = static_cast<uint32_t>(0);
            constexpr static uint32_t max = static_cast<uint32_t>(262140);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint32_t value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1041);
                uint32_t rawValue = static_cast<uint32_t>((value) / (4));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint32_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1041) {
                    while(1);
                }
                uint32_t value = static_cast<uint32_t>((intel & 0xFFFF0000ull) >> 16);
                return value * (4);
            }

            // Attributes of signal 'Track_OD_MemFree'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_CpuUsage {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1040            
            using dataType = float;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static float min = static_cast<float>(0);
            constexpr static float max = static_cast<float>(100);
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, float value) noexcept {
                if (value > max) {
                    value = max;
                }
                if (value < min) {
                    value = min;
                }
                Track_SDO_ID::set(intel, motorola, dlc, 1040);
                uint8_t rawValue = static_cast<uint8_t>(STD_ROUND((value) / (0.5f)));
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline float get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1040) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value * (0.5f);
            }

            // Attributes of signal 'Track_OD_CpuUsage'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_OdEntrySendInterval {
            public:
            // This signal is multiplexed by Track_SDO_ID == 33            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 33);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 33) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_OdEntrySendInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 50.0f;
            constexpr static float CANzero_SDO_Default = 50.0f;
        };
        class Track_OD_SendOdOnBootup {
            public:
            // This signal is multiplexed by Track_SDO_ID == 32            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 32);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 32) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_SendOdOnBootup'
            constexpr static uint8_t DISABLED = 0;
            constexpr static uint8_t ENABLED = 1;

            // Attributes of signal 'Track_OD_SendOdOnBootup'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_HeartbeatInterval {
            public:
            // This signal is multiplexed by Track_SDO_ID == 16            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 16);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 16) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_HeartbeatInterval'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_WRITE;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 250.0f;
            constexpr static float CANzero_SDO_Default = 250.0f;
        };
        class Track_OD_DbcVersion {
            public:
            // This signal is multiplexed by Track_SDO_ID == 5            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 5);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 5) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_DbcVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_StackVersion {
            public:
            // This signal is multiplexed by Track_SDO_ID == 4            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 4);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 4) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_StackVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_ProtocolVersion {
            public:
            // This signal is multiplexed by Track_SDO_ID == 3            
            using dataType = uint16_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint16_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 3);
                uint16_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFFFF0000ull;
                dlc = 4;
            }
            constexpr static inline uint16_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 3) {
                    while(1);
                }
                uint16_t value = static_cast<uint16_t>((intel & 0xFFFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_ProtocolVersion'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 1.0f;
            constexpr static float CANzero_SDO_Default = 1.0f;
        };
        class Track_OD_NodeStatus {
            public:
            // This signal is multiplexed by Track_SDO_ID == 2            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 2);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 2) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Value table of signal 'Track_OD_NodeStatus'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
            constexpr static uint8_t RESET = 128;

            // Attributes of signal 'Track_OD_NodeStatus'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_OD_NodeID {
            public:
            // This signal is multiplexed by Track_SDO_ID == 1            
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 2;
            constexpr static uint32_t ids[] = { 0x5B2, 0x5F2 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                Track_SDO_ID::set(intel, motorola, dlc, 1);
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue) << 16) & 0xFF0000ull;
                dlc = 3;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                if (Track_SDO_ID::get(intel, motorola) != 1) {
                    while(1);
                }
                uint8_t value = static_cast<uint8_t>((intel & 0xFF0000ull) >> 16);
                return value;
            }

            // Attributes of signal 'Track_OD_NodeID'
            constexpr static char CANzero_SDO_Group[] = "";
            constexpr static CANzero_SDO_AccessType_t CANzero_SDO_AccessType = CANzero_SDO_AccessType_t::READ_ONLY;
            constexpr static CANzero_SDO_AccessIfOperational_t CANzero_SDO_AccessIfOperational = CANzero_SDO_AccessIfOperational_t::YES;
            constexpr static float GenSigStartValue = 0.0f;
            constexpr static float CANzero_SDO_Default = 0.0f;
        };
        class Track_NodeState {
            public:
            using dataType = uint8_t;
            constexpr static uint8_t numIds = 1;
            constexpr static uint32_t ids[] = { 0x732 };
            constexpr static inline void set(uint64_t& intel, uint64_t& motorola, uint8_t& dlc, uint8_t value) noexcept {
                uint8_t rawValue = (value);
                intel |= (static_cast<uint64_t>(rawValue)) & 0xFFull;
            }
            constexpr static inline uint8_t get(const uint64_t& intel, const uint64_t& motorola) noexcept {
                uint8_t value = static_cast<uint8_t>((intel & 0xFFull));
                return value;
            }

            // Value table of signal 'Track_NodeState'
            constexpr static uint8_t BOOTUP = 0;
            constexpr static uint8_t STOPPED = 4;
            constexpr static uint8_t OPERATIONAL = 5;
            constexpr static uint8_t PREOPERATIONAL = 127;
        };
    }

    /**********************************************************************************************
    * Namespace containing all messages                                                           *
    ***********************************************************************************************/
    namespace messages {
        class BrakeF_TX_PressureCooling {
            public:
            constexpr static uint32_t id = 0x110;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PressureCooling'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BMS_Frame {
            public:
            constexpr static uint32_t id = 0x10ECE0;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'BMS_Frame'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_Respond {
            public:
            constexpr static uint32_t id = 0x1;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_TX_Response = signals::Track_TX_Response;

            // Attributes of message 'Track_TX_Respond'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_RX_Controll {
            public:
            constexpr static uint32_t id = 0x0;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_RX_Command = signals::Track_RX_Command;

            // Attributes of message 'Track_RX_Controll'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TEST_GROUND_STATION_CONTROLL {
            public:
            constexpr static uint32_t id = 0x200;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using TEST_GROUND_STATION_COMMAND = signals::TEST_GROUND_STATION_COMMAND;

            // Attributes of message 'TEST_GROUND_STATION_CONTROLL'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB_TX_State {
            public:
            constexpr static uint32_t id = 0x100;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB_Id = signals::MDB_Id;
            using MDB_State = signals::MDB_State;

            // Attributes of message 'MDB_TX_State'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_RX_POD1 {
            public:
            constexpr static uint32_t id = 0x1C2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_RX_POD1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class OpticalSensor_TX_DetailData {
            public:
            constexpr static uint32_t id = 0x1FFFFFFB;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = true;

            // Signals
            using OpticalSensor_TX_VelLong = signals::OpticalSensor_TX_VelLong;
            using OpticalSensor_TX_VelTrans = signals::OpticalSensor_TX_VelTrans;
            using OpticalSensor_TX_Angle = signals::OpticalSensor_TX_Angle;

            // Attributes of message 'OpticalSensor_TX_DetailData'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class OpticalSensor_TX_MainData {
            public:
            constexpr static uint32_t id = 0x1FFFFFFA;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using OpticalSensor_TX_Timestamp = signals::OpticalSensor_TX_Timestamp;
            using OpticalSensor_TX_Vel = signals::OpticalSensor_TX_Vel;
            using OpticalSensor_TX_Distance = signals::OpticalSensor_TX_Distance;

            // Attributes of message 'OpticalSensor_TX_MainData'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class OpticalSensor_TX_Status {
            public:
            constexpr static uint32_t id = 0x1FFFFFFC;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using OpticalSensor_TX_SerialNo = signals::OpticalSensor_TX_SerialNo;
            using OpticalSensor_TX_SensorNo = signals::OpticalSensor_TX_SensorNo;
            using OpticalSensor_TX_Temp = signals::OpticalSensor_TX_Temp;
            using OpticalSensor_TX_LEDCurrent = signals::OpticalSensor_TX_LEDCurrent;
            using OpticalSensor_TX_STST = signals::OpticalSensor_TX_STST;
            using OpticalSensor_TX_SelfTest = signals::OpticalSensor_TX_SelfTest;
            using OpticalSensor_TX_SensorOK = signals::OpticalSensor_TX_SensorOK;
            using OpticalSensor_TX_TempOK = signals::OpticalSensor_TX_TempOK;
            using OpticalSensor_TX_OpticOK = signals::OpticalSensor_TX_OpticOK;
            using OpticalSensor_TX_CurrentLowHigh = signals::OpticalSensor_TX_CurrentLowHigh;
            using OpticalSensor_TX_CurrentOK = signals::OpticalSensor_TX_CurrentOK;
            using OpticalSensor_TX_PowerOK = signals::OpticalSensor_TX_PowerOK;
            using OpticalSensor_TX_LED_Cal = signals::OpticalSensor_TX_LED_Cal;
            using OpticalSensor_TX_LEDStatus = signals::OpticalSensor_TX_LEDStatus;
            using OpticalSensor_TX_V25OK = signals::OpticalSensor_TX_V25OK;
            using OpticalSensor_TX_V33OK = signals::OpticalSensor_TX_V33OK;
            using OpticalSensor_TX_VeeOK = signals::OpticalSensor_TX_VeeOK;
            using OpticalSensor_TX_VddOK = signals::OpticalSensor_TX_VddOK;

            // Attributes of message 'OpticalSensor_TX_Status'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class CANzero_NMT {
            public:
            constexpr static uint32_t id = 0x2;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using CANzero_NMT_State = signals::CANzero_NMT_State;
            using CANzero_NMT_Node = signals::CANzero_NMT_Node;

            // Attributes of message 'CANzero_NMT'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class CANzero_Sync {
            public:
            constexpr static uint32_t id = 0x7A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'CANzero_Sync'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class CANzero_Timestamp {
            public:
            constexpr static uint32_t id = 0x7B;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'CANzero_Timestamp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_EMCY {
            public:
            constexpr static uint32_t id = 0x81;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_W0_OtherWarning = signals::SensorF_W0_OtherWarning;
            using SensorF_W1_StateMTransitionW = signals::SensorF_W1_StateMTransitionW;
            using SensorF_W2_encoderOORWarning = signals::SensorF_W2_encoderOORWarning;
            using SensorF_E0_OtherError = signals::SensorF_E0_OtherError;
            using SensorF_E1_StateMTransitionE = signals::SensorF_E1_StateMTransitionE;
            using SensorF_E2_BrakeFTimeout = signals::SensorF_E2_BrakeFTimeout;
            using SensorF_E3_BrakeRTimeout = signals::SensorF_E3_BrakeRTimeout;
            using SensorF_E4_PDUTimeout = signals::SensorF_E4_PDUTimeout;
            using SensorF_E5_HVCUTimeout = signals::SensorF_E5_HVCUTimeout;
            using SensorF_E6_SensorRTimeout = signals::SensorF_E6_SensorRTimeout;
            using SensorF_E7_TelemetryTimeout = signals::SensorF_E7_TelemetryTimeout;
            using SensorF_E8_NodeErrorFlag = signals::SensorF_E8_NodeErrorFlag;
            using SensorF_E9_SWError = signals::SensorF_E9_SWError;
            using SensorF_E10_TelemEmergency = signals::SensorF_E10_TelemEmergency;
            using SensorF_E12_encoderError = signals::SensorF_E12_encoderError;
            using SensorF_E13_encoderSpeedError = signals::SensorF_E13_encoderSpeedError;
            using SensorF_E14_fiducialHighOffset = signals::SensorF_E14_fiducialHighOffset;

            // Attributes of message 'SensorF_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_StatePod {
            public:
            constexpr static uint32_t id = 0x181;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_TX_PodState = signals::SensorF_TX_PodState;
            using SensorF_TX_PodState_Last = signals::SensorF_TX_PodState_Last;
            using SensorF_TX_PodState_Target = signals::SensorF_TX_PodState_Target;

            // Attributes of message 'SensorF_TX_StatePod'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1C1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_FSMTransitions {
            public:
            constexpr static uint32_t id = 0x201;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_TX_BrakesTransition = signals::SensorF_TX_BrakesTransition;
            using SensorF_TX_EnableTransition = signals::SensorF_TX_EnableTransition;
            using SensorF_TX_ErrorResetTransition = signals::SensorF_TX_ErrorResetTransition;
            using SensorF_TX_HWEnableTransition = signals::SensorF_TX_HWEnableTransition;
            using SensorF_TX_LaunchSetupTransition = signals::SensorF_TX_LaunchSetupTransition;
            using SensorF_TX_LaunchStartTransition = signals::SensorF_TX_LaunchStartTransition;
            using SensorF_TX_PreopTransition = signals::SensorF_TX_PreopTransition;
            using SensorF_TX_SetHVTransition = signals::SensorF_TX_SetHVTransition;
            using SensorF_TX_EnableBrakeFT = signals::SensorF_TX_EnableBrakeFT;
            using SensorF_TX_EnableBrakeRT = signals::SensorF_TX_EnableBrakeRT;
            using SensorF_TX_EnableHVCUT = signals::SensorF_TX_EnableHVCUT;
            using SensorF_TX_EnablePDUT = signals::SensorF_TX_EnablePDUT;
            using SensorF_TX_EnableSensorRT = signals::SensorF_TX_EnableSensorRT;
            using SensorF_TX_PreopSensorRT = signals::SensorF_TX_PreopSensorRT;
            using SensorF_TX_PreopBrakeFT = signals::SensorF_TX_PreopBrakeFT;
            using SensorF_TX_PreopBrakeRT = signals::SensorF_TX_PreopBrakeRT;
            using SensorF_TX_PreopPDUT = signals::SensorF_TX_PreopPDUT;
            using SensorF_TX_PreopHVCUT = signals::SensorF_TX_PreopHVCUT;

            // Attributes of message 'SensorF_TX_FSMTransitions'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x241;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x281;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2C1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x301;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x341;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x381;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3C1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_EncoderFront {
            public:
            constexpr static uint32_t id = 0x401;
            constexpr static uint8_t dlc = 7;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_Pos_EncoderFront = signals::SensorF_Pos_EncoderFront;
            using SensorF_Vel_EncoderFront = signals::SensorF_Vel_EncoderFront;
            using SensorF_GyroFront_X = signals::SensorF_GyroFront_X;

            // Attributes of message 'SensorF_TX_EncoderFront'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_BMS {
            public:
            constexpr static uint32_t id = 0x441;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_TX_BatteryTemp = signals::SensorF_TX_BatteryTemp;

            // Attributes of message 'SensorF_TX_BMS'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_Temperature {
            public:
            constexpr static uint32_t id = 0x481;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_LIMT_Stator_1 = signals::SensorF_LIMT_Stator_1;
            using SensorF_LIMT_Stator_2 = signals::SensorF_LIMT_Stator_2;
            using SensorF_LIMT_Stator_3 = signals::SensorF_LIMT_Stator_3;
            using SensorF_LIMT_Stator_4 = signals::SensorF_LIMT_Stator_4;
            using SensorF_Cooling_Temp = signals::SensorF_Cooling_Temp;

            // Attributes of message 'SensorF_TX_Temperature'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_AccFront {
            public:
            constexpr static uint32_t id = 0x4C1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_AccFront_X = signals::SensorF_AccFront_X;
            using SensorF_AccFront_Y = signals::SensorF_AccFront_Y;
            using SensorF_AccFront_Z = signals::SensorF_AccFront_Z;
            using SensorF_GyroFront_Z = signals::SensorF_GyroFront_Z;

            // Attributes of message 'SensorF_TX_AccFront'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x501;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x541;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x581;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_SDO_ID = signals::SensorF_SDO_ID;
            using SensorF_SDO_RespCode = signals::SensorF_SDO_RespCode;
            using SensorF_OD_SetReset = signals::SensorF_OD_SetReset;
            using SensorF_OD_Velocity = signals::SensorF_OD_Velocity;
            using SensorF_OD_Position = signals::SensorF_OD_Position;
            using SensorF_OD_FiducialLeftCounter = signals::SensorF_OD_FiducialLeftCounter;
            using SensorF_OD_FiducialRightCounter = signals::SensorF_OD_FiducialRightCounter;
            using SensorF_OD_CoolingPressure = signals::SensorF_OD_CoolingPressure;
            using SensorF_OD_IMU_GyroZ = signals::SensorF_OD_IMU_GyroZ;
            using SensorF_OD_IMU_GyroY = signals::SensorF_OD_IMU_GyroY;
            using SensorF_OD_IMU_GyroX = signals::SensorF_OD_IMU_GyroX;
            using SensorF_OD_IMU_AccelZ = signals::SensorF_OD_IMU_AccelZ;
            using SensorF_OD_IMU_AccelY = signals::SensorF_OD_IMU_AccelY;
            using SensorF_OD_IMU_AccelX = signals::SensorF_OD_IMU_AccelX;
            using SensorF_OD_IMU3_Temperature = signals::SensorF_OD_IMU3_Temperature;
            using SensorF_OD_IMU2_Temperature = signals::SensorF_OD_IMU2_Temperature;
            using SensorF_OD_IMU1_Temperature = signals::SensorF_OD_IMU1_Temperature;
            using SensorF_OD_IMU_number = signals::SensorF_OD_IMU_number;
            using SensorF_OD_EncoderResetPosition = signals::SensorF_OD_EncoderResetPosition;
            using SensorF_OD_EncoderWheelDiameter = signals::SensorF_OD_EncoderWheelDiameter;
            using SensorF_OD_HVBatteryMode = signals::SensorF_OD_HVBatteryMode;
            using SensorF_OD_StateMachineActivate = signals::SensorF_OD_StateMachineActivate;
            using SensorF_OD_StateMachineInterval = signals::SensorF_OD_StateMachineInterval;
            using SensorF_OD_TelemetryCommands = signals::SensorF_OD_TelemetryCommands;
            using SensorF_OD_samplingInterval = signals::SensorF_OD_samplingInterval;
            using SensorF_OD_CAN2_DelayedTxMessages = signals::SensorF_OD_CAN2_DelayedTxMessages;
            using SensorF_OD_CAN2_ErrorStatus = signals::SensorF_OD_CAN2_ErrorStatus;
            using SensorF_OD_CAN2_DiscardedTxMessages = signals::SensorF_OD_CAN2_DiscardedTxMessages;
            using SensorF_OD_CAN2_Status = signals::SensorF_OD_CAN2_Status;
            using SensorF_OD_CAN2_Baudrate = signals::SensorF_OD_CAN2_Baudrate;
            using SensorF_OD_CAN2_autoErrorReset = signals::SensorF_OD_CAN2_autoErrorReset;
            using SensorF_OD_CAN2_lastErrorCode = signals::SensorF_OD_CAN2_lastErrorCode;
            using SensorF_OD_CAN2_RxErrCnt = signals::SensorF_OD_CAN2_RxErrCnt;
            using SensorF_OD_CAN2_TxErrCnt = signals::SensorF_OD_CAN2_TxErrCnt;
            using SensorF_OD_CAN1_DelayedTxMessages = signals::SensorF_OD_CAN1_DelayedTxMessages;
            using SensorF_OD_CAN1_ErrorStatus = signals::SensorF_OD_CAN1_ErrorStatus;
            using SensorF_OD_CAN1_DiscardedTxMessages = signals::SensorF_OD_CAN1_DiscardedTxMessages;
            using SensorF_OD_CAN1_Status = signals::SensorF_OD_CAN1_Status;
            using SensorF_OD_CAN1_Baudrate = signals::SensorF_OD_CAN1_Baudrate;
            using SensorF_OD_CAN1_autoErrorReset = signals::SensorF_OD_CAN1_autoErrorReset;
            using SensorF_OD_CAN1_lastErrorCode = signals::SensorF_OD_CAN1_lastErrorCode;
            using SensorF_OD_CAN1_RxErrCnt = signals::SensorF_OD_CAN1_RxErrCnt;
            using SensorF_OD_CAN1_TxErrCnt = signals::SensorF_OD_CAN1_TxErrCnt;
            using SensorF_OD_BuildTime = signals::SensorF_OD_BuildTime;
            using SensorF_OD_BuildDate = signals::SensorF_OD_BuildDate;
            using SensorF_OD_ChipUID2 = signals::SensorF_OD_ChipUID2;
            using SensorF_OD_ChipUID1 = signals::SensorF_OD_ChipUID1;
            using SensorF_OD_SdcOut = signals::SensorF_OD_SdcOut;
            using SensorF_OD_SdcIn = signals::SensorF_OD_SdcIn;
            using SensorF_OD_runtime = signals::SensorF_OD_runtime;
            using SensorF_OD_InputVoltage = signals::SensorF_OD_InputVoltage;
            using SensorF_OD_BoardTemp = signals::SensorF_OD_BoardTemp;
            using SensorF_OD_MemFree = signals::SensorF_OD_MemFree;
            using SensorF_OD_CpuUsage = signals::SensorF_OD_CpuUsage;
            using SensorF_OD_OdEntrySendInterval = signals::SensorF_OD_OdEntrySendInterval;
            using SensorF_OD_SendOdOnBootup = signals::SensorF_OD_SendOdOnBootup;
            using SensorF_OD_HeartbeatInterval = signals::SensorF_OD_HeartbeatInterval;
            using SensorF_OD_DbcVersion = signals::SensorF_OD_DbcVersion;
            using SensorF_OD_StackVersion = signals::SensorF_OD_StackVersion;
            using SensorF_OD_ProtocolVersion = signals::SensorF_OD_ProtocolVersion;
            using SensorF_OD_NodeStatus = signals::SensorF_OD_NodeStatus;
            using SensorF_OD_NodeID = signals::SensorF_OD_NodeID;

            // Attributes of message 'SensorF_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5C1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_SDO_ID = signals::SensorF_SDO_ID;
            using SensorF_OD_SetReset = signals::SensorF_OD_SetReset;
            using SensorF_OD_Velocity = signals::SensorF_OD_Velocity;
            using SensorF_OD_Position = signals::SensorF_OD_Position;
            using SensorF_OD_FiducialLeftCounter = signals::SensorF_OD_FiducialLeftCounter;
            using SensorF_OD_FiducialRightCounter = signals::SensorF_OD_FiducialRightCounter;
            using SensorF_OD_CoolingPressure = signals::SensorF_OD_CoolingPressure;
            using SensorF_OD_IMU_GyroZ = signals::SensorF_OD_IMU_GyroZ;
            using SensorF_OD_IMU_GyroY = signals::SensorF_OD_IMU_GyroY;
            using SensorF_OD_IMU_GyroX = signals::SensorF_OD_IMU_GyroX;
            using SensorF_OD_IMU_AccelZ = signals::SensorF_OD_IMU_AccelZ;
            using SensorF_OD_IMU_AccelY = signals::SensorF_OD_IMU_AccelY;
            using SensorF_OD_IMU_AccelX = signals::SensorF_OD_IMU_AccelX;
            using SensorF_OD_IMU3_Temperature = signals::SensorF_OD_IMU3_Temperature;
            using SensorF_OD_IMU2_Temperature = signals::SensorF_OD_IMU2_Temperature;
            using SensorF_OD_IMU1_Temperature = signals::SensorF_OD_IMU1_Temperature;
            using SensorF_OD_IMU_number = signals::SensorF_OD_IMU_number;
            using SensorF_OD_EncoderResetPosition = signals::SensorF_OD_EncoderResetPosition;
            using SensorF_OD_EncoderWheelDiameter = signals::SensorF_OD_EncoderWheelDiameter;
            using SensorF_OD_HVBatteryMode = signals::SensorF_OD_HVBatteryMode;
            using SensorF_OD_StateMachineActivate = signals::SensorF_OD_StateMachineActivate;
            using SensorF_OD_StateMachineInterval = signals::SensorF_OD_StateMachineInterval;
            using SensorF_OD_TelemetryCommands = signals::SensorF_OD_TelemetryCommands;
            using SensorF_OD_samplingInterval = signals::SensorF_OD_samplingInterval;
            using SensorF_OD_CAN2_DelayedTxMessages = signals::SensorF_OD_CAN2_DelayedTxMessages;
            using SensorF_OD_CAN2_ErrorStatus = signals::SensorF_OD_CAN2_ErrorStatus;
            using SensorF_OD_CAN2_DiscardedTxMessages = signals::SensorF_OD_CAN2_DiscardedTxMessages;
            using SensorF_OD_CAN2_Status = signals::SensorF_OD_CAN2_Status;
            using SensorF_OD_CAN2_Baudrate = signals::SensorF_OD_CAN2_Baudrate;
            using SensorF_OD_CAN2_autoErrorReset = signals::SensorF_OD_CAN2_autoErrorReset;
            using SensorF_OD_CAN2_lastErrorCode = signals::SensorF_OD_CAN2_lastErrorCode;
            using SensorF_OD_CAN2_RxErrCnt = signals::SensorF_OD_CAN2_RxErrCnt;
            using SensorF_OD_CAN2_TxErrCnt = signals::SensorF_OD_CAN2_TxErrCnt;
            using SensorF_OD_CAN1_DelayedTxMessages = signals::SensorF_OD_CAN1_DelayedTxMessages;
            using SensorF_OD_CAN1_ErrorStatus = signals::SensorF_OD_CAN1_ErrorStatus;
            using SensorF_OD_CAN1_DiscardedTxMessages = signals::SensorF_OD_CAN1_DiscardedTxMessages;
            using SensorF_OD_CAN1_Status = signals::SensorF_OD_CAN1_Status;
            using SensorF_OD_CAN1_Baudrate = signals::SensorF_OD_CAN1_Baudrate;
            using SensorF_OD_CAN1_autoErrorReset = signals::SensorF_OD_CAN1_autoErrorReset;
            using SensorF_OD_CAN1_lastErrorCode = signals::SensorF_OD_CAN1_lastErrorCode;
            using SensorF_OD_CAN1_RxErrCnt = signals::SensorF_OD_CAN1_RxErrCnt;
            using SensorF_OD_CAN1_TxErrCnt = signals::SensorF_OD_CAN1_TxErrCnt;
            using SensorF_OD_BuildTime = signals::SensorF_OD_BuildTime;
            using SensorF_OD_BuildDate = signals::SensorF_OD_BuildDate;
            using SensorF_OD_ChipUID2 = signals::SensorF_OD_ChipUID2;
            using SensorF_OD_ChipUID1 = signals::SensorF_OD_ChipUID1;
            using SensorF_OD_SdcOut = signals::SensorF_OD_SdcOut;
            using SensorF_OD_SdcIn = signals::SensorF_OD_SdcIn;
            using SensorF_OD_runtime = signals::SensorF_OD_runtime;
            using SensorF_OD_InputVoltage = signals::SensorF_OD_InputVoltage;
            using SensorF_OD_BoardTemp = signals::SensorF_OD_BoardTemp;
            using SensorF_OD_MemFree = signals::SensorF_OD_MemFree;
            using SensorF_OD_CpuUsage = signals::SensorF_OD_CpuUsage;
            using SensorF_OD_OdEntrySendInterval = signals::SensorF_OD_OdEntrySendInterval;
            using SensorF_OD_SendOdOnBootup = signals::SensorF_OD_SendOdOnBootup;
            using SensorF_OD_HeartbeatInterval = signals::SensorF_OD_HeartbeatInterval;
            using SensorF_OD_DbcVersion = signals::SensorF_OD_DbcVersion;
            using SensorF_OD_StackVersion = signals::SensorF_OD_StackVersion;
            using SensorF_OD_ProtocolVersion = signals::SensorF_OD_ProtocolVersion;
            using SensorF_OD_NodeStatus = signals::SensorF_OD_NodeStatus;
            using SensorF_OD_NodeID = signals::SensorF_OD_NodeID;

            // Attributes of message 'SensorF_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x601;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_SDO_ID = signals::SensorF_SDO_ID;

            // Attributes of message 'SensorF_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_Heartbeat {
            public:
            constexpr static uint32_t id = 0x701;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorF_NodeState = signals::SensorF_NodeState;

            // Attributes of message 'SensorF_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_BTL_TX {
            public:
            constexpr static uint32_t id = 0x741;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorF_BTL_RX {
            public:
            constexpr static uint32_t id = 0x781;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorF_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_EMCY {
            public:
            constexpr static uint32_t id = 0x82;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_W0_OtherWarning = signals::SensorR_W0_OtherWarning;
            using SensorR_W1_stripeWarning = signals::SensorR_W1_stripeWarning;
            using SensorR_W2_stateEstimationVelWarning = signals::SensorR_W2_stateEstimationVelWarning;
            using SensorR_W3_stateEstimationPosWarning = signals::SensorR_W3_stateEstimationPosWarning;
            using SensorR_W4_stateEstimationAccWarning = signals::SensorR_W4_stateEstimationAccWarning;
            using SensorR_W5_sciMoPEwarning069CPUtemp = signals::SensorR_W5_sciMoPEwarning069CPUtemp;
            using SensorR_W6_sciMoPEwarning104FETtemp = signals::SensorR_W6_sciMoPEwarning104FETtemp;
            using SensorR_W7_highOscillations = signals::SensorR_W7_highOscillations;
            using SensorR_W8_outOfLimModelBoundaries = signals::SensorR_W8_outOfLimModelBoundaries;
            using SensorR_W9_restrictingVelocity = signals::SensorR_W9_restrictingVelocity;
            using SensorR_W10_highLIMTemperature = signals::SensorR_W10_highLIMTemperature;
            using SensorR_E0_OtherError = signals::SensorR_E0_OtherError;
            using SensorR_E1_trajectoryError = signals::SensorR_E1_trajectoryError;
            using SensorR_E2_stripeEmergencyStop = signals::SensorR_E2_stripeEmergencyStop;
            using SensorR_E3_posEmergencyStop = signals::SensorR_E3_posEmergencyStop;
            using SensorR_E4_velEmergencyStop = signals::SensorR_E4_velEmergencyStop;
            using SensorR_E5_accEmergencyStop = signals::SensorR_E5_accEmergencyStop;
            using SensorR_E6_scimoPEerror009Pulslock = signals::SensorR_E6_scimoPEerror009Pulslock;
            using SensorR_E7_scimoPEerror020uZKmin = signals::SensorR_E7_scimoPEerror020uZKmin;
            using SensorR_E8_scimoPEerror024motTemp = signals::SensorR_E8_scimoPEerror024motTemp;
            using SensorR_E9_scimoPEerror102overcurrent = signals::SensorR_E9_scimoPEerror102overcurrent;
            using SensorR_E10_scimoPEerror103sumcurrent = signals::SensorR_E10_scimoPEerror103sumcurrent;
            using SensorR_E11_scimoPEerror101overcurrent = signals::SensorR_E11_scimoPEerror101overcurrent;
            using SensorR_E12_highLIMTemperature = signals::SensorR_E12_highLIMTemperature;

            // Attributes of message 'SensorR_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_AccFront {
            public:
            constexpr static uint32_t id = 0x182;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_AccFront_X = signals::SensorR_TX_AccFront_X;
            using SensorR_TX_AccFront_Y = signals::SensorR_TX_AccFront_Y;
            using SensorR_TX_AccFront_Z = signals::SensorR_TX_AccFront_Z;
            using SensorR_TX_GyroFront_Z = signals::SensorR_TX_GyroFront_Z;

            // Attributes of message 'SensorR_TX_AccFront'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_RunStatus {
            public:
            constexpr static uint32_t id = 0x202;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_RunState = signals::SensorR_TX_RunState;
            using SensorR_TX_TrajectorySet = signals::SensorR_TX_TrajectorySet;
            using SensorR_TX_Enabled = signals::SensorR_TX_Enabled;
            using SensorR_TX_ErrorFlag = signals::SensorR_TX_ErrorFlag;

            // Attributes of message 'SensorR_TX_RunStatus'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x242;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_SE {
            public:
            constexpr static uint32_t id = 0x282;
            constexpr static uint8_t dlc = 7;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_Acc = signals::SensorR_TX_Acc;
            using SensorR_TX_Vel = signals::SensorR_TX_Vel;
            using SensorR_TX_Pos = signals::SensorR_TX_Pos;

            // Attributes of message 'SensorR_TX_SE'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_RX_RunControl {
            public:
            constexpr static uint32_t id = 0x2C2;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_RX_LaunchComm = signals::SensorR_RX_LaunchComm;
            using SensorR_RX_Enable = signals::SensorR_RX_Enable;
            using SensorR_RX_ErrorReset = signals::SensorR_RX_ErrorReset;

            // Attributes of message 'SensorR_RX_RunControl'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_Vel {
            public:
            constexpr static uint32_t id = 0x302;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_Vel_EncoderFront = signals::SensorR_TX_Vel_EncoderFront;
            using SensorR_TX_Vel_EncoderRear = signals::SensorR_TX_Vel_EncoderRear;
            using SensorR_TX_Vel_Optical = signals::SensorR_TX_Vel_Optical;

            // Attributes of message 'SensorR_TX_Vel'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x342;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_Gyro_XY {
            public:
            constexpr static uint32_t id = 0x382;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_GyroFront_X = signals::SensorR_TX_GyroFront_X;
            using SensorR_TX_GyroFront_Y = signals::SensorR_TX_GyroFront_Y;
            using SensorR_TX_GyroRear_X = signals::SensorR_TX_GyroRear_X;
            using SensorR_TX_GyroRear_Y = signals::SensorR_TX_GyroRear_Y;

            // Attributes of message 'SensorR_TX_Gyro_XY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_TargetValues {
            public:
            constexpr static uint32_t id = 0x3C2;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_TargetVelocity = signals::SensorR_TX_TargetVelocity;

            // Attributes of message 'SensorR_TX_TargetValues'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_GapHeight {
            public:
            constexpr static uint32_t id = 0x402;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_GapHeight_Left = signals::SensorR_TX_GapHeight_Left;
            using SensorR_TX_GapHeight_Right = signals::SensorR_TX_GapHeight_Right;

            // Attributes of message 'SensorR_TX_GapHeight'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x442;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_Temperature {
            public:
            constexpr static uint32_t id = 0x482;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_LIMT_Coil_1 = signals::SensorR_LIMT_Coil_1;
            using SensorR_LIMT_Coil_2 = signals::SensorR_LIMT_Coil_2;
            using SensorR_LIMT_Coil_3 = signals::SensorR_LIMT_Coil_3;

            // Attributes of message 'SensorR_TX_Temperature'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_AccRear {
            public:
            constexpr static uint32_t id = 0x4C2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_AccRear_X = signals::SensorR_TX_AccRear_X;
            using SensorR_TX_AccRear_Y = signals::SensorR_TX_AccRear_Y;
            using SensorR_TX_AccRear_Z = signals::SensorR_TX_AccRear_Z;
            using SensorR_TX_GyroRear_Z = signals::SensorR_TX_GyroRear_Z;

            // Attributes of message 'SensorR_TX_AccRear'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_Pos {
            public:
            constexpr static uint32_t id = 0x502;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_TX_Pos_EncoderFront = signals::SensorR_TX_Pos_EncoderFront;
            using SensorR_TX_Pos_EncoderRear = signals::SensorR_TX_Pos_EncoderRear;
            using SensorR_TX_Pos_Optical = signals::SensorR_TX_Pos_Optical;
            using SensorR_TX_StripeCounter_Left = signals::SensorR_TX_StripeCounter_Left;
            using SensorR_TX_StripeCounter_Right = signals::SensorR_TX_StripeCounter_Right;

            // Attributes of message 'SensorR_TX_Pos'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x542;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x582;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_SDO_ID = signals::SensorR_SDO_ID;
            using SensorR_SDO_RespCode = signals::SensorR_SDO_RespCode;
            using SensorR_OD_posDeviationOptic = signals::SensorR_OD_posDeviationOptic;
            using SensorR_OD_posDeviationEncoder = signals::SensorR_OD_posDeviationEncoder;
            using SensorR_OD_velDeviationOptic = signals::SensorR_OD_velDeviationOptic;
            using SensorR_OD_velDeviationEncoder = signals::SensorR_OD_velDeviationEncoder;
            using SensorR_OD_accDeviation = signals::SensorR_OD_accDeviation;
            using SensorR_OD_EnableSignalGeneration = signals::SensorR_OD_EnableSignalGeneration;
            using SensorR_OD_PositionGlitch = signals::SensorR_OD_PositionGlitch;
            using SensorR_OD_ReflectorDistance = signals::SensorR_OD_ReflectorDistance;
            using SensorR_OD_StripeMode = signals::SensorR_OD_StripeMode;
            using SensorR_OD_opc_lowpass_TcI = signals::SensorR_OD_opc_lowpass_TcI;
            using SensorR_OD_opc_lowpass_Tcf = signals::SensorR_OD_opc_lowpass_Tcf;
            using SensorR_OD_opc_F_decrease = signals::SensorR_OD_opc_F_decrease;
            using SensorR_OD_opc_v_threshold = signals::SensorR_OD_opc_v_threshold;
            using SensorR_OD_opc_v_max = signals::SensorR_OD_opc_v_max;
            using SensorR_OD_opc_T_acc = signals::SensorR_OD_opc_T_acc;
            using SensorR_OD_opc_F_max = signals::SensorR_OD_opc_F_max;
            using SensorR_OD_opc_t_run_max = signals::SensorR_OD_opc_t_run_max;
            using SensorR_OD_opc_brakeFlag = signals::SensorR_OD_opc_brakeFlag;
            using SensorR_OD_DebugCVOPCfreq = signals::SensorR_OD_DebugCVOPCfreq;
            using SensorR_OD_DebugCascadedIreq = signals::SensorR_OD_DebugCascadedIreq;
            using SensorR_OD_opc_ratelimiter_f = signals::SensorR_OD_opc_ratelimiter_f;
            using SensorR_OD_maxRunDistance = signals::SensorR_OD_maxRunDistance;
            using SensorR_OD_FinishedDelay = signals::SensorR_OD_FinishedDelay;
            using SensorR_OD_Current4Stopping = signals::SensorR_OD_Current4Stopping;
            using SensorR_OD_AdaptModelByCurrent = signals::SensorR_OD_AdaptModelByCurrent;
            using SensorR_OD_CVOPCTcFreq = signals::SensorR_OD_CVOPCTcFreq;
            using SensorR_OD_CVOPCImin = signals::SensorR_OD_CVOPCImin;
            using SensorR_OD_CascadedKpDecreaseCurrent = signals::SensorR_OD_CascadedKpDecreaseCurrent;
            using SensorR_OD_CascadedKpIncreaseCurrent = signals::SensorR_OD_CascadedKpIncreaseCurrent;
            using SensorR_OD_CascadedFreqCurUpdate = signals::SensorR_OD_CascadedFreqCurUpdate;
            using SensorR_OD_CascadedMaxSetForceDelta = signals::SensorR_OD_CascadedMaxSetForceDelta;
            using SensorR_OD_CurrentForConstantVelocity = signals::SensorR_OD_CurrentForConstantVelocity;
            using SensorR_OD_AccAtCurrentMeasured = signals::SensorR_OD_AccAtCurrentMeasured;
            using SensorR_OD_CVOPCHystereseF = signals::SensorR_OD_CVOPCHystereseF;
            using SensorR_OD_CVOPCReduceCurrentWhileCruising = signals::SensorR_OD_CVOPCReduceCurrentWhileCruising;
            using SensorR_OD_CVOPCDeltaVelHigherCurrent = signals::SensorR_OD_CVOPCDeltaVelHigherCurrent;
            using SensorR_OD_CVOPCSmoothingDeltaVelocity = signals::SensorR_OD_CVOPCSmoothingDeltaVelocity;
            using SensorR_OD_CVOPCTcI = signals::SensorR_OD_CVOPCTcI;
            using SensorR_OD_CVOPCTcf = signals::SensorR_OD_CVOPCTcf;
            using SensorR_OD_CVOPCImax = signals::SensorR_OD_CVOPCImax;
            using SensorR_OD_VelocityController = signals::SensorR_OD_VelocityController;
            using SensorR_OD_TC_f = signals::SensorR_OD_TC_f;
            using SensorR_OD_TC_I = signals::SensorR_OD_TC_I;
            using SensorR_OD_EstimatedRunLength = signals::SensorR_OD_EstimatedRunLength;
            using SensorR_OD_RunProfile_V4 = signals::SensorR_OD_RunProfile_V4;
            using SensorR_OD_RunProfile_T4 = signals::SensorR_OD_RunProfile_T4;
            using SensorR_OD_RunProfile_V3 = signals::SensorR_OD_RunProfile_V3;
            using SensorR_OD_RunProfile_T3 = signals::SensorR_OD_RunProfile_T3;
            using SensorR_OD_RunProfile_V2 = signals::SensorR_OD_RunProfile_V2;
            using SensorR_OD_RunProfile_T2 = signals::SensorR_OD_RunProfile_T2;
            using SensorR_OD_RunProfile_V1 = signals::SensorR_OD_RunProfile_V1;
            using SensorR_OD_RunProfile_T1 = signals::SensorR_OD_RunProfile_T1;
            using SensorR_OD_RunProfile_V0 = signals::SensorR_OD_RunProfile_V0;
            using SensorR_OD_RunProfile_T0 = signals::SensorR_OD_RunProfile_T0;
            using SensorR_OD_SetFinish = signals::SensorR_OD_SetFinish;
            using SensorR_OD_RunMode = signals::SensorR_OD_RunMode;
            using SensorR_OD_VdcReduceFactor = signals::SensorR_OD_VdcReduceFactor;
            using SensorR_OD_MaxRequiredVelocity = signals::SensorR_OD_MaxRequiredVelocity;
            using SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries = signals::SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries;
            using SensorR_OD_MaxCtrlErrorDuration = signals::SensorR_OD_MaxCtrlErrorDuration;
            using SensorR_OD_MaxCtrlError = signals::SensorR_OD_MaxCtrlError;
            using SensorR_OD_FminCtrl = signals::SensorR_OD_FminCtrl;
            using SensorR_OD_FmaxCtrl = signals::SensorR_OD_FmaxCtrl;
            using SensorR_OD_PodMass = signals::SensorR_OD_PodMass;
            using SensorR_OD_CurrentReq = signals::SensorR_OD_CurrentReq;
            using SensorR_OD_CtrlMode = signals::SensorR_OD_CtrlMode;
            using SensorR_OD_OpcKi = signals::SensorR_OD_OpcKi;
            using SensorR_OD_OpcKp = signals::SensorR_OD_OpcKp;
            using SensorR_OD_ExecTimeReadSensors = signals::SensorR_OD_ExecTimeReadSensors;
            using SensorR_OD_ExecTimeControl = signals::SensorR_OD_ExecTimeControl;
            using SensorR_OD_ExecTimeStateEst = signals::SensorR_OD_ExecTimeStateEst;
            using SensorR_OD_ExecTimeOverall = signals::SensorR_OD_ExecTimeOverall;
            using SensorR_OD_IMU3_Temperature = signals::SensorR_OD_IMU3_Temperature;
            using SensorR_OD_IMU2_Temperature = signals::SensorR_OD_IMU2_Temperature;
            using SensorR_OD_IMU1_Temperature = signals::SensorR_OD_IMU1_Temperature;
            using SensorR_OD_IMU_number = signals::SensorR_OD_IMU_number;
            using SensorR_OD_EncoderResetPosition = signals::SensorR_OD_EncoderResetPosition;
            using SensorR_OD_EncoderWheelDiameter = signals::SensorR_OD_EncoderWheelDiameter;
            using SensorR_OD_samplingInterval = signals::SensorR_OD_samplingInterval;
            using SensorR_OD_CAN2_DelayedTxMessages = signals::SensorR_OD_CAN2_DelayedTxMessages;
            using SensorR_OD_CAN2_ErrorStatus = signals::SensorR_OD_CAN2_ErrorStatus;
            using SensorR_OD_CAN2_DiscardedTxMessages = signals::SensorR_OD_CAN2_DiscardedTxMessages;
            using SensorR_OD_CAN2_Status = signals::SensorR_OD_CAN2_Status;
            using SensorR_OD_CAN2_Baudrate = signals::SensorR_OD_CAN2_Baudrate;
            using SensorR_OD_CAN2_autoErrorReset = signals::SensorR_OD_CAN2_autoErrorReset;
            using SensorR_OD_CAN2_lastErrorCode = signals::SensorR_OD_CAN2_lastErrorCode;
            using SensorR_OD_CAN2_RxErrCnt = signals::SensorR_OD_CAN2_RxErrCnt;
            using SensorR_OD_CAN2_TxErrCnt = signals::SensorR_OD_CAN2_TxErrCnt;
            using SensorR_OD_CAN1_DelayedTxMessages = signals::SensorR_OD_CAN1_DelayedTxMessages;
            using SensorR_OD_CAN1_ErrorStatus = signals::SensorR_OD_CAN1_ErrorStatus;
            using SensorR_OD_CAN1_DiscardedTxMessages = signals::SensorR_OD_CAN1_DiscardedTxMessages;
            using SensorR_OD_CAN1_Status = signals::SensorR_OD_CAN1_Status;
            using SensorR_OD_CAN1_Baudrate = signals::SensorR_OD_CAN1_Baudrate;
            using SensorR_OD_CAN1_autoErrorReset = signals::SensorR_OD_CAN1_autoErrorReset;
            using SensorR_OD_CAN1_lastErrorCode = signals::SensorR_OD_CAN1_lastErrorCode;
            using SensorR_OD_CAN1_RxErrCnt = signals::SensorR_OD_CAN1_RxErrCnt;
            using SensorR_OD_CAN1_TxErrCnt = signals::SensorR_OD_CAN1_TxErrCnt;
            using SensorR_OD_BuildTime = signals::SensorR_OD_BuildTime;
            using SensorR_OD_BuildDate = signals::SensorR_OD_BuildDate;
            using SensorR_OD_ChipUID2 = signals::SensorR_OD_ChipUID2;
            using SensorR_OD_ChipUID1 = signals::SensorR_OD_ChipUID1;
            using SensorR_OD_SdcOut = signals::SensorR_OD_SdcOut;
            using SensorR_OD_SdcIn = signals::SensorR_OD_SdcIn;
            using SensorR_OD_runtime = signals::SensorR_OD_runtime;
            using SensorR_OD_InputVoltage = signals::SensorR_OD_InputVoltage;
            using SensorR_OD_BoardTemp = signals::SensorR_OD_BoardTemp;
            using SensorR_OD_MemFree = signals::SensorR_OD_MemFree;
            using SensorR_OD_CpuUsage = signals::SensorR_OD_CpuUsage;
            using SensorR_OD_OdEntrySendInterval = signals::SensorR_OD_OdEntrySendInterval;
            using SensorR_OD_SendOdOnBootup = signals::SensorR_OD_SendOdOnBootup;
            using SensorR_OD_HeartbeatInterval = signals::SensorR_OD_HeartbeatInterval;
            using SensorR_OD_DbcVersion = signals::SensorR_OD_DbcVersion;
            using SensorR_OD_StackVersion = signals::SensorR_OD_StackVersion;
            using SensorR_OD_ProtocolVersion = signals::SensorR_OD_ProtocolVersion;
            using SensorR_OD_NodeStatus = signals::SensorR_OD_NodeStatus;
            using SensorR_OD_NodeID = signals::SensorR_OD_NodeID;

            // Attributes of message 'SensorR_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5C2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_SDO_ID = signals::SensorR_SDO_ID;
            using SensorR_OD_posDeviationOptic = signals::SensorR_OD_posDeviationOptic;
            using SensorR_OD_posDeviationEncoder = signals::SensorR_OD_posDeviationEncoder;
            using SensorR_OD_velDeviationOptic = signals::SensorR_OD_velDeviationOptic;
            using SensorR_OD_velDeviationEncoder = signals::SensorR_OD_velDeviationEncoder;
            using SensorR_OD_accDeviation = signals::SensorR_OD_accDeviation;
            using SensorR_OD_EnableSignalGeneration = signals::SensorR_OD_EnableSignalGeneration;
            using SensorR_OD_PositionGlitch = signals::SensorR_OD_PositionGlitch;
            using SensorR_OD_ReflectorDistance = signals::SensorR_OD_ReflectorDistance;
            using SensorR_OD_StripeMode = signals::SensorR_OD_StripeMode;
            using SensorR_OD_opc_lowpass_TcI = signals::SensorR_OD_opc_lowpass_TcI;
            using SensorR_OD_opc_lowpass_Tcf = signals::SensorR_OD_opc_lowpass_Tcf;
            using SensorR_OD_opc_F_decrease = signals::SensorR_OD_opc_F_decrease;
            using SensorR_OD_opc_v_threshold = signals::SensorR_OD_opc_v_threshold;
            using SensorR_OD_opc_v_max = signals::SensorR_OD_opc_v_max;
            using SensorR_OD_opc_T_acc = signals::SensorR_OD_opc_T_acc;
            using SensorR_OD_opc_F_max = signals::SensorR_OD_opc_F_max;
            using SensorR_OD_opc_t_run_max = signals::SensorR_OD_opc_t_run_max;
            using SensorR_OD_opc_brakeFlag = signals::SensorR_OD_opc_brakeFlag;
            using SensorR_OD_DebugCVOPCfreq = signals::SensorR_OD_DebugCVOPCfreq;
            using SensorR_OD_DebugCascadedIreq = signals::SensorR_OD_DebugCascadedIreq;
            using SensorR_OD_opc_ratelimiter_f = signals::SensorR_OD_opc_ratelimiter_f;
            using SensorR_OD_maxRunDistance = signals::SensorR_OD_maxRunDistance;
            using SensorR_OD_FinishedDelay = signals::SensorR_OD_FinishedDelay;
            using SensorR_OD_Current4Stopping = signals::SensorR_OD_Current4Stopping;
            using SensorR_OD_AdaptModelByCurrent = signals::SensorR_OD_AdaptModelByCurrent;
            using SensorR_OD_CVOPCTcFreq = signals::SensorR_OD_CVOPCTcFreq;
            using SensorR_OD_CVOPCImin = signals::SensorR_OD_CVOPCImin;
            using SensorR_OD_CascadedKpDecreaseCurrent = signals::SensorR_OD_CascadedKpDecreaseCurrent;
            using SensorR_OD_CascadedKpIncreaseCurrent = signals::SensorR_OD_CascadedKpIncreaseCurrent;
            using SensorR_OD_CascadedFreqCurUpdate = signals::SensorR_OD_CascadedFreqCurUpdate;
            using SensorR_OD_CascadedMaxSetForceDelta = signals::SensorR_OD_CascadedMaxSetForceDelta;
            using SensorR_OD_CurrentForConstantVelocity = signals::SensorR_OD_CurrentForConstantVelocity;
            using SensorR_OD_AccAtCurrentMeasured = signals::SensorR_OD_AccAtCurrentMeasured;
            using SensorR_OD_CVOPCHystereseF = signals::SensorR_OD_CVOPCHystereseF;
            using SensorR_OD_CVOPCReduceCurrentWhileCruising = signals::SensorR_OD_CVOPCReduceCurrentWhileCruising;
            using SensorR_OD_CVOPCDeltaVelHigherCurrent = signals::SensorR_OD_CVOPCDeltaVelHigherCurrent;
            using SensorR_OD_CVOPCSmoothingDeltaVelocity = signals::SensorR_OD_CVOPCSmoothingDeltaVelocity;
            using SensorR_OD_CVOPCTcI = signals::SensorR_OD_CVOPCTcI;
            using SensorR_OD_CVOPCTcf = signals::SensorR_OD_CVOPCTcf;
            using SensorR_OD_CVOPCImax = signals::SensorR_OD_CVOPCImax;
            using SensorR_OD_VelocityController = signals::SensorR_OD_VelocityController;
            using SensorR_OD_TC_f = signals::SensorR_OD_TC_f;
            using SensorR_OD_TC_I = signals::SensorR_OD_TC_I;
            using SensorR_OD_EstimatedRunLength = signals::SensorR_OD_EstimatedRunLength;
            using SensorR_OD_RunProfile_V4 = signals::SensorR_OD_RunProfile_V4;
            using SensorR_OD_RunProfile_T4 = signals::SensorR_OD_RunProfile_T4;
            using SensorR_OD_RunProfile_V3 = signals::SensorR_OD_RunProfile_V3;
            using SensorR_OD_RunProfile_T3 = signals::SensorR_OD_RunProfile_T3;
            using SensorR_OD_RunProfile_V2 = signals::SensorR_OD_RunProfile_V2;
            using SensorR_OD_RunProfile_T2 = signals::SensorR_OD_RunProfile_T2;
            using SensorR_OD_RunProfile_V1 = signals::SensorR_OD_RunProfile_V1;
            using SensorR_OD_RunProfile_T1 = signals::SensorR_OD_RunProfile_T1;
            using SensorR_OD_RunProfile_V0 = signals::SensorR_OD_RunProfile_V0;
            using SensorR_OD_RunProfile_T0 = signals::SensorR_OD_RunProfile_T0;
            using SensorR_OD_SetFinish = signals::SensorR_OD_SetFinish;
            using SensorR_OD_RunMode = signals::SensorR_OD_RunMode;
            using SensorR_OD_VdcReduceFactor = signals::SensorR_OD_VdcReduceFactor;
            using SensorR_OD_MaxRequiredVelocity = signals::SensorR_OD_MaxRequiredVelocity;
            using SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries = signals::SensorR_OD_WarningThreshholdForLimModelOutOfBoundaries;
            using SensorR_OD_MaxCtrlErrorDuration = signals::SensorR_OD_MaxCtrlErrorDuration;
            using SensorR_OD_MaxCtrlError = signals::SensorR_OD_MaxCtrlError;
            using SensorR_OD_FminCtrl = signals::SensorR_OD_FminCtrl;
            using SensorR_OD_FmaxCtrl = signals::SensorR_OD_FmaxCtrl;
            using SensorR_OD_PodMass = signals::SensorR_OD_PodMass;
            using SensorR_OD_CurrentReq = signals::SensorR_OD_CurrentReq;
            using SensorR_OD_CtrlMode = signals::SensorR_OD_CtrlMode;
            using SensorR_OD_OpcKi = signals::SensorR_OD_OpcKi;
            using SensorR_OD_OpcKp = signals::SensorR_OD_OpcKp;
            using SensorR_OD_ExecTimeReadSensors = signals::SensorR_OD_ExecTimeReadSensors;
            using SensorR_OD_ExecTimeControl = signals::SensorR_OD_ExecTimeControl;
            using SensorR_OD_ExecTimeStateEst = signals::SensorR_OD_ExecTimeStateEst;
            using SensorR_OD_ExecTimeOverall = signals::SensorR_OD_ExecTimeOverall;
            using SensorR_OD_IMU3_Temperature = signals::SensorR_OD_IMU3_Temperature;
            using SensorR_OD_IMU2_Temperature = signals::SensorR_OD_IMU2_Temperature;
            using SensorR_OD_IMU1_Temperature = signals::SensorR_OD_IMU1_Temperature;
            using SensorR_OD_IMU_number = signals::SensorR_OD_IMU_number;
            using SensorR_OD_EncoderResetPosition = signals::SensorR_OD_EncoderResetPosition;
            using SensorR_OD_EncoderWheelDiameter = signals::SensorR_OD_EncoderWheelDiameter;
            using SensorR_OD_samplingInterval = signals::SensorR_OD_samplingInterval;
            using SensorR_OD_CAN2_DelayedTxMessages = signals::SensorR_OD_CAN2_DelayedTxMessages;
            using SensorR_OD_CAN2_ErrorStatus = signals::SensorR_OD_CAN2_ErrorStatus;
            using SensorR_OD_CAN2_DiscardedTxMessages = signals::SensorR_OD_CAN2_DiscardedTxMessages;
            using SensorR_OD_CAN2_Status = signals::SensorR_OD_CAN2_Status;
            using SensorR_OD_CAN2_Baudrate = signals::SensorR_OD_CAN2_Baudrate;
            using SensorR_OD_CAN2_autoErrorReset = signals::SensorR_OD_CAN2_autoErrorReset;
            using SensorR_OD_CAN2_lastErrorCode = signals::SensorR_OD_CAN2_lastErrorCode;
            using SensorR_OD_CAN2_RxErrCnt = signals::SensorR_OD_CAN2_RxErrCnt;
            using SensorR_OD_CAN2_TxErrCnt = signals::SensorR_OD_CAN2_TxErrCnt;
            using SensorR_OD_CAN1_DelayedTxMessages = signals::SensorR_OD_CAN1_DelayedTxMessages;
            using SensorR_OD_CAN1_ErrorStatus = signals::SensorR_OD_CAN1_ErrorStatus;
            using SensorR_OD_CAN1_DiscardedTxMessages = signals::SensorR_OD_CAN1_DiscardedTxMessages;
            using SensorR_OD_CAN1_Status = signals::SensorR_OD_CAN1_Status;
            using SensorR_OD_CAN1_Baudrate = signals::SensorR_OD_CAN1_Baudrate;
            using SensorR_OD_CAN1_autoErrorReset = signals::SensorR_OD_CAN1_autoErrorReset;
            using SensorR_OD_CAN1_lastErrorCode = signals::SensorR_OD_CAN1_lastErrorCode;
            using SensorR_OD_CAN1_RxErrCnt = signals::SensorR_OD_CAN1_RxErrCnt;
            using SensorR_OD_CAN1_TxErrCnt = signals::SensorR_OD_CAN1_TxErrCnt;
            using SensorR_OD_BuildTime = signals::SensorR_OD_BuildTime;
            using SensorR_OD_BuildDate = signals::SensorR_OD_BuildDate;
            using SensorR_OD_ChipUID2 = signals::SensorR_OD_ChipUID2;
            using SensorR_OD_ChipUID1 = signals::SensorR_OD_ChipUID1;
            using SensorR_OD_SdcOut = signals::SensorR_OD_SdcOut;
            using SensorR_OD_SdcIn = signals::SensorR_OD_SdcIn;
            using SensorR_OD_runtime = signals::SensorR_OD_runtime;
            using SensorR_OD_InputVoltage = signals::SensorR_OD_InputVoltage;
            using SensorR_OD_BoardTemp = signals::SensorR_OD_BoardTemp;
            using SensorR_OD_MemFree = signals::SensorR_OD_MemFree;
            using SensorR_OD_CpuUsage = signals::SensorR_OD_CpuUsage;
            using SensorR_OD_OdEntrySendInterval = signals::SensorR_OD_OdEntrySendInterval;
            using SensorR_OD_SendOdOnBootup = signals::SensorR_OD_SendOdOnBootup;
            using SensorR_OD_HeartbeatInterval = signals::SensorR_OD_HeartbeatInterval;
            using SensorR_OD_DbcVersion = signals::SensorR_OD_DbcVersion;
            using SensorR_OD_StackVersion = signals::SensorR_OD_StackVersion;
            using SensorR_OD_ProtocolVersion = signals::SensorR_OD_ProtocolVersion;
            using SensorR_OD_NodeStatus = signals::SensorR_OD_NodeStatus;
            using SensorR_OD_NodeID = signals::SensorR_OD_NodeID;

            // Attributes of message 'SensorR_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x602;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_SDO_ID = signals::SensorR_SDO_ID;

            // Attributes of message 'SensorR_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_Heartbeat {
            public:
            constexpr static uint32_t id = 0x702;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using SensorR_NodeState = signals::SensorR_NodeState;

            // Attributes of message 'SensorR_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_BTL_TX {
            public:
            constexpr static uint32_t id = 0x742;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SensorR_BTL_RX {
            public:
            constexpr static uint32_t id = 0x782;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'SensorR_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_EMCY {
            public:
            constexpr static uint32_t id = 0x91;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_W0_highPressureActingChamber = signals::BrakeF_W0_highPressureActingChamber;
            using BrakeF_W1_highPressureRetractingChamber = signals::BrakeF_W1_highPressureRetractingChamber;
            using BrakeF_W2_enableWithAnError = signals::BrakeF_W2_enableWithAnError;
            using BrakeF_W3_externalError = signals::BrakeF_W3_externalError;
            using BrakeF_E0_pressureTooHigh = signals::BrakeF_E0_pressureTooHigh;
            using BrakeF_E1_pressureTooLow = signals::BrakeF_E1_pressureTooLow;
            using BrakeF_E2_commWatchdogTimeout = signals::BrakeF_E2_commWatchdogTimeout;
            using BrakeF_E3_retractUnsuccesful_errorFlag = signals::BrakeF_E3_retractUnsuccesful_errorFlag;
            using BrakeF_E4_retractUnsuccesful_notEnabled = signals::BrakeF_E4_retractUnsuccesful_notEnabled;
            using BrakeF_E5_retractUnsuccesful_openSDC = signals::BrakeF_E5_retractUnsuccesful_openSDC;

            // Attributes of message 'BrakeF_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_Status {
            public:
            constexpr static uint32_t id = 0x191;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_TX_Status_ = signals::BrakeF_TX_Status;
            using BrakeF_TX_Enabled = signals::BrakeF_TX_Enabled;
            using BrakeF_TX_ErrorFlag = signals::BrakeF_TX_ErrorFlag;
            using BrakeF_TX_SDC_Input = signals::BrakeF_TX_SDC_Input;
            using BrakeF_TX_DeltaTime_Control = signals::BrakeF_TX_DeltaTime_Control;
            using BrakeF_TX_MaxDeltaTime_Control = signals::BrakeF_TX_MaxDeltaTime_Control;

            // Attributes of message 'BrakeF_TX_Status'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_RX_Control {
            public:
            constexpr static uint32_t id = 0x1D1;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_RX_ErrorReset = signals::BrakeF_RX_ErrorReset;
            using BrakeF_RX_Enable = signals::BrakeF_RX_Enable;
            using BrakeF_RX_Engage = signals::BrakeF_RX_Engage;

            // Attributes of message 'BrakeF_RX_Control'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x211;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x251;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x291;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2D1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x311;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x351;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x391;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3D1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_Pressure {
            public:
            constexpr static uint32_t id = 0x411;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_TX_Pressure_Act = signals::BrakeF_TX_Pressure_Act;
            using BrakeF_TX_Pressure_Retract = signals::BrakeF_TX_Pressure_Retract;
            using BrakeF_TX_Pressure_Tank = signals::BrakeF_TX_Pressure_Tank;

            // Attributes of message 'BrakeF_TX_Pressure'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x451;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x491;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4D1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x511;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x551;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x591;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_SDO_ID = signals::BrakeF_SDO_ID;
            using BrakeF_SDO_RespCode = signals::BrakeF_SDO_RespCode;
            using BrakeF_OD_valveUpperTolerance = signals::BrakeF_OD_valveUpperTolerance;
            using BrakeF_OD_commWatchdog = signals::BrakeF_OD_commWatchdog;
            using BrakeF_OD_counterLimit = signals::BrakeF_OD_counterLimit;
            using BrakeF_OD_delay = signals::BrakeF_OD_delay;
            using BrakeF_OD_tankUpperControlLimit = signals::BrakeF_OD_tankUpperControlLimit;
            using BrakeF_OD_tankLowerControlLimit = signals::BrakeF_OD_tankLowerControlLimit;
            using BrakeF_OD_CAN2_DelayedTxMessages = signals::BrakeF_OD_CAN2_DelayedTxMessages;
            using BrakeF_OD_CAN2_ErrorStatus = signals::BrakeF_OD_CAN2_ErrorStatus;
            using BrakeF_OD_CAN2_DiscardedTxMessages = signals::BrakeF_OD_CAN2_DiscardedTxMessages;
            using BrakeF_OD_CAN2_Status = signals::BrakeF_OD_CAN2_Status;
            using BrakeF_OD_CAN2_Baudrate = signals::BrakeF_OD_CAN2_Baudrate;
            using BrakeF_OD_CAN2_autoErrorReset = signals::BrakeF_OD_CAN2_autoErrorReset;
            using BrakeF_OD_CAN2_lastErrorCode = signals::BrakeF_OD_CAN2_lastErrorCode;
            using BrakeF_OD_CAN2_RxErrCnt = signals::BrakeF_OD_CAN2_RxErrCnt;
            using BrakeF_OD_CAN2_TxErrCnt = signals::BrakeF_OD_CAN2_TxErrCnt;
            using BrakeF_OD_CAN1_DelayedTxMessages = signals::BrakeF_OD_CAN1_DelayedTxMessages;
            using BrakeF_OD_CAN1_ErrorStatus = signals::BrakeF_OD_CAN1_ErrorStatus;
            using BrakeF_OD_CAN1_DiscardedTxMessages = signals::BrakeF_OD_CAN1_DiscardedTxMessages;
            using BrakeF_OD_CAN1_Status = signals::BrakeF_OD_CAN1_Status;
            using BrakeF_OD_CAN1_Baudrate = signals::BrakeF_OD_CAN1_Baudrate;
            using BrakeF_OD_CAN1_autoErrorReset = signals::BrakeF_OD_CAN1_autoErrorReset;
            using BrakeF_OD_CAN1_lastErrorCode = signals::BrakeF_OD_CAN1_lastErrorCode;
            using BrakeF_OD_CAN1_RxErrCnt = signals::BrakeF_OD_CAN1_RxErrCnt;
            using BrakeF_OD_CAN1_TxErrCnt = signals::BrakeF_OD_CAN1_TxErrCnt;
            using BrakeF_OD_BuildTime = signals::BrakeF_OD_BuildTime;
            using BrakeF_OD_BuildDate = signals::BrakeF_OD_BuildDate;
            using BrakeF_OD_ChipUID2 = signals::BrakeF_OD_ChipUID2;
            using BrakeF_OD_ChipUID1 = signals::BrakeF_OD_ChipUID1;
            using BrakeF_OD_SdcOut = signals::BrakeF_OD_SdcOut;
            using BrakeF_OD_SdcIn = signals::BrakeF_OD_SdcIn;
            using BrakeF_OD_runtime = signals::BrakeF_OD_runtime;
            using BrakeF_OD_InputVoltage = signals::BrakeF_OD_InputVoltage;
            using BrakeF_OD_BoardTemp = signals::BrakeF_OD_BoardTemp;
            using BrakeF_OD_MemFree = signals::BrakeF_OD_MemFree;
            using BrakeF_OD_CpuUsage = signals::BrakeF_OD_CpuUsage;
            using BrakeF_OD_OdEntrySendInterval = signals::BrakeF_OD_OdEntrySendInterval;
            using BrakeF_OD_SendOdOnBootup = signals::BrakeF_OD_SendOdOnBootup;
            using BrakeF_OD_HeartbeatInterval = signals::BrakeF_OD_HeartbeatInterval;
            using BrakeF_OD_DbcVersion = signals::BrakeF_OD_DbcVersion;
            using BrakeF_OD_StackVersion = signals::BrakeF_OD_StackVersion;
            using BrakeF_OD_ProtocolVersion = signals::BrakeF_OD_ProtocolVersion;
            using BrakeF_OD_NodeStatus = signals::BrakeF_OD_NodeStatus;
            using BrakeF_OD_NodeID = signals::BrakeF_OD_NodeID;

            // Attributes of message 'BrakeF_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5D1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_SDO_ID = signals::BrakeF_SDO_ID;
            using BrakeF_OD_valveUpperTolerance = signals::BrakeF_OD_valveUpperTolerance;
            using BrakeF_OD_commWatchdog = signals::BrakeF_OD_commWatchdog;
            using BrakeF_OD_counterLimit = signals::BrakeF_OD_counterLimit;
            using BrakeF_OD_delay = signals::BrakeF_OD_delay;
            using BrakeF_OD_tankUpperControlLimit = signals::BrakeF_OD_tankUpperControlLimit;
            using BrakeF_OD_tankLowerControlLimit = signals::BrakeF_OD_tankLowerControlLimit;
            using BrakeF_OD_CAN2_DelayedTxMessages = signals::BrakeF_OD_CAN2_DelayedTxMessages;
            using BrakeF_OD_CAN2_ErrorStatus = signals::BrakeF_OD_CAN2_ErrorStatus;
            using BrakeF_OD_CAN2_DiscardedTxMessages = signals::BrakeF_OD_CAN2_DiscardedTxMessages;
            using BrakeF_OD_CAN2_Status = signals::BrakeF_OD_CAN2_Status;
            using BrakeF_OD_CAN2_Baudrate = signals::BrakeF_OD_CAN2_Baudrate;
            using BrakeF_OD_CAN2_autoErrorReset = signals::BrakeF_OD_CAN2_autoErrorReset;
            using BrakeF_OD_CAN2_lastErrorCode = signals::BrakeF_OD_CAN2_lastErrorCode;
            using BrakeF_OD_CAN2_RxErrCnt = signals::BrakeF_OD_CAN2_RxErrCnt;
            using BrakeF_OD_CAN2_TxErrCnt = signals::BrakeF_OD_CAN2_TxErrCnt;
            using BrakeF_OD_CAN1_DelayedTxMessages = signals::BrakeF_OD_CAN1_DelayedTxMessages;
            using BrakeF_OD_CAN1_ErrorStatus = signals::BrakeF_OD_CAN1_ErrorStatus;
            using BrakeF_OD_CAN1_DiscardedTxMessages = signals::BrakeF_OD_CAN1_DiscardedTxMessages;
            using BrakeF_OD_CAN1_Status = signals::BrakeF_OD_CAN1_Status;
            using BrakeF_OD_CAN1_Baudrate = signals::BrakeF_OD_CAN1_Baudrate;
            using BrakeF_OD_CAN1_autoErrorReset = signals::BrakeF_OD_CAN1_autoErrorReset;
            using BrakeF_OD_CAN1_lastErrorCode = signals::BrakeF_OD_CAN1_lastErrorCode;
            using BrakeF_OD_CAN1_RxErrCnt = signals::BrakeF_OD_CAN1_RxErrCnt;
            using BrakeF_OD_CAN1_TxErrCnt = signals::BrakeF_OD_CAN1_TxErrCnt;
            using BrakeF_OD_BuildTime = signals::BrakeF_OD_BuildTime;
            using BrakeF_OD_BuildDate = signals::BrakeF_OD_BuildDate;
            using BrakeF_OD_ChipUID2 = signals::BrakeF_OD_ChipUID2;
            using BrakeF_OD_ChipUID1 = signals::BrakeF_OD_ChipUID1;
            using BrakeF_OD_SdcOut = signals::BrakeF_OD_SdcOut;
            using BrakeF_OD_SdcIn = signals::BrakeF_OD_SdcIn;
            using BrakeF_OD_runtime = signals::BrakeF_OD_runtime;
            using BrakeF_OD_InputVoltage = signals::BrakeF_OD_InputVoltage;
            using BrakeF_OD_BoardTemp = signals::BrakeF_OD_BoardTemp;
            using BrakeF_OD_MemFree = signals::BrakeF_OD_MemFree;
            using BrakeF_OD_CpuUsage = signals::BrakeF_OD_CpuUsage;
            using BrakeF_OD_OdEntrySendInterval = signals::BrakeF_OD_OdEntrySendInterval;
            using BrakeF_OD_SendOdOnBootup = signals::BrakeF_OD_SendOdOnBootup;
            using BrakeF_OD_HeartbeatInterval = signals::BrakeF_OD_HeartbeatInterval;
            using BrakeF_OD_DbcVersion = signals::BrakeF_OD_DbcVersion;
            using BrakeF_OD_StackVersion = signals::BrakeF_OD_StackVersion;
            using BrakeF_OD_ProtocolVersion = signals::BrakeF_OD_ProtocolVersion;
            using BrakeF_OD_NodeStatus = signals::BrakeF_OD_NodeStatus;
            using BrakeF_OD_NodeID = signals::BrakeF_OD_NodeID;

            // Attributes of message 'BrakeF_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x611;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_SDO_ID = signals::BrakeF_SDO_ID;

            // Attributes of message 'BrakeF_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_Heartbeat {
            public:
            constexpr static uint32_t id = 0x711;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeF_NodeState = signals::BrakeF_NodeState;

            // Attributes of message 'BrakeF_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_BTL_TX {
            public:
            constexpr static uint32_t id = 0x751;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeF_BTL_RX {
            public:
            constexpr static uint32_t id = 0x791;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeF_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_EMCY {
            public:
            constexpr static uint32_t id = 0x92;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_W0_highPressureActingChamber = signals::BrakeR_W0_highPressureActingChamber;
            using BrakeR_W1_highPressureRetractingChamber = signals::BrakeR_W1_highPressureRetractingChamber;
            using BrakeR_W2_enableWithAnError = signals::BrakeR_W2_enableWithAnError;
            using BrakeR_W3_externalError = signals::BrakeR_W3_externalError;
            using BrakeR_E0_pressureTooHigh = signals::BrakeR_E0_pressureTooHigh;
            using BrakeR_E1_pressureTooLow = signals::BrakeR_E1_pressureTooLow;
            using BrakeR_E2_commWatchdogTimeout = signals::BrakeR_E2_commWatchdogTimeout;
            using BrakeR_E3_retractUnsuccesful_errorFlag = signals::BrakeR_E3_retractUnsuccesful_errorFlag;
            using BrakeR_E4_retractUnsuccesful_notEnabled = signals::BrakeR_E4_retractUnsuccesful_notEnabled;
            using BrakeR_E5_retractUnsuccesful_openSDC = signals::BrakeR_E5_retractUnsuccesful_openSDC;

            // Attributes of message 'BrakeR_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_Status {
            public:
            constexpr static uint32_t id = 0x192;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_TX_Status_ = signals::BrakeR_TX_Status;
            using BrakeR_TX_Enabled = signals::BrakeR_TX_Enabled;
            using BrakeR_TX_ErrorFlag = signals::BrakeR_TX_ErrorFlag;
            using BrakeR_TX_SDC_Input = signals::BrakeR_TX_SDC_Input;
            using BrakeR_TX_DeltaTime_Control = signals::BrakeR_TX_DeltaTime_Control;
            using BrakeR_TX_MaxDeltaTime_Control = signals::BrakeR_TX_MaxDeltaTime_Control;

            // Attributes of message 'BrakeR_TX_Status'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_RX_Control {
            public:
            constexpr static uint32_t id = 0x1D2;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_RX_ErrorReset = signals::BrakeR_RX_ErrorReset;
            using BrakeR_RX_Enable = signals::BrakeR_RX_Enable;
            using BrakeR_RX_Engage = signals::BrakeR_RX_Engage;

            // Attributes of message 'BrakeR_RX_Control'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x212;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x252;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x292;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2D2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x312;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x352;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x392;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3D2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x412;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_Pressure {
            public:
            constexpr static uint32_t id = 0x452;
            constexpr static uint8_t dlc = 5;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_TX_Pressure_Act = signals::BrakeR_TX_Pressure_Act;
            using BrakeR_TX_Pressure_Retract = signals::BrakeR_TX_Pressure_Retract;
            using BrakeR_TX_Pressure_Tank = signals::BrakeR_TX_Pressure_Tank;

            // Attributes of message 'BrakeR_TX_Pressure'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x492;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4D2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x512;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x552;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x592;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_SDO_ID = signals::BrakeR_SDO_ID;
            using BrakeR_SDO_RespCode = signals::BrakeR_SDO_RespCode;
            using BrakeR_OD_valveUpperTolerance = signals::BrakeR_OD_valveUpperTolerance;
            using BrakeR_OD_commWatchdog = signals::BrakeR_OD_commWatchdog;
            using BrakeR_OD_counterLimit = signals::BrakeR_OD_counterLimit;
            using BrakeR_OD_delay = signals::BrakeR_OD_delay;
            using BrakeR_OD_tankUpperControlLimit = signals::BrakeR_OD_tankUpperControlLimit;
            using BrakeR_OD_tankLowerControlLimit = signals::BrakeR_OD_tankLowerControlLimit;
            using BrakeR_OD_CAN2_DelayedTxMessages = signals::BrakeR_OD_CAN2_DelayedTxMessages;
            using BrakeR_OD_CAN2_ErrorStatus = signals::BrakeR_OD_CAN2_ErrorStatus;
            using BrakeR_OD_CAN2_DiscardedTxMessages = signals::BrakeR_OD_CAN2_DiscardedTxMessages;
            using BrakeR_OD_CAN2_Status = signals::BrakeR_OD_CAN2_Status;
            using BrakeR_OD_CAN2_Baudrate = signals::BrakeR_OD_CAN2_Baudrate;
            using BrakeR_OD_CAN2_autoErrorReset = signals::BrakeR_OD_CAN2_autoErrorReset;
            using BrakeR_OD_CAN2_lastErrorCode = signals::BrakeR_OD_CAN2_lastErrorCode;
            using BrakeR_OD_CAN2_RxErrCnt = signals::BrakeR_OD_CAN2_RxErrCnt;
            using BrakeR_OD_CAN2_TxErrCnt = signals::BrakeR_OD_CAN2_TxErrCnt;
            using BrakeR_OD_CAN1_DelayedTxMessages = signals::BrakeR_OD_CAN1_DelayedTxMessages;
            using BrakeR_OD_CAN1_ErrorStatus = signals::BrakeR_OD_CAN1_ErrorStatus;
            using BrakeR_OD_CAN1_DiscardedTxMessages = signals::BrakeR_OD_CAN1_DiscardedTxMessages;
            using BrakeR_OD_CAN1_Status = signals::BrakeR_OD_CAN1_Status;
            using BrakeR_OD_CAN1_Baudrate = signals::BrakeR_OD_CAN1_Baudrate;
            using BrakeR_OD_CAN1_autoErrorReset = signals::BrakeR_OD_CAN1_autoErrorReset;
            using BrakeR_OD_CAN1_lastErrorCode = signals::BrakeR_OD_CAN1_lastErrorCode;
            using BrakeR_OD_CAN1_RxErrCnt = signals::BrakeR_OD_CAN1_RxErrCnt;
            using BrakeR_OD_CAN1_TxErrCnt = signals::BrakeR_OD_CAN1_TxErrCnt;
            using BrakeR_OD_BuildTime = signals::BrakeR_OD_BuildTime;
            using BrakeR_OD_BuildDate = signals::BrakeR_OD_BuildDate;
            using BrakeR_OD_ChipUID2 = signals::BrakeR_OD_ChipUID2;
            using BrakeR_OD_ChipUID1 = signals::BrakeR_OD_ChipUID1;
            using BrakeR_OD_SdcOut = signals::BrakeR_OD_SdcOut;
            using BrakeR_OD_SdcIn = signals::BrakeR_OD_SdcIn;
            using BrakeR_OD_runtime = signals::BrakeR_OD_runtime;
            using BrakeR_OD_InputVoltage = signals::BrakeR_OD_InputVoltage;
            using BrakeR_OD_BoardTemp = signals::BrakeR_OD_BoardTemp;
            using BrakeR_OD_MemFree = signals::BrakeR_OD_MemFree;
            using BrakeR_OD_CpuUsage = signals::BrakeR_OD_CpuUsage;
            using BrakeR_OD_OdEntrySendInterval = signals::BrakeR_OD_OdEntrySendInterval;
            using BrakeR_OD_SendOdOnBootup = signals::BrakeR_OD_SendOdOnBootup;
            using BrakeR_OD_HeartbeatInterval = signals::BrakeR_OD_HeartbeatInterval;
            using BrakeR_OD_DbcVersion = signals::BrakeR_OD_DbcVersion;
            using BrakeR_OD_StackVersion = signals::BrakeR_OD_StackVersion;
            using BrakeR_OD_ProtocolVersion = signals::BrakeR_OD_ProtocolVersion;
            using BrakeR_OD_NodeStatus = signals::BrakeR_OD_NodeStatus;
            using BrakeR_OD_NodeID = signals::BrakeR_OD_NodeID;

            // Attributes of message 'BrakeR_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5D2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_SDO_ID = signals::BrakeR_SDO_ID;
            using BrakeR_OD_valveUpperTolerance = signals::BrakeR_OD_valveUpperTolerance;
            using BrakeR_OD_commWatchdog = signals::BrakeR_OD_commWatchdog;
            using BrakeR_OD_counterLimit = signals::BrakeR_OD_counterLimit;
            using BrakeR_OD_delay = signals::BrakeR_OD_delay;
            using BrakeR_OD_tankUpperControlLimit = signals::BrakeR_OD_tankUpperControlLimit;
            using BrakeR_OD_tankLowerControlLimit = signals::BrakeR_OD_tankLowerControlLimit;
            using BrakeR_OD_CAN2_DelayedTxMessages = signals::BrakeR_OD_CAN2_DelayedTxMessages;
            using BrakeR_OD_CAN2_ErrorStatus = signals::BrakeR_OD_CAN2_ErrorStatus;
            using BrakeR_OD_CAN2_DiscardedTxMessages = signals::BrakeR_OD_CAN2_DiscardedTxMessages;
            using BrakeR_OD_CAN2_Status = signals::BrakeR_OD_CAN2_Status;
            using BrakeR_OD_CAN2_Baudrate = signals::BrakeR_OD_CAN2_Baudrate;
            using BrakeR_OD_CAN2_autoErrorReset = signals::BrakeR_OD_CAN2_autoErrorReset;
            using BrakeR_OD_CAN2_lastErrorCode = signals::BrakeR_OD_CAN2_lastErrorCode;
            using BrakeR_OD_CAN2_RxErrCnt = signals::BrakeR_OD_CAN2_RxErrCnt;
            using BrakeR_OD_CAN2_TxErrCnt = signals::BrakeR_OD_CAN2_TxErrCnt;
            using BrakeR_OD_CAN1_DelayedTxMessages = signals::BrakeR_OD_CAN1_DelayedTxMessages;
            using BrakeR_OD_CAN1_ErrorStatus = signals::BrakeR_OD_CAN1_ErrorStatus;
            using BrakeR_OD_CAN1_DiscardedTxMessages = signals::BrakeR_OD_CAN1_DiscardedTxMessages;
            using BrakeR_OD_CAN1_Status = signals::BrakeR_OD_CAN1_Status;
            using BrakeR_OD_CAN1_Baudrate = signals::BrakeR_OD_CAN1_Baudrate;
            using BrakeR_OD_CAN1_autoErrorReset = signals::BrakeR_OD_CAN1_autoErrorReset;
            using BrakeR_OD_CAN1_lastErrorCode = signals::BrakeR_OD_CAN1_lastErrorCode;
            using BrakeR_OD_CAN1_RxErrCnt = signals::BrakeR_OD_CAN1_RxErrCnt;
            using BrakeR_OD_CAN1_TxErrCnt = signals::BrakeR_OD_CAN1_TxErrCnt;
            using BrakeR_OD_BuildTime = signals::BrakeR_OD_BuildTime;
            using BrakeR_OD_BuildDate = signals::BrakeR_OD_BuildDate;
            using BrakeR_OD_ChipUID2 = signals::BrakeR_OD_ChipUID2;
            using BrakeR_OD_ChipUID1 = signals::BrakeR_OD_ChipUID1;
            using BrakeR_OD_SdcOut = signals::BrakeR_OD_SdcOut;
            using BrakeR_OD_SdcIn = signals::BrakeR_OD_SdcIn;
            using BrakeR_OD_runtime = signals::BrakeR_OD_runtime;
            using BrakeR_OD_InputVoltage = signals::BrakeR_OD_InputVoltage;
            using BrakeR_OD_BoardTemp = signals::BrakeR_OD_BoardTemp;
            using BrakeR_OD_MemFree = signals::BrakeR_OD_MemFree;
            using BrakeR_OD_CpuUsage = signals::BrakeR_OD_CpuUsage;
            using BrakeR_OD_OdEntrySendInterval = signals::BrakeR_OD_OdEntrySendInterval;
            using BrakeR_OD_SendOdOnBootup = signals::BrakeR_OD_SendOdOnBootup;
            using BrakeR_OD_HeartbeatInterval = signals::BrakeR_OD_HeartbeatInterval;
            using BrakeR_OD_DbcVersion = signals::BrakeR_OD_DbcVersion;
            using BrakeR_OD_StackVersion = signals::BrakeR_OD_StackVersion;
            using BrakeR_OD_ProtocolVersion = signals::BrakeR_OD_ProtocolVersion;
            using BrakeR_OD_NodeStatus = signals::BrakeR_OD_NodeStatus;
            using BrakeR_OD_NodeID = signals::BrakeR_OD_NodeID;

            // Attributes of message 'BrakeR_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x612;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_SDO_ID = signals::BrakeR_SDO_ID;

            // Attributes of message 'BrakeR_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_Heartbeat {
            public:
            constexpr static uint32_t id = 0x712;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using BrakeR_NodeState = signals::BrakeR_NodeState;

            // Attributes of message 'BrakeR_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_BTL_TX {
            public:
            constexpr static uint32_t id = 0x752;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class BrakeR_BTL_RX {
            public:
            constexpr static uint32_t id = 0x792;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'BrakeR_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_EMCY {
            public:
            constexpr static uint32_t id = 0x9A;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_W0_OtherWarning = signals::PDU_W0_OtherWarning;
            using PDU_W1_batterVoltageLow = signals::PDU_W1_batterVoltageLow;
            using PDU_W2_batterTempHigh = signals::PDU_W2_batterTempHigh;
            using PDU_E0_OtherError = signals::PDU_E0_OtherError;
            using PDU_E1_batterVoltageCritical = signals::PDU_E1_batterVoltageCritical;
            using PDU_E2_batteryOvercurrent = signals::PDU_E2_batteryOvercurrent;
            using PDU_E3_batterTempCritical = signals::PDU_E3_batterTempCritical;
            using PDU_E4_watchdogStateMachine = signals::PDU_E4_watchdogStateMachine;

            // Attributes of message 'PDU_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_Status {
            public:
            constexpr static uint32_t id = 0x19A;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_TX_Enabled = signals::PDU_TX_Enabled;
            using PDU_TX_ErrorFlag = signals::PDU_TX_ErrorFlag;
            using PDU_TX_PEHWEnabled = signals::PDU_TX_PEHWEnabled;

            // Attributes of message 'PDU_TX_Status'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_RX_Control {
            public:
            constexpr static uint32_t id = 0x1DA;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_RX_Enable = signals::PDU_RX_Enable;
            using PDU_RX_ErrorReset = signals::PDU_RX_ErrorReset;
            using PDU_RX_PEHWEnable = signals::PDU_RX_PEHWEnable;

            // Attributes of message 'PDU_RX_Control'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_HP_Current {
            public:
            constexpr static uint32_t id = 0x21A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_HPCh1_Current = signals::PDU_HPCh1_Current;
            using PDU_HPCh2_Current = signals::PDU_HPCh2_Current;
            using PDU_HPCh3_Current = signals::PDU_HPCh3_Current;
            using PDU_HPCh4_Current = signals::PDU_HPCh4_Current;

            // Attributes of message 'PDU_TX_HP_Current'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_RX_LP_Dutycycle {
            public:
            constexpr static uint32_t id = 0x25A;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_LPCh1_Dutycycle = signals::PDU_LPCh1_Dutycycle;
            using PDU_LPCh10_Dutycycle = signals::PDU_LPCh10_Dutycycle;
            using PDU_LPCh2_Dutycycle = signals::PDU_LPCh2_Dutycycle;
            using PDU_LPCh3_Dutycycle = signals::PDU_LPCh3_Dutycycle;
            using PDU_LPCh8_Dutycycle = signals::PDU_LPCh8_Dutycycle;
            using PDU_LPCh9_Dutycycle = signals::PDU_LPCh9_Dutycycle;

            // Attributes of message 'PDU_RX_LP_Dutycycle'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_HP_Short_Circuit_Debug {
            public:
            constexpr static uint32_t id = 0x29A;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_HPCh1_ShortCnt = signals::PDU_HPCh1_ShortCnt;
            using PDU_HPCh1_State = signals::PDU_HPCh1_State;
            using PDU_HPCh2_State = signals::PDU_HPCh2_State;
            using PDU_HPCh2_ShortCnt = signals::PDU_HPCh2_ShortCnt;
            using PDU_HPCh3_ShortCnt = signals::PDU_HPCh3_ShortCnt;
            using PDU_HPCh3_State = signals::PDU_HPCh3_State;
            using PDU_HPCh4_ShortCnt = signals::PDU_HPCh4_ShortCnt;
            using PDU_HPCh4_State = signals::PDU_HPCh4_State;

            // Attributes of message 'PDU_TX_HP_Short_Circuit_Debug'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_RX_HP_D_Dutycycle {
            public:
            constexpr static uint32_t id = 0x2DA;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_HPCh1_Dutycycle = signals::PDU_HPCh1_Dutycycle;
            using PDU_HPCh2_Dutycycle = signals::PDU_HPCh2_Dutycycle;
            using PDU_D1_Dutycycle = signals::PDU_D1_Dutycycle;
            using PDU_D2_Dutycycle = signals::PDU_D2_Dutycycle;
            using PDU_D3_Dutycycle = signals::PDU_D3_Dutycycle;
            using PDU_D4_Dutycycle = signals::PDU_D4_Dutycycle;

            // Attributes of message 'PDU_RX_HP_D_Dutycycle'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x31A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_RX_Manual_Control {
            public:
            constexpr static uint32_t id = 0x35A;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_LPCh1_Enable = signals::PDU_LPCh1_Enable;
            using PDU_LPCh2_Enable = signals::PDU_LPCh2_Enable;
            using PDU_LPCh3_Enable = signals::PDU_LPCh3_Enable;
            using PDU_LPCh4_Enable = signals::PDU_LPCh4_Enable;
            using PDU_LPCh5_Enable = signals::PDU_LPCh5_Enable;
            using PDU_LPCh6_Enable = signals::PDU_LPCh6_Enable;
            using PDU_LPCh7_Enable = signals::PDU_LPCh7_Enable;
            using PDU_LPCh8_Enable = signals::PDU_LPCh8_Enable;
            using PDU_LPCh9_Enable = signals::PDU_LPCh9_Enable;
            using PDU_LPCh10_Enable = signals::PDU_LPCh10_Enable;
            using PDU_HPCh1_Enable = signals::PDU_HPCh1_Enable;
            using PDU_HPCh2_Enable = signals::PDU_HPCh2_Enable;
            using PDU_HPCh3_Enable = signals::PDU_HPCh3_Enable;
            using PDU_HPCh4_Enable = signals::PDU_HPCh4_Enable;
            using PDU_D1_Enable = signals::PDU_D1_Enable;
            using PDU_D2_Enable = signals::PDU_D2_Enable;
            using PDU_D3_Enable = signals::PDU_D3_Enable;
            using PDU_D4_Enable = signals::PDU_D4_Enable;
            using PDU_SDC_Enable = signals::PDU_SDC_Enable;

            // Attributes of message 'PDU_RX_Manual_Control'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x39A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3DA;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x41A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x45A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_LP_Short_Circuit_Debug {
            public:
            constexpr static uint32_t id = 0x49A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_LPCh10_ShortCnt = signals::PDU_LPCh10_ShortCnt;
            using PDU_LPCh1_ShortCnt = signals::PDU_LPCh1_ShortCnt;
            using PDU_LPCh2_ShortCnt = signals::PDU_LPCh2_ShortCnt;
            using PDU_LPCh3_ShortCnt = signals::PDU_LPCh3_ShortCnt;
            using PDU_LPCh4_ShortCnt = signals::PDU_LPCh4_ShortCnt;
            using PDU_LPCh5_ShortCnt = signals::PDU_LPCh5_ShortCnt;
            using PDU_LPCh6_ShortCnt = signals::PDU_LPCh6_ShortCnt;
            using PDU_LPCh7_ShortCnt = signals::PDU_LPCh7_ShortCnt;
            using PDU_LPCh8_ShortCnt = signals::PDU_LPCh8_ShortCnt;
            using PDU_LPCh9_ShortCnt = signals::PDU_LPCh9_ShortCnt;
            using PDU_LPCh10_State = signals::PDU_LPCh10_State;
            using PDU_LPCh1_State = signals::PDU_LPCh1_State;
            using PDU_LPCh2_State = signals::PDU_LPCh2_State;
            using PDU_LPCh3_State = signals::PDU_LPCh3_State;
            using PDU_LPCh4_State = signals::PDU_LPCh4_State;
            using PDU_LPCh5_State = signals::PDU_LPCh5_State;
            using PDU_LPCh6_State = signals::PDU_LPCh6_State;
            using PDU_LPCh7_State = signals::PDU_LPCh7_State;
            using PDU_LPCh8_State = signals::PDU_LPCh8_State;
            using PDU_LPCh9_State = signals::PDU_LPCh9_State;

            // Attributes of message 'PDU_TX_LP_Short_Circuit_Debug'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_LV_BMS {
            public:
            constexpr static uint32_t id = 0x4DA;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_LV_Current = signals::PDU_LV_Current;
            using PDU_LV_Voltage = signals::PDU_LV_Voltage;
            using PDU_LV_SOC = signals::PDU_LV_SOC;

            // Attributes of message 'PDU_TX_LV_BMS'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_LP_Current1 {
            public:
            constexpr static uint32_t id = 0x51A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_LPCh1_Current = signals::PDU_LPCh1_Current;
            using PDU_LPCh2_Current = signals::PDU_LPCh2_Current;
            using PDU_LPCh3_Current = signals::PDU_LPCh3_Current;
            using PDU_LPCh4_Current = signals::PDU_LPCh4_Current;
            using PDU_LPCh5_Current = signals::PDU_LPCh5_Current;

            // Attributes of message 'PDU_TX_LP_Current1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_TX_LP_Current2 {
            public:
            constexpr static uint32_t id = 0x55A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_LPCh10_Current = signals::PDU_LPCh10_Current;
            using PDU_LPCh6_Current = signals::PDU_LPCh6_Current;
            using PDU_LPCh7_Current = signals::PDU_LPCh7_Current;
            using PDU_LPCh8_Current = signals::PDU_LPCh8_Current;
            using PDU_LPCh9_Current = signals::PDU_LPCh9_Current;

            // Attributes of message 'PDU_TX_LP_Current2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x59A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_SDO_ID = signals::PDU_SDO_ID;
            using PDU_SDO_RespCode = signals::PDU_SDO_RespCode;
            using PDU_OD_CoolingPumpEnabled = signals::PDU_OD_CoolingPumpEnabled;
            using PDU_OD_LedCommands = signals::PDU_OD_LedCommands;
            using PDU_OD_projectXXEnabled = signals::PDU_OD_projectXXEnabled;
            using PDU_OD_watchdogTimeout = signals::PDU_OD_watchdogTimeout;
            using PDU_OD_statusSendInterval = signals::PDU_OD_statusSendInterval;
            using PDU_OD_currentReadInterval = signals::PDU_OD_currentReadInterval;
            using PDU_OD_batteryOvercurrent = signals::PDU_OD_batteryOvercurrent;
            using PDU_OD_overTempCritical = signals::PDU_OD_overTempCritical;
            using PDU_OD_overTempWarn = signals::PDU_OD_overTempWarn;
            using PDU_OD_batterVoltageCritical = signals::PDU_OD_batterVoltageCritical;
            using PDU_OD_batterVoltageLow = signals::PDU_OD_batterVoltageLow;
            using PDU_OD_CAN2_DelayedTxMessages = signals::PDU_OD_CAN2_DelayedTxMessages;
            using PDU_OD_CAN2_ErrorStatus = signals::PDU_OD_CAN2_ErrorStatus;
            using PDU_OD_CAN2_DiscardedTxMessages = signals::PDU_OD_CAN2_DiscardedTxMessages;
            using PDU_OD_CAN2_Status = signals::PDU_OD_CAN2_Status;
            using PDU_OD_CAN2_Baudrate = signals::PDU_OD_CAN2_Baudrate;
            using PDU_OD_CAN2_autoErrorReset = signals::PDU_OD_CAN2_autoErrorReset;
            using PDU_OD_CAN2_lastErrorCode = signals::PDU_OD_CAN2_lastErrorCode;
            using PDU_OD_CAN2_RxErrCnt = signals::PDU_OD_CAN2_RxErrCnt;
            using PDU_OD_CAN2_TxErrCnt = signals::PDU_OD_CAN2_TxErrCnt;
            using PDU_OD_CAN1_DelayedTxMessages = signals::PDU_OD_CAN1_DelayedTxMessages;
            using PDU_OD_CAN1_ErrorStatus = signals::PDU_OD_CAN1_ErrorStatus;
            using PDU_OD_CAN1_DiscardedTxMessages = signals::PDU_OD_CAN1_DiscardedTxMessages;
            using PDU_OD_CAN1_Status = signals::PDU_OD_CAN1_Status;
            using PDU_OD_CAN1_Baudrate = signals::PDU_OD_CAN1_Baudrate;
            using PDU_OD_CAN1_autoErrorReset = signals::PDU_OD_CAN1_autoErrorReset;
            using PDU_OD_CAN1_lastErrorCode = signals::PDU_OD_CAN1_lastErrorCode;
            using PDU_OD_CAN1_RxErrCnt = signals::PDU_OD_CAN1_RxErrCnt;
            using PDU_OD_CAN1_TxErrCnt = signals::PDU_OD_CAN1_TxErrCnt;
            using PDU_OD_BuildTime = signals::PDU_OD_BuildTime;
            using PDU_OD_BuildDate = signals::PDU_OD_BuildDate;
            using PDU_OD_ChipUID2 = signals::PDU_OD_ChipUID2;
            using PDU_OD_ChipUID1 = signals::PDU_OD_ChipUID1;
            using PDU_OD_SdcOut = signals::PDU_OD_SdcOut;
            using PDU_OD_SdcIn = signals::PDU_OD_SdcIn;
            using PDU_OD_runtime = signals::PDU_OD_runtime;
            using PDU_OD_InputVoltage = signals::PDU_OD_InputVoltage;
            using PDU_OD_BoardTemp = signals::PDU_OD_BoardTemp;
            using PDU_OD_MemFree = signals::PDU_OD_MemFree;
            using PDU_OD_CpuUsage = signals::PDU_OD_CpuUsage;
            using PDU_OD_OdEntrySendInterval = signals::PDU_OD_OdEntrySendInterval;
            using PDU_OD_SendOdOnBootup = signals::PDU_OD_SendOdOnBootup;
            using PDU_OD_HeartbeatInterval = signals::PDU_OD_HeartbeatInterval;
            using PDU_OD_DbcVersion = signals::PDU_OD_DbcVersion;
            using PDU_OD_StackVersion = signals::PDU_OD_StackVersion;
            using PDU_OD_ProtocolVersion = signals::PDU_OD_ProtocolVersion;
            using PDU_OD_NodeStatus = signals::PDU_OD_NodeStatus;
            using PDU_OD_NodeID = signals::PDU_OD_NodeID;

            // Attributes of message 'PDU_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5DA;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_SDO_ID = signals::PDU_SDO_ID;
            using PDU_OD_CoolingPumpEnabled = signals::PDU_OD_CoolingPumpEnabled;
            using PDU_OD_LedCommands = signals::PDU_OD_LedCommands;
            using PDU_OD_projectXXEnabled = signals::PDU_OD_projectXXEnabled;
            using PDU_OD_watchdogTimeout = signals::PDU_OD_watchdogTimeout;
            using PDU_OD_statusSendInterval = signals::PDU_OD_statusSendInterval;
            using PDU_OD_currentReadInterval = signals::PDU_OD_currentReadInterval;
            using PDU_OD_batteryOvercurrent = signals::PDU_OD_batteryOvercurrent;
            using PDU_OD_overTempCritical = signals::PDU_OD_overTempCritical;
            using PDU_OD_overTempWarn = signals::PDU_OD_overTempWarn;
            using PDU_OD_batterVoltageCritical = signals::PDU_OD_batterVoltageCritical;
            using PDU_OD_batterVoltageLow = signals::PDU_OD_batterVoltageLow;
            using PDU_OD_CAN2_DelayedTxMessages = signals::PDU_OD_CAN2_DelayedTxMessages;
            using PDU_OD_CAN2_ErrorStatus = signals::PDU_OD_CAN2_ErrorStatus;
            using PDU_OD_CAN2_DiscardedTxMessages = signals::PDU_OD_CAN2_DiscardedTxMessages;
            using PDU_OD_CAN2_Status = signals::PDU_OD_CAN2_Status;
            using PDU_OD_CAN2_Baudrate = signals::PDU_OD_CAN2_Baudrate;
            using PDU_OD_CAN2_autoErrorReset = signals::PDU_OD_CAN2_autoErrorReset;
            using PDU_OD_CAN2_lastErrorCode = signals::PDU_OD_CAN2_lastErrorCode;
            using PDU_OD_CAN2_RxErrCnt = signals::PDU_OD_CAN2_RxErrCnt;
            using PDU_OD_CAN2_TxErrCnt = signals::PDU_OD_CAN2_TxErrCnt;
            using PDU_OD_CAN1_DelayedTxMessages = signals::PDU_OD_CAN1_DelayedTxMessages;
            using PDU_OD_CAN1_ErrorStatus = signals::PDU_OD_CAN1_ErrorStatus;
            using PDU_OD_CAN1_DiscardedTxMessages = signals::PDU_OD_CAN1_DiscardedTxMessages;
            using PDU_OD_CAN1_Status = signals::PDU_OD_CAN1_Status;
            using PDU_OD_CAN1_Baudrate = signals::PDU_OD_CAN1_Baudrate;
            using PDU_OD_CAN1_autoErrorReset = signals::PDU_OD_CAN1_autoErrorReset;
            using PDU_OD_CAN1_lastErrorCode = signals::PDU_OD_CAN1_lastErrorCode;
            using PDU_OD_CAN1_RxErrCnt = signals::PDU_OD_CAN1_RxErrCnt;
            using PDU_OD_CAN1_TxErrCnt = signals::PDU_OD_CAN1_TxErrCnt;
            using PDU_OD_BuildTime = signals::PDU_OD_BuildTime;
            using PDU_OD_BuildDate = signals::PDU_OD_BuildDate;
            using PDU_OD_ChipUID2 = signals::PDU_OD_ChipUID2;
            using PDU_OD_ChipUID1 = signals::PDU_OD_ChipUID1;
            using PDU_OD_SdcOut = signals::PDU_OD_SdcOut;
            using PDU_OD_SdcIn = signals::PDU_OD_SdcIn;
            using PDU_OD_runtime = signals::PDU_OD_runtime;
            using PDU_OD_InputVoltage = signals::PDU_OD_InputVoltage;
            using PDU_OD_BoardTemp = signals::PDU_OD_BoardTemp;
            using PDU_OD_MemFree = signals::PDU_OD_MemFree;
            using PDU_OD_CpuUsage = signals::PDU_OD_CpuUsage;
            using PDU_OD_OdEntrySendInterval = signals::PDU_OD_OdEntrySendInterval;
            using PDU_OD_SendOdOnBootup = signals::PDU_OD_SendOdOnBootup;
            using PDU_OD_HeartbeatInterval = signals::PDU_OD_HeartbeatInterval;
            using PDU_OD_DbcVersion = signals::PDU_OD_DbcVersion;
            using PDU_OD_StackVersion = signals::PDU_OD_StackVersion;
            using PDU_OD_ProtocolVersion = signals::PDU_OD_ProtocolVersion;
            using PDU_OD_NodeStatus = signals::PDU_OD_NodeStatus;
            using PDU_OD_NodeID = signals::PDU_OD_NodeID;

            // Attributes of message 'PDU_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x61A;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_SDO_ID = signals::PDU_SDO_ID;

            // Attributes of message 'PDU_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_Heartbeat {
            public:
            constexpr static uint32_t id = 0x71A;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using PDU_NodeState = signals::PDU_NodeState;

            // Attributes of message 'PDU_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_BTL_TX {
            public:
            constexpr static uint32_t id = 0x75A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class PDU_BTL_RX {
            public:
            constexpr static uint32_t id = 0x79A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'PDU_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_EMCY {
            public:
            constexpr static uint32_t id = 0x8A;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_W0_OtherWarning = signals::HVCU_W0_OtherWarning;
            using HVCU_W1_HighVoltage = signals::HVCU_W1_HighVoltage;
            using HVCU_W2_PreChargeOn = signals::HVCU_W2_PreChargeOn;
            using HVCU_W3_Bir1On = signals::HVCU_W3_Bir1On;
            using HVCU_W4_Bir2On = signals::HVCU_W4_Bir2On;
            using HVCU_W5_Bir3On = signals::HVCU_W5_Bir3On;
            using HVCU_W6_Bir4On = signals::HVCU_W6_Bir4On;
            using HVCU_W7_IsolationResistanceLow = signals::HVCU_W7_IsolationResistanceLow;
            using HVCU_W8_ChargingMode = signals::HVCU_W8_ChargingMode;
            using HVCU_E0_OtherError = signals::HVCU_E0_OtherError;
            using HVCU_E1_IMDError = signals::HVCU_E1_IMDError;
            using HVCU_E2_BMSError = signals::HVCU_E2_BMSError;
            using HVCU_E3_PrechargeError = signals::HVCU_E3_PrechargeError;
            using HVCU_E4_BMSPermissionMissing = signals::HVCU_E4_BMSPermissionMissing;
            using HVCU_E5_DischargeTimeout = signals::HVCU_E5_DischargeTimeout;
            using HVCU_E6_DischargeError = signals::HVCU_E6_DischargeError;
            using HVCU_E7_BALError = signals::HVCU_E7_BALError;
            using HVCU_E8_VoltageMeasuring = signals::HVCU_E8_VoltageMeasuring;
            using HVCU_E9_HVSLError = signals::HVCU_E9_HVSLError;
            using HVCU_E10_BIR1Error = signals::HVCU_E10_BIR1Error;
            using HVCU_E11_BIR2Error = signals::HVCU_E11_BIR2Error;
            using HVCU_E12_BIR3Error = signals::HVCU_E12_BIR3Error;
            using HVCU_E13_BIR4Error = signals::HVCU_E13_BIR4Error;
            using HVCU_E14_HVMPError = signals::HVCU_E14_HVMPError;
            using HVCU_E15_SDCOpen = signals::HVCU_E15_SDCOpen;
            using HVCU_E16_NoEnable = signals::HVCU_E16_NoEnable;
            using HVCU_E17_ControlMessageTimeout = signals::HVCU_E17_ControlMessageTimeout;
            using HVCU_E18_SDCSwitchError = signals::HVCU_E18_SDCSwitchError;
            using HVCU_E19_ChargingModeError = signals::HVCU_E19_ChargingModeError;

            // Attributes of message 'HVCU_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_Status {
            public:
            constexpr static uint32_t id = 0x18A;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_TX_InternalStatus = signals::HVCU_TX_InternalStatus;
            using HVCU_TX_Status_ = signals::HVCU_TX_Status;
            using HVCU_TX_ErrorFlag = signals::HVCU_TX_ErrorFlag;
            using HVCU_TX_Enabled = signals::HVCU_TX_Enabled;

            // Attributes of message 'HVCU_TX_Status'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_RX_Control {
            public:
            constexpr static uint32_t id = 0x1CA;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_RX_Enable = signals::HVCU_RX_Enable;
            using HVCU_RX_Activate = signals::HVCU_RX_Activate;
            using HVCU_RX_ErrorReset = signals::HVCU_RX_ErrorReset;
            using HVCU_RX_Charging = signals::HVCU_RX_Charging;

            // Attributes of message 'HVCU_RX_Control'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x20A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x24A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_IMD {
            public:
            constexpr static uint32_t id = 0x28A;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_IMD_DutyCycle = signals::HVCU_IMD_DutyCycle;
            using HVCU_IMD_Frequency = signals::HVCU_IMD_Frequency;
            using HVCU_IMD_Isolation_Resistance = signals::HVCU_IMD_Isolation_Resistance;

            // Attributes of message 'HVCU_TX_IMD'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2CA;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x30A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x34A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x38A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3CA;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x40A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x44A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x48A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4CA;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x50A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x54A;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x58A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_SDO_ID = signals::HVCU_SDO_ID;
            using HVCU_SDO_RespCode = signals::HVCU_SDO_RespCode;
            using HVCU_OD_CAN2_DelayedTxMessages = signals::HVCU_OD_CAN2_DelayedTxMessages;
            using HVCU_OD_CAN2_ErrorStatus = signals::HVCU_OD_CAN2_ErrorStatus;
            using HVCU_OD_CAN2_DiscardedTxMessages = signals::HVCU_OD_CAN2_DiscardedTxMessages;
            using HVCU_OD_CAN2_Status = signals::HVCU_OD_CAN2_Status;
            using HVCU_OD_CAN2_Baudrate = signals::HVCU_OD_CAN2_Baudrate;
            using HVCU_OD_CAN2_autoErrorReset = signals::HVCU_OD_CAN2_autoErrorReset;
            using HVCU_OD_CAN2_lastErrorCode = signals::HVCU_OD_CAN2_lastErrorCode;
            using HVCU_OD_CAN2_RxErrCnt = signals::HVCU_OD_CAN2_RxErrCnt;
            using HVCU_OD_CAN2_TxErrCnt = signals::HVCU_OD_CAN2_TxErrCnt;
            using HVCU_OD_CAN1_DelayedTxMessages = signals::HVCU_OD_CAN1_DelayedTxMessages;
            using HVCU_OD_CAN1_ErrorStatus = signals::HVCU_OD_CAN1_ErrorStatus;
            using HVCU_OD_CAN1_DiscardedTxMessages = signals::HVCU_OD_CAN1_DiscardedTxMessages;
            using HVCU_OD_CAN1_Status = signals::HVCU_OD_CAN1_Status;
            using HVCU_OD_CAN1_Baudrate = signals::HVCU_OD_CAN1_Baudrate;
            using HVCU_OD_CAN1_autoErrorReset = signals::HVCU_OD_CAN1_autoErrorReset;
            using HVCU_OD_CAN1_lastErrorCode = signals::HVCU_OD_CAN1_lastErrorCode;
            using HVCU_OD_CAN1_RxErrCnt = signals::HVCU_OD_CAN1_RxErrCnt;
            using HVCU_OD_CAN1_TxErrCnt = signals::HVCU_OD_CAN1_TxErrCnt;
            using HVCU_OD_BuildTime = signals::HVCU_OD_BuildTime;
            using HVCU_OD_BuildDate = signals::HVCU_OD_BuildDate;
            using HVCU_OD_ChipUID2 = signals::HVCU_OD_ChipUID2;
            using HVCU_OD_ChipUID1 = signals::HVCU_OD_ChipUID1;
            using HVCU_OD_SdcOut = signals::HVCU_OD_SdcOut;
            using HVCU_OD_SdcIn = signals::HVCU_OD_SdcIn;
            using HVCU_OD_runtime = signals::HVCU_OD_runtime;
            using HVCU_OD_InputVoltage = signals::HVCU_OD_InputVoltage;
            using HVCU_OD_BoardTemp = signals::HVCU_OD_BoardTemp;
            using HVCU_OD_MemFree = signals::HVCU_OD_MemFree;
            using HVCU_OD_CpuUsage = signals::HVCU_OD_CpuUsage;
            using HVCU_OD_OdEntrySendInterval = signals::HVCU_OD_OdEntrySendInterval;
            using HVCU_OD_SendOdOnBootup = signals::HVCU_OD_SendOdOnBootup;
            using HVCU_OD_HeartbeatInterval = signals::HVCU_OD_HeartbeatInterval;
            using HVCU_OD_DbcVersion = signals::HVCU_OD_DbcVersion;
            using HVCU_OD_StackVersion = signals::HVCU_OD_StackVersion;
            using HVCU_OD_ProtocolVersion = signals::HVCU_OD_ProtocolVersion;
            using HVCU_OD_NodeStatus = signals::HVCU_OD_NodeStatus;
            using HVCU_OD_NodeID = signals::HVCU_OD_NodeID;

            // Attributes of message 'HVCU_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5CA;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_SDO_ID = signals::HVCU_SDO_ID;
            using HVCU_OD_CAN2_DelayedTxMessages = signals::HVCU_OD_CAN2_DelayedTxMessages;
            using HVCU_OD_CAN2_ErrorStatus = signals::HVCU_OD_CAN2_ErrorStatus;
            using HVCU_OD_CAN2_DiscardedTxMessages = signals::HVCU_OD_CAN2_DiscardedTxMessages;
            using HVCU_OD_CAN2_Status = signals::HVCU_OD_CAN2_Status;
            using HVCU_OD_CAN2_Baudrate = signals::HVCU_OD_CAN2_Baudrate;
            using HVCU_OD_CAN2_autoErrorReset = signals::HVCU_OD_CAN2_autoErrorReset;
            using HVCU_OD_CAN2_lastErrorCode = signals::HVCU_OD_CAN2_lastErrorCode;
            using HVCU_OD_CAN2_RxErrCnt = signals::HVCU_OD_CAN2_RxErrCnt;
            using HVCU_OD_CAN2_TxErrCnt = signals::HVCU_OD_CAN2_TxErrCnt;
            using HVCU_OD_CAN1_DelayedTxMessages = signals::HVCU_OD_CAN1_DelayedTxMessages;
            using HVCU_OD_CAN1_ErrorStatus = signals::HVCU_OD_CAN1_ErrorStatus;
            using HVCU_OD_CAN1_DiscardedTxMessages = signals::HVCU_OD_CAN1_DiscardedTxMessages;
            using HVCU_OD_CAN1_Status = signals::HVCU_OD_CAN1_Status;
            using HVCU_OD_CAN1_Baudrate = signals::HVCU_OD_CAN1_Baudrate;
            using HVCU_OD_CAN1_autoErrorReset = signals::HVCU_OD_CAN1_autoErrorReset;
            using HVCU_OD_CAN1_lastErrorCode = signals::HVCU_OD_CAN1_lastErrorCode;
            using HVCU_OD_CAN1_RxErrCnt = signals::HVCU_OD_CAN1_RxErrCnt;
            using HVCU_OD_CAN1_TxErrCnt = signals::HVCU_OD_CAN1_TxErrCnt;
            using HVCU_OD_BuildTime = signals::HVCU_OD_BuildTime;
            using HVCU_OD_BuildDate = signals::HVCU_OD_BuildDate;
            using HVCU_OD_ChipUID2 = signals::HVCU_OD_ChipUID2;
            using HVCU_OD_ChipUID1 = signals::HVCU_OD_ChipUID1;
            using HVCU_OD_SdcOut = signals::HVCU_OD_SdcOut;
            using HVCU_OD_SdcIn = signals::HVCU_OD_SdcIn;
            using HVCU_OD_runtime = signals::HVCU_OD_runtime;
            using HVCU_OD_InputVoltage = signals::HVCU_OD_InputVoltage;
            using HVCU_OD_BoardTemp = signals::HVCU_OD_BoardTemp;
            using HVCU_OD_MemFree = signals::HVCU_OD_MemFree;
            using HVCU_OD_CpuUsage = signals::HVCU_OD_CpuUsage;
            using HVCU_OD_OdEntrySendInterval = signals::HVCU_OD_OdEntrySendInterval;
            using HVCU_OD_SendOdOnBootup = signals::HVCU_OD_SendOdOnBootup;
            using HVCU_OD_HeartbeatInterval = signals::HVCU_OD_HeartbeatInterval;
            using HVCU_OD_DbcVersion = signals::HVCU_OD_DbcVersion;
            using HVCU_OD_StackVersion = signals::HVCU_OD_StackVersion;
            using HVCU_OD_ProtocolVersion = signals::HVCU_OD_ProtocolVersion;
            using HVCU_OD_NodeStatus = signals::HVCU_OD_NodeStatus;
            using HVCU_OD_NodeID = signals::HVCU_OD_NodeID;

            // Attributes of message 'HVCU_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x60A;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_SDO_ID = signals::HVCU_SDO_ID;

            // Attributes of message 'HVCU_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_Heartbeat {
            public:
            constexpr static uint32_t id = 0x70A;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVCU_NodeState = signals::HVCU_NodeState;

            // Attributes of message 'HVCU_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_BTL_TX {
            public:
            constexpr static uint32_t id = 0x74A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVCU_BTL_RX {
            public:
            constexpr static uint32_t id = 0x78A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVCU_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_EMCY {
            public:
            constexpr static uint32_t id = 0x99;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_W0_OtherWarning = signals::HVTU_W0_OtherWarning;
            using HVTU_E0_OtherError = signals::HVTU_E0_OtherError;

            // Attributes of message 'HVTU_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_01 {
            public:
            constexpr static uint32_t id = 0x1FFF0000;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_01'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_02 {
            public:
            constexpr static uint32_t id = 0x1FFF0001;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_02'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_03 {
            public:
            constexpr static uint32_t id = 0x1FFF0002;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_03'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_04 {
            public:
            constexpr static uint32_t id = 0x1FFF0003;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_04'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_05 {
            public:
            constexpr static uint32_t id = 0x1FFF0004;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_05'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_06 {
            public:
            constexpr static uint32_t id = 0x1FFF0005;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_06'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_07 {
            public:
            constexpr static uint32_t id = 0x1FFF0006;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_07'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_08 {
            public:
            constexpr static uint32_t id = 0x1FFF0007;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_08'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_09 {
            public:
            constexpr static uint32_t id = 0x1FFF0008;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_09'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_10 {
            public:
            constexpr static uint32_t id = 0x1FFF0009;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_11 {
            public:
            constexpr static uint32_t id = 0x1FFF000A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_12 {
            public:
            constexpr static uint32_t id = 0x1FFF000B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_13 {
            public:
            constexpr static uint32_t id = 0x1FFF000C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_13'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_14 {
            public:
            constexpr static uint32_t id = 0x1FFF000D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_14'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_15 {
            public:
            constexpr static uint32_t id = 0x1FFF000E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_15'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_16 {
            public:
            constexpr static uint32_t id = 0x1FFF000F;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_16'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_17 {
            public:
            constexpr static uint32_t id = 0x1FFF0010;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_17'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_18 {
            public:
            constexpr static uint32_t id = 0x1FFF0011;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_18'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_19 {
            public:
            constexpr static uint32_t id = 0x1FFF0012;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_19'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_20 {
            public:
            constexpr static uint32_t id = 0x1FFF0013;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_20'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_21 {
            public:
            constexpr static uint32_t id = 0x1FFF0014;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_21'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_22 {
            public:
            constexpr static uint32_t id = 0x1FFF0015;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_22'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_23 {
            public:
            constexpr static uint32_t id = 0x1FFF0016;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_23'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_24 {
            public:
            constexpr static uint32_t id = 0x1FFF0017;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_24'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_25 {
            public:
            constexpr static uint32_t id = 0x1FFF0018;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_25'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_26 {
            public:
            constexpr static uint32_t id = 0x1FFF0019;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_26'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_27 {
            public:
            constexpr static uint32_t id = 0x1FFF001A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_27'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_28 {
            public:
            constexpr static uint32_t id = 0x1FFF001B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_28'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_29 {
            public:
            constexpr static uint32_t id = 0x1FFF001C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_29'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_30 {
            public:
            constexpr static uint32_t id = 0x1FFF001D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_30'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_31 {
            public:
            constexpr static uint32_t id = 0x1FFF001E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_31'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_32 {
            public:
            constexpr static uint32_t id = 0x1FFF001F;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_32'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_33 {
            public:
            constexpr static uint32_t id = 0x1FFF0020;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_33'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_34 {
            public:
            constexpr static uint32_t id = 0x1FFF0021;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_34'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_35 {
            public:
            constexpr static uint32_t id = 0x1FFF0022;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_35'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_36 {
            public:
            constexpr static uint32_t id = 0x1FFF0023;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_36'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_37 {
            public:
            constexpr static uint32_t id = 0x1FFF0024;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_37'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_38 {
            public:
            constexpr static uint32_t id = 0x1FFF0025;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_38'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_39 {
            public:
            constexpr static uint32_t id = 0x1FFF0026;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_39'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_40 {
            public:
            constexpr static uint32_t id = 0x1FFF0027;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_40'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_41 {
            public:
            constexpr static uint32_t id = 0x1FFF0028;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_41'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_42 {
            public:
            constexpr static uint32_t id = 0x1FFF0029;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_42'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_43 {
            public:
            constexpr static uint32_t id = 0x1FFF002A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_43'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_44 {
            public:
            constexpr static uint32_t id = 0x1FFF002B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_44'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_45 {
            public:
            constexpr static uint32_t id = 0x1FFF002C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_45'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_46 {
            public:
            constexpr static uint32_t id = 0x1FFF002D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_46'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_47 {
            public:
            constexpr static uint32_t id = 0x1FFF002E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_47'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Internal_48 {
            public:
            constexpr static uint32_t id = 0x1FFF002F;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Attributes of message 'EMUS_Internal_48'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Electric_MZ_V_FAST {
            public:
            constexpr static uint32_t id = 0x5E5;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_V_SET_U_MOT2 = signals::SCIMO_V_SET_U_MOT2;
            using SCIMO_V_SET_V_MOT2 = signals::SCIMO_V_SET_V_MOT2;
            using SCIMO_V_SET_W_MOT2 = signals::SCIMO_V_SET_W_MOT2;

            // Attributes of message 'SCIMO_PE_TX_Electric_MZ_V_FAST'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Electric_MZ_I_FAST {
            public:
            constexpr static uint32_t id = 0x5E4;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_I_MES_U_MOT2 = signals::SCIMO_I_MES_U_MOT2;
            using SCIMO_I_MES_V_MOT2 = signals::SCIMO_I_MES_V_MOT2;
            using SCIMO_I_MES_W_MOT2 = signals::SCIMO_I_MES_W_MOT2;

            // Attributes of message 'SCIMO_PE_TX_Electric_MZ_I_FAST'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_AmbientTemp_MOT2 {
            public:
            constexpr static uint32_t id = 0x5D0;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_Temp_RotorAmbient_MOT2 = signals::SCIMO_Temp_RotorAmbient_MOT2;
            using SCIMO_Temp_ADS_Ambient_MOT2 = signals::SCIMO_Temp_ADS_Ambient_MOT2;
            using SCIMO_Temp_ThermocoupleK_MOT2 = signals::SCIMO_Temp_ThermocoupleK_MOT2;
            using SCIMO_Temp_ThermocoupleJ_MOT2 = signals::SCIMO_Temp_ThermocoupleJ_MOT2;

            // Attributes of message 'SCIMO_PE_TX_AmbientTemp_MOT2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_AmbientTemp_MOT1 {
            public:
            constexpr static uint32_t id = 0x5C0;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_Temp_RotorAmbient_MOT1 = signals::SCIMO_Temp_RotorAmbient_MOT1;
            using SCIMO_Temp_ADS_Ambient_MOT1 = signals::SCIMO_Temp_ADS_Ambient_MOT1;
            using SCIMO_Temp_ThermocoupleK_MOT1 = signals::SCIMO_Temp_ThermocoupleK_MOT1;
            using SCIMO_Temp_ThermocoupleJ_MOT1 = signals::SCIMO_Temp_ThermocoupleJ_MOT1;

            // Attributes of message 'SCIMO_PE_TX_AmbientTemp_MOT1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_MS_RX_RequestData {
            public:
            constexpr static uint32_t id = 0x5B0;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_NumOfSamples = signals::SCIMO_NumOfSamples;

            // Attributes of message 'SCIMO_MS_RX_RequestData'
            constexpr static GenMsgSendType_t GenMsgSendType = GenMsgSendType_t::CYCLIC;
            constexpr static uint16_t GenMsgCycleTime = 10;
        };
        class SCIMO_MS_TX_Electric {
            public:
            constexpr static uint32_t id = 0x5A0;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_I_D_MOT = signals::SCIMO_I_D_MOT;
            using SCIMO_I_Q_MOT = signals::SCIMO_I_Q_MOT;
            using SCIMO_U_D_MOT = signals::SCIMO_U_D_MOT;
            using SCIMO_U_Q_MOT = signals::SCIMO_U_Q_MOT;

            // Attributes of message 'SCIMO_MS_TX_Electric'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_MotorTemp_MOT2 {
            public:
            constexpr static uint32_t id = 0x540;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_Temp_Rotor_MOT2 = signals::SCIMO_Temp_Rotor_MOT2;
            using SCIMO_Temp_PT100A_MOT2 = signals::SCIMO_Temp_PT100A_MOT2;
            using SCIMO_Temp_PT100B_MOT2 = signals::SCIMO_Temp_PT100B_MOT2;

            // Attributes of message 'SCIMO_PE_TX_MotorTemp_MOT2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_MotorTemp_MOT1 {
            public:
            constexpr static uint32_t id = 0x530;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_Temp_Rotor_MOT1 = signals::SCIMO_Temp_Rotor_MOT1;
            using SCIMO_Temp_PT100A_MOT1 = signals::SCIMO_Temp_PT100A_MOT1;
            using SCIMO_Temp_PT100B_MOT1 = signals::SCIMO_Temp_PT100B_MOT1;

            // Attributes of message 'SCIMO_PE_TX_MotorTemp_MOT1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Status {
            public:
            constexpr static uint32_t id = 0x5F0;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_tempPCB = signals::SCIMO_tempPCB;
            using SCIMO_tempAUX1 = signals::SCIMO_tempAUX1;
            using SCIMO_tempAUX2 = signals::SCIMO_tempAUX2;
            using SCIMO_I_LV = signals::SCIMO_I_LV;
            using SCIMO_VCC_LV = signals::SCIMO_VCC_LV;
            using SCIMO_tempCPU = signals::SCIMO_tempCPU;

            // Attributes of message 'SCIMO_PE_TX_Status'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Slow_Status_MOT2 {
            public:
            constexpr static uint32_t id = 0x580;
            constexpr static uint8_t dlc = 7;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_T_FET_MOT2 = signals::SCIMO_T_FET_MOT2;
            using SCIMO_FSM_State_MOT2 = signals::SCIMO_FSM_State_MOT2;
            using SCIMO_ctrlMode_MOT2 = signals::SCIMO_ctrlMode_MOT2;
            using SCIMO_enable_MOT2 = signals::SCIMO_enable_MOT2;
            using SCIMO_extPulsEnable_MOT2 = signals::SCIMO_extPulsEnable_MOT2;
            using SCIMO_pulsEnable_MOT2 = signals::SCIMO_pulsEnable_MOT2;
            using SCIMO_uZK_MOT2 = signals::SCIMO_uZK_MOT2;
            using SCIMO_temp_MOT2 = signals::SCIMO_temp_MOT2;
            using SCIMO_temp_MOT1_ = signals::SCIMO_temp_MOT1_;

            // Attributes of message 'SCIMO_PE_TX_Slow_Status_MOT2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Slow_Status_MOT1 {
            public:
            constexpr static uint32_t id = 0x570;
            constexpr static uint8_t dlc = 7;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_T_FET_MOT1 = signals::SCIMO_T_FET_MOT1;
            using SCIMO_FSM_State_MOT1 = signals::SCIMO_FSM_State_MOT1;
            using SCIMO_ctrlMode_MOT1 = signals::SCIMO_ctrlMode_MOT1;
            using SCIMO_enable_MOT1 = signals::SCIMO_enable_MOT1;
            using SCIMO_extPulsEnable_MOT1 = signals::SCIMO_extPulsEnable_MOT1;
            using SCIMO_pulsEnable_MOT1 = signals::SCIMO_pulsEnable_MOT1;
            using SCIMO_uZK_MOT1 = signals::SCIMO_uZK_MOT1;
            using SCIMO_temp_MOT1 = signals::SCIMO_temp_MOT1;
            using SCIMO_I_AUX_MOT1 = signals::SCIMO_I_AUX_MOT1;

            // Attributes of message 'SCIMO_PE_TX_Slow_Status_MOT1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Electric {
            public:
            constexpr static uint32_t id = 0x5E0;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using I_D_MOT1 = signals::I_D_MOT1;
            using I_Q_MOT1 = signals::I_Q_MOT1;
            using I_D_MOT2 = signals::I_D_MOT2;
            using I_Q_MOT2 = signals::I_Q_MOT2;

            // Attributes of message 'SCIMO_PE_TX_Electric'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_MZ_Electric {
            public:
            constexpr static uint32_t id = 0x5E6;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_I_REQ_LOWPASS_MOT2 = signals::SCIMO_I_REQ_LOWPASS_MOT2;
            using SCIMO_f_REQ_LOWPASS_MOT2 = signals::SCIMO_f_REQ_LOWPASS_MOT2;
            using SCIMO_I_D_MOT2 = signals::SCIMO_I_D_MOT2;
            using SCIMO_I_Q_MOT2 = signals::SCIMO_I_Q_MOT2;

            // Attributes of message 'SCIMO_PE_TX_MZ_Electric'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Errors {
            public:
            constexpr static uint32_t id = 0x520;
            constexpr static uint8_t dlc = 5;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_errNum_MOT1 = signals::SCIMO_errNum_MOT1;
            using SCIMO_errNum_MOT2 = signals::SCIMO_errNum_MOT2;
            using SCIMO_warnNum_MOT1 = signals::SCIMO_warnNum_MOT1;
            using SCIMO_warnNum_MOT2 = signals::SCIMO_warnNum_MOT2;

            // Attributes of message 'SCIMO_PE_TX_Errors'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_TX_Mech_fast {
            public:
            constexpr static uint32_t id = 0x550;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_n_gw_MOT1 = signals::SCIMO_n_gw_MOT1;
            using SCIMO_M_ist_gw_MOT1 = signals::SCIMO_M_ist_gw_MOT1;
            using SCIMO_n_gw_MOT2 = signals::SCIMO_n_gw_MOT2;
            using SCIMO_M_ist_gw_MOT2 = signals::SCIMO_M_ist_gw_MOT2;

            // Attributes of message 'SCIMO_PE_TX_Mech_fast'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_RX_MZ_Ctrl_MOT2 {
            public:
            constexpr static uint32_t id = 0x513;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_MOT2_ctrlMode_mz = signals::SCIMO_MOT2_ctrlMode_mz;
            using SCIMO_MOT2_f_dir = signals::SCIMO_MOT2_f_dir;
            using SCIMO_MOT2_freqSp = signals::SCIMO_MOT2_freqSp;
            using SCIMO_MOT2_VISp = signals::SCIMO_MOT2_VISp;
            using SCIMO_MOT2_A1 = signals::SCIMO_MOT2_A1;
            using SCIMO_MOT2_A2 = signals::SCIMO_MOT2_A2;
            using SCIMO_MOT2_A3 = signals::SCIMO_MOT2_A3;

            // Attributes of message 'SCIMO_PE_RX_MZ_Ctrl_MOT2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class SCIMO_PE_RX_Ctrl_MOT1 {
            public:
            constexpr static uint32_t id = 0x500;
            constexpr static uint8_t dlc = 5;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_MOT1_enable = signals::SCIMO_MOT1_enable;
            using SCIMO_MOT1_ctrlMode = signals::SCIMO_MOT1_ctrlMode;
            using SCIMO_MOT1_reset = signals::SCIMO_MOT1_reset;
            using SCIMO_MOT1_targetSp = signals::SCIMO_MOT1_targetSp;
            using SCIMO_MOT1_limitSp = signals::SCIMO_MOT1_limitSp;

            // Attributes of message 'SCIMO_PE_RX_Ctrl_MOT1'
            constexpr static GenMsgSendType_t GenMsgSendType = GenMsgSendType_t::CYCLIC;
            constexpr static uint16_t GenMsgCycleTime = 10;
        };
        class SCIMO_PE_RX_Ctrl_MOT2 {
            public:
            constexpr static uint32_t id = 0x510;
            constexpr static uint8_t dlc = 5;
            constexpr static bool isExtendedId = false;

            // Signals
            using SCIMO_MOT2_enable = signals::SCIMO_MOT2_enable;
            using SCIMO_MOT2_ctrlMode = signals::SCIMO_MOT2_ctrlMode;
            using SCIMO_MOT2_reset = signals::SCIMO_MOT2_reset;
            using SCIMO_MOT2_targetSp = signals::SCIMO_MOT2_targetSp;
            using SCIMO_MOT2_limitSp = signals::SCIMO_MOT2_limitSp;

            // Attributes of message 'SCIMO_PE_RX_Ctrl_MOT2'
            constexpr static uint16_t GenMsgCycleTime = 10;
            constexpr static GenMsgSendType_t GenMsgSendType = GenMsgSendType_t::CYCLIC;
        };
        class EMUS_Battery_Volt_Overall_Param_ {
            public:
            constexpr static uint32_t id = 0x19B50001;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_VoltOverallParam_MinCellVol = signals::EMUS_VoltOverallParam_MinCellVol;
            using EMUS_VoltOverallParam_MaxCellVol = signals::EMUS_VoltOverallParam_MaxCellVol;
            using EMUS_VoltOverallParam_AvrgCellVo = signals::EMUS_VoltOverallParam_AvrgCellVo;
            using EMUS_VoltOverallParams_TVoltSecB = signals::EMUS_VoltOverallParams_TVoltSecB;
            using EMUS_VoltOverallParams_TVoltLSB = signals::EMUS_VoltOverallParams_TVoltLSB;
            using EMUS_VoltOverallParams_TVoltMSB = signals::EMUS_VoltOverallParams_TVoltMSB;
            using EMUS_VoltOverallParams_TVoltThir = signals::EMUS_VoltOverallParams_TVoltThir;

            // Attributes of message 'EMUS_Battery_Volt_Overall_Param_'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Overall_Parameters_Ext {
            public:
            constexpr static uint32_t id = 0x19B50000;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_OverallParams_IgnitionKey = signals::EMUS_OverallParams_IgnitionKey;
            using EMUS_OverallParams_ChargerMains = signals::EMUS_OverallParams_ChargerMains;
            using EMUS_OverallParams_FastCharge = signals::EMUS_OverallParams_FastCharge;
            using EMUS_OverallParams_LeakageSensor = signals::EMUS_OverallParams_LeakageSensor;
            using EMUS_OverallParams_ChargerEnable = signals::EMUS_OverallParams_ChargerEnable;
            using EMUS_OverallParams_HeaterEnable = signals::EMUS_OverallParams_HeaterEnable;
            using EMUS_OverallParams_BatteryContac = signals::EMUS_OverallParams_BatteryContac;
            using EMUS_OverallParams_BatteryFan = signals::EMUS_OverallParams_BatteryFan;
            using EMUS_OverallParams_PowerReductio = signals::EMUS_OverallParams_PowerReductio;
            using EMUS_OverallParams_ChargingInter = signals::EMUS_OverallParams_ChargingInter;
            using EMUS_OverallParams_DCDC_Control = signals::EMUS_OverallParams_DCDC_Control;
            using EMUS_OverallParams_ContactorPreC = signals::EMUS_OverallParams_ContactorPreC;
            using EMUS_OverallParams_NumberOfCells = signals::EMUS_OverallParams_NumberOfCells;
            using EMUS_OverallParams_ChargingStage = signals::EMUS_OverallParams_ChargingStage;
            using EMUS_OverallParams_ChrgStageDura = signals::EMUS_OverallParams_ChrgStageDura;
            using EMUS_OverallParams_ChrgStag_0000 = signals::EMUS_OverallParams_ChrgStag_0000;
            using EMUS_OverallParams_LastChargingE = signals::EMUS_OverallParams_LastChargingE;
            using EMUS_OverallParams_NumberOf_0000 = signals::EMUS_OverallParams_NumberOf_0000;

            // Attributes of message 'EMUS_Overall_Parameters_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Diagnostic_Codes_Ext {
            public:
            constexpr static uint32_t id = 0x19B50007;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_DiagnosticCodes_UnderVoltag = signals::EMUS_DiagnosticCodes_UnderVoltag;
            using EMUS_DiagnosticCodes_OverVoltage = signals::EMUS_DiagnosticCodes_OverVoltage;
            using EMUS_DiagnosticCodes_DchrgOvrCur = signals::EMUS_DiagnosticCodes_DchrgOvrCur;
            using EMUS_DiagnosticCodes_ChrgOverCur = signals::EMUS_DiagnosticCodes_ChrgOverCur;
            using EMUS_DiagnosticCodes_CellModOver = signals::EMUS_DiagnosticCodes_CellModOver;
            using EMUS_DiagnosticCodes_Leakage = signals::EMUS_DiagnosticCodes_Leakage;
            using EMUS_DiagnosticCodes_NoCellComm = signals::EMUS_DiagnosticCodes_NoCellComm;
            using EMUS_DiagnosticCodes_LowVoltage = signals::EMUS_DiagnosticCodes_LowVoltage;
            using EMUS_DiagnosticCodes_HighCurrent = signals::EMUS_DiagnosticCodes_HighCurrent;
            using EMUS_DiagnosticCodes_HighTempera = signals::EMUS_DiagnosticCodes_HighTempera;
            using EMUS_DiagnosticCodes_CellOverHea = signals::EMUS_DiagnosticCodes_CellOverHea;
            using EMUS_DiagnosticCodes_NoCurrentSe = signals::EMUS_DiagnosticCodes_NoCurrentSe;
            using EMUS_DiagnosticCodes_PackUnderVo = signals::EMUS_DiagnosticCodes_PackUnderVo;
            using EMUS_DiagnosticCodes_CellVoltVal = signals::EMUS_DiagnosticCodes_CellVoltVal;
            using EMUS_DiagnosticCodes_CellModTemp = signals::EMUS_DiagnosticCodes_CellModTemp;
            using EMUS_DiagnosticCodes_CellBalancV = signals::EMUS_DiagnosticCodes_CellBalancV;
            using EMUS_DiagnosticCodes_NumOfCellsV = signals::EMUS_DiagnosticCodes_NumOfCellsV;
            using EMUS_DiagnosticCodes_BatChrgFini = signals::EMUS_DiagnosticCodes_BatChrgFini;
            using EMUS_DiagnosticCodes_CellTempVal = signals::EMUS_DiagnosticCodes_CellTempVal;

            // Attributes of message 'EMUS_Diagnostic_Codes_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Cell_Mod_Temp_Overall_Param {
            public:
            constexpr static uint32_t id = 0x19B50002;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_CellModOverallPar_MinCellMo = signals::EMUS_CellModOverallPar_MinCellMo;
            using EMUS_CellModOverallPar_MaxCellMo = signals::EMUS_CellModOverallPar_MaxCellMo;
            using EMUS_CellModOverallPar_AvgCellMo = signals::EMUS_CellModOverallPar_AvgCellMo;

            // Attributes of message 'EMUS_Cell_Mod_Temp_Overall_Param'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Cell_Temp_Overall_Params_Ex {
            public:
            constexpr static uint32_t id = 0x19B50008;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_CellOverallPar_MinCellTemp = signals::EMUS_CellOverallPar_MinCellTemp;
            using EMUS_CellOverallPar_MaxCellTemp = signals::EMUS_CellOverallPar_MaxCellTemp;
            using EMUS_CellOverallPar_AvgCellTemp = signals::EMUS_CellOverallPar_AvgCellTemp;

            // Attributes of message 'EMUS_Cell_Temp_Overall_Params_Ex'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Cell_Balanc_Rate_Overall_Pa {
            public:
            constexpr static uint32_t id = 0x19B50003;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_CellBalancPar_MinCellBalanc = signals::EMUS_CellBalancPar_MinCellBalanc;
            using EMUS_CellBalancPar_MaxCellBalanc = signals::EMUS_CellBalancPar_MaxCellBalanc;
            using EMUS_CellBalancPar_AvgCellBalanc = signals::EMUS_CellBalancPar_AvgCellBalanc;

            // Attributes of message 'EMUS_Cell_Balanc_Rate_Overall_Pa'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Configuration_Parameters_Ex {
            public:
            constexpr static uint32_t id = 0x19B50400;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_ConfigParams_ParameterID_MS = signals::EMUS_ConfigParams_ParameterID_MS;
            using EMUS_ConfigParams_ParameterID_LS = signals::EMUS_ConfigParams_ParameterID_LS;
            using EMUS_ConfigParams_ParameterSize = signals::EMUS_ConfigParams_ParameterSize;
            using EMUS_ConfigParams_ParameterData_ = signals::EMUS_ConfigParams_ParameterData_;
            using EMUS_ConfigParams_ParamData_Thir = signals::EMUS_ConfigParams_ParamData_Thir;
            using EMUS_ConfigParams_ParamData_SecB = signals::EMUS_ConfigParams_ParamData_SecB;
            using EMUS_ConfigParams_Parameter_0000 = signals::EMUS_ConfigParams_Parameter_0000;

            // Attributes of message 'EMUS_Configuration_Parameters_Ex'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Login_Level_Ext {
            public:
            constexpr static uint32_t id = 0x19B50402;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_LoginLevel = signals::EMUS_LoginLevel;

            // Attributes of message 'EMUS_Login_Level_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Contactor_Control_Ext {
            public:
            constexpr static uint32_t id = 0x19B50401;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_ContactorControl_ContactorState = signals::EMUS_ContactorControl_ContactorState;

            // Attributes of message 'EMUS_Contactor_Control_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Energy_Parameters_Ext {
            public:
            constexpr static uint32_t id = 0x19B50600;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Energy_EstimatedConsumption = signals::EMUS_Energy_EstimatedConsumption;
            using EMUS_Energy_EstimatedConsum_0000 = signals::EMUS_Energy_EstimatedConsum_0000;
            using EMUS_Energy_EstimatedEnergy_MSB = signals::EMUS_Energy_EstimatedEnergy_MSB;
            using EMUS_Energy_EstimatedEnergy_LSB = signals::EMUS_Energy_EstimatedEnergy_LSB;
            using EMUS_Energy_EstimatedDistanceLef = signals::EMUS_Energy_EstimatedDistanceLef;
            using EMUS_Energy_EstimatedDistan_0000 = signals::EMUS_Energy_EstimatedDistan_0000;
            using EMUS_Energy_DistanceTraveled_MSB = signals::EMUS_Energy_DistanceTraveled_MSB;
            using EMUS_Energy_DistanceTraveled_LSB = signals::EMUS_Energy_DistanceTraveled_LSB;

            // Attributes of message 'EMUS_Energy_Parameters_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_State_Of_Charge_Param_Ext {
            public:
            constexpr static uint32_t id = 0x19B50500;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_SOCParams_Current_MSB = signals::EMUS_SOCParams_Current_MSB;
            using EMUS_SOCParams_Current_LSB = signals::EMUS_SOCParams_Current_LSB;
            using EMUS_SOCParams_EstimatedCharge_M = signals::EMUS_SOCParams_EstimatedCharge_M;
            using EMUS_SOCParams_EstimatedCharge_L = signals::EMUS_SOCParams_EstimatedCharge_L;
            using EMUS_SOCParams_EstimatedSOC = signals::EMUS_SOCParams_EstimatedSOC;

            // Attributes of message 'EMUS_State_Of_Charge_Param_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Statistics_Ext {
            public:
            constexpr static uint32_t id = 0x19B50404;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Statistics_Identifier = signals::EMUS_Statistics_Identifier;
            using EMUS_Statistics_DataType = signals::EMUS_Statistics_DataType;
            using EMUS_Statistics_Data_MSB = signals::EMUS_Statistics_Data_MSB;
            using EMUS_Statistics_Data_ThirdByte = signals::EMUS_Statistics_Data_ThirdByte;
            using EMUS_Statistics_Data_SecondByte = signals::EMUS_Statistics_Data_SecondByte;
            using EMUS_Statistics_Data_LSB = signals::EMUS_Statistics_Data_LSB;

            // Attributes of message 'EMUS_Statistics_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Events_Ext {
            public:
            constexpr static uint32_t id = 0x19B50405;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Events_EntryNumber = signals::EMUS_Events_EntryNumber;
            using EMUS_Events_DataType = signals::EMUS_Events_DataType;
            using EMUS_Events_Data_MSB = signals::EMUS_Events_Data_MSB;
            using EMUS_Events_Data_ThirdByte = signals::EMUS_Events_Data_ThirdByte;
            using EMUS_Events_Data_SecondByte = signals::EMUS_Events_Data_SecondByte;
            using EMUS_Events_Data_LSB = signals::EMUS_Events_Data_LSB;

            // Attributes of message 'EMUS_Events_Ext'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Voltages_E {
            public:
            constexpr static uint32_t id = 0x19B50100;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage_Data_ = signals::EMUS_IndividualCellVoltage_Data_;
            using EMUS_IndividualCellVoltage__0000 = signals::EMUS_IndividualCellVoltage__0000;
            using EMUS_IndividualCellVoltage__0001 = signals::EMUS_IndividualCellVoltage__0001;
            using EMUS_IndividualCellVoltage__0002 = signals::EMUS_IndividualCellVoltage__0002;
            using EMUS_IndividualCellVoltage__0003 = signals::EMUS_IndividualCellVoltage__0003;
            using EMUS_IndividualCellVoltage__0004 = signals::EMUS_IndividualCellVoltage__0004;
            using EMUS_IndividualCellVoltage__0005 = signals::EMUS_IndividualCellVoltage__0005;
            using EMUS_IndividualCellVoltage__0006 = signals::EMUS_IndividualCellVoltage__0006;

            // Attributes of message 'EMUS_Individual_Cells_Voltages_E'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0000 {
            public:
            constexpr static uint32_t id = 0x19B50101;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0007 = signals::EMUS_IndividualCellVoltage__0007;
            using EMUS_IndividualCellVoltage__0008 = signals::EMUS_IndividualCellVoltage__0008;
            using EMUS_IndividualCellVoltage__0009 = signals::EMUS_IndividualCellVoltage__0009;
            using EMUS_IndividualCellVoltage__0010 = signals::EMUS_IndividualCellVoltage__0010;
            using EMUS_IndividualCellVoltage__0011 = signals::EMUS_IndividualCellVoltage__0011;
            using EMUS_IndividualCellVoltage__0012 = signals::EMUS_IndividualCellVoltage__0012;
            using EMUS_IndividualCellVoltage__0013 = signals::EMUS_IndividualCellVoltage__0013;
            using EMUS_IndividualCellVoltage__0014 = signals::EMUS_IndividualCellVoltage__0014;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0000'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0001 {
            public:
            constexpr static uint32_t id = 0x19B50102;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0015 = signals::EMUS_IndividualCellVoltage__0015;
            using EMUS_IndividualCellVoltage__0016 = signals::EMUS_IndividualCellVoltage__0016;
            using EMUS_IndividualCellVoltage__0017 = signals::EMUS_IndividualCellVoltage__0017;
            using EMUS_IndividualCellVoltage__0018 = signals::EMUS_IndividualCellVoltage__0018;
            using EMUS_IndividualCellVoltage__0019 = signals::EMUS_IndividualCellVoltage__0019;
            using EMUS_IndividualCellVoltage__0020 = signals::EMUS_IndividualCellVoltage__0020;
            using EMUS_IndividualCellVoltage__0021 = signals::EMUS_IndividualCellVoltage__0021;
            using EMUS_IndividualCellVoltage__0022 = signals::EMUS_IndividualCellVoltage__0022;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0001'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0002 {
            public:
            constexpr static uint32_t id = 0x19B50103;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0023 = signals::EMUS_IndividualCellVoltage__0023;
            using EMUS_IndividualCellVoltage__0024 = signals::EMUS_IndividualCellVoltage__0024;
            using EMUS_IndividualCellVoltage__0025 = signals::EMUS_IndividualCellVoltage__0025;
            using EMUS_IndividualCellVoltage__0026 = signals::EMUS_IndividualCellVoltage__0026;
            using EMUS_IndividualCellVoltage__0027 = signals::EMUS_IndividualCellVoltage__0027;
            using EMUS_IndividualCellVoltage__0028 = signals::EMUS_IndividualCellVoltage__0028;
            using EMUS_IndividualCellVoltage__0029 = signals::EMUS_IndividualCellVoltage__0029;
            using EMUS_IndividualCellVoltage__0030 = signals::EMUS_IndividualCellVoltage__0030;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0002'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0003 {
            public:
            constexpr static uint32_t id = 0x19B50104;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0031 = signals::EMUS_IndividualCellVoltage__0031;
            using EMUS_IndividualCellVoltage__0032 = signals::EMUS_IndividualCellVoltage__0032;
            using EMUS_IndividualCellVoltage__0033 = signals::EMUS_IndividualCellVoltage__0033;
            using EMUS_IndividualCellVoltage__0034 = signals::EMUS_IndividualCellVoltage__0034;
            using EMUS_IndividualCellVoltage__0035 = signals::EMUS_IndividualCellVoltage__0035;
            using EMUS_IndividualCellVoltage__0036 = signals::EMUS_IndividualCellVoltage__0036;
            using EMUS_IndividualCellVoltage__0037 = signals::EMUS_IndividualCellVoltage__0037;
            using EMUS_IndividualCellVoltage__0038 = signals::EMUS_IndividualCellVoltage__0038;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0003'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0004 {
            public:
            constexpr static uint32_t id = 0x19B50105;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0039 = signals::EMUS_IndividualCellVoltage__0039;
            using EMUS_IndividualCellVoltage__0040 = signals::EMUS_IndividualCellVoltage__0040;
            using EMUS_IndividualCellVoltage__0041 = signals::EMUS_IndividualCellVoltage__0041;
            using EMUS_IndividualCellVoltage__0042 = signals::EMUS_IndividualCellVoltage__0042;
            using EMUS_IndividualCellVoltage__0043 = signals::EMUS_IndividualCellVoltage__0043;
            using EMUS_IndividualCellVoltage__0044 = signals::EMUS_IndividualCellVoltage__0044;
            using EMUS_IndividualCellVoltage__0045 = signals::EMUS_IndividualCellVoltage__0045;
            using EMUS_IndividualCellVoltage__0046 = signals::EMUS_IndividualCellVoltage__0046;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0004'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0005 {
            public:
            constexpr static uint32_t id = 0x19B50106;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0047 = signals::EMUS_IndividualCellVoltage__0047;
            using EMUS_IndividualCellVoltage__0048 = signals::EMUS_IndividualCellVoltage__0048;
            using EMUS_IndividualCellVoltage__0049 = signals::EMUS_IndividualCellVoltage__0049;
            using EMUS_IndividualCellVoltage__0050 = signals::EMUS_IndividualCellVoltage__0050;
            using EMUS_IndividualCellVoltage__0051 = signals::EMUS_IndividualCellVoltage__0051;
            using EMUS_IndividualCellVoltage__0052 = signals::EMUS_IndividualCellVoltage__0052;
            using EMUS_IndividualCellVoltage__0053 = signals::EMUS_IndividualCellVoltage__0053;
            using EMUS_IndividualCellVoltage__0054 = signals::EMUS_IndividualCellVoltage__0054;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0005'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0006 {
            public:
            constexpr static uint32_t id = 0x19B50107;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0055 = signals::EMUS_IndividualCellVoltage__0055;
            using EMUS_IndividualCellVoltage__0056 = signals::EMUS_IndividualCellVoltage__0056;
            using EMUS_IndividualCellVoltage__0057 = signals::EMUS_IndividualCellVoltage__0057;
            using EMUS_IndividualCellVoltage__0058 = signals::EMUS_IndividualCellVoltage__0058;
            using EMUS_IndividualCellVoltage__0059 = signals::EMUS_IndividualCellVoltage__0059;
            using EMUS_IndividualCellVoltage__0060 = signals::EMUS_IndividualCellVoltage__0060;
            using EMUS_IndividualCellVoltage__0061 = signals::EMUS_IndividualCellVoltage__0061;
            using EMUS_IndividualCellVoltage__0062 = signals::EMUS_IndividualCellVoltage__0062;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0006'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0007 {
            public:
            constexpr static uint32_t id = 0x19B50108;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0063 = signals::EMUS_IndividualCellVoltage__0063;
            using EMUS_IndividualCellVoltage__0064 = signals::EMUS_IndividualCellVoltage__0064;
            using EMUS_IndividualCellVoltage__0065 = signals::EMUS_IndividualCellVoltage__0065;
            using EMUS_IndividualCellVoltage__0066 = signals::EMUS_IndividualCellVoltage__0066;
            using EMUS_IndividualCellVoltage__0067 = signals::EMUS_IndividualCellVoltage__0067;
            using EMUS_IndividualCellVoltage__0068 = signals::EMUS_IndividualCellVoltage__0068;
            using EMUS_IndividualCellVoltage__0069 = signals::EMUS_IndividualCellVoltage__0069;
            using EMUS_IndividualCellVoltage__0070 = signals::EMUS_IndividualCellVoltage__0070;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0007'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0008 {
            public:
            constexpr static uint32_t id = 0x19B50109;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0071 = signals::EMUS_IndividualCellVoltage__0071;
            using EMUS_IndividualCellVoltage__0072 = signals::EMUS_IndividualCellVoltage__0072;
            using EMUS_IndividualCellVoltage__0073 = signals::EMUS_IndividualCellVoltage__0073;
            using EMUS_IndividualCellVoltage__0074 = signals::EMUS_IndividualCellVoltage__0074;
            using EMUS_IndividualCellVoltage__0075 = signals::EMUS_IndividualCellVoltage__0075;
            using EMUS_IndividualCellVoltage__0076 = signals::EMUS_IndividualCellVoltage__0076;
            using EMUS_IndividualCellVoltage__0077 = signals::EMUS_IndividualCellVoltage__0077;
            using EMUS_IndividualCellVoltage__0078 = signals::EMUS_IndividualCellVoltage__0078;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0008'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0009 {
            public:
            constexpr static uint32_t id = 0x19B5010A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0079 = signals::EMUS_IndividualCellVoltage__0079;
            using EMUS_IndividualCellVoltage__0080 = signals::EMUS_IndividualCellVoltage__0080;
            using EMUS_IndividualCellVoltage__0081 = signals::EMUS_IndividualCellVoltage__0081;
            using EMUS_IndividualCellVoltage__0082 = signals::EMUS_IndividualCellVoltage__0082;
            using EMUS_IndividualCellVoltage__0083 = signals::EMUS_IndividualCellVoltage__0083;
            using EMUS_IndividualCellVoltage__0084 = signals::EMUS_IndividualCellVoltage__0084;
            using EMUS_IndividualCellVoltage__0085 = signals::EMUS_IndividualCellVoltage__0085;
            using EMUS_IndividualCellVoltage__0086 = signals::EMUS_IndividualCellVoltage__0086;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0009'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0010 {
            public:
            constexpr static uint32_t id = 0x19B5010B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0087 = signals::EMUS_IndividualCellVoltage__0087;
            using EMUS_IndividualCellVoltage__0088 = signals::EMUS_IndividualCellVoltage__0088;
            using EMUS_IndividualCellVoltage__0089 = signals::EMUS_IndividualCellVoltage__0089;
            using EMUS_IndividualCellVoltage__0090 = signals::EMUS_IndividualCellVoltage__0090;
            using EMUS_IndividualCellVoltage__0091 = signals::EMUS_IndividualCellVoltage__0091;
            using EMUS_IndividualCellVoltage__0092 = signals::EMUS_IndividualCellVoltage__0092;
            using EMUS_IndividualCellVoltage__0093 = signals::EMUS_IndividualCellVoltage__0093;
            using EMUS_IndividualCellVoltage__0094 = signals::EMUS_IndividualCellVoltage__0094;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0010'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0011 {
            public:
            constexpr static uint32_t id = 0x19B5010C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0095 = signals::EMUS_IndividualCellVoltage__0095;
            using EMUS_IndividualCellVoltage__0096 = signals::EMUS_IndividualCellVoltage__0096;
            using EMUS_IndividualCellVoltage__0097 = signals::EMUS_IndividualCellVoltage__0097;
            using EMUS_IndividualCellVoltage__0098 = signals::EMUS_IndividualCellVoltage__0098;
            using EMUS_IndividualCellVoltage__0099 = signals::EMUS_IndividualCellVoltage__0099;
            using EMUS_IndividualCellVoltage__0100 = signals::EMUS_IndividualCellVoltage__0100;
            using EMUS_IndividualCellVoltage__0101 = signals::EMUS_IndividualCellVoltage__0101;
            using EMUS_IndividualCellVoltage__0102 = signals::EMUS_IndividualCellVoltage__0102;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0011'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0012 {
            public:
            constexpr static uint32_t id = 0x19B5010D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0103 = signals::EMUS_IndividualCellVoltage__0103;
            using EMUS_IndividualCellVoltage__0104 = signals::EMUS_IndividualCellVoltage__0104;
            using EMUS_IndividualCellVoltage__0105 = signals::EMUS_IndividualCellVoltage__0105;
            using EMUS_IndividualCellVoltage__0106 = signals::EMUS_IndividualCellVoltage__0106;
            using EMUS_IndividualCellVoltage__0107 = signals::EMUS_IndividualCellVoltage__0107;
            using EMUS_IndividualCellVoltage__0108 = signals::EMUS_IndividualCellVoltage__0108;
            using EMUS_IndividualCellVoltage__0109 = signals::EMUS_IndividualCellVoltage__0109;
            using EMUS_IndividualCellVoltage__0110 = signals::EMUS_IndividualCellVoltage__0110;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0012'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0013 {
            public:
            constexpr static uint32_t id = 0x19B5010E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0111 = signals::EMUS_IndividualCellVoltage__0111;
            using EMUS_IndividualCellVoltage__0112 = signals::EMUS_IndividualCellVoltage__0112;
            using EMUS_IndividualCellVoltage__0113 = signals::EMUS_IndividualCellVoltage__0113;
            using EMUS_IndividualCellVoltage__0114 = signals::EMUS_IndividualCellVoltage__0114;
            using EMUS_IndividualCellVoltage__0115 = signals::EMUS_IndividualCellVoltage__0115;
            using EMUS_IndividualCellVoltage__0116 = signals::EMUS_IndividualCellVoltage__0116;
            using EMUS_IndividualCellVoltage__0117 = signals::EMUS_IndividualCellVoltage__0117;
            using EMUS_IndividualCellVoltage__0118 = signals::EMUS_IndividualCellVoltage__0118;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0013'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0014 {
            public:
            constexpr static uint32_t id = 0x19B5010F;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0119 = signals::EMUS_IndividualCellVoltage__0119;
            using EMUS_IndividualCellVoltage__0120 = signals::EMUS_IndividualCellVoltage__0120;
            using EMUS_IndividualCellVoltage__0121 = signals::EMUS_IndividualCellVoltage__0121;
            using EMUS_IndividualCellVoltage__0122 = signals::EMUS_IndividualCellVoltage__0122;
            using EMUS_IndividualCellVoltage__0123 = signals::EMUS_IndividualCellVoltage__0123;
            using EMUS_IndividualCellVoltage__0124 = signals::EMUS_IndividualCellVoltage__0124;
            using EMUS_IndividualCellVoltage__0125 = signals::EMUS_IndividualCellVoltage__0125;
            using EMUS_IndividualCellVoltage__0126 = signals::EMUS_IndividualCellVoltage__0126;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0014'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0015 {
            public:
            constexpr static uint32_t id = 0x19B50110;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0127 = signals::EMUS_IndividualCellVoltage__0127;
            using EMUS_IndividualCellVoltage__0128 = signals::EMUS_IndividualCellVoltage__0128;
            using EMUS_IndividualCellVoltage__0129 = signals::EMUS_IndividualCellVoltage__0129;
            using EMUS_IndividualCellVoltage__0130 = signals::EMUS_IndividualCellVoltage__0130;
            using EMUS_IndividualCellVoltage__0131 = signals::EMUS_IndividualCellVoltage__0131;
            using EMUS_IndividualCellVoltage__0132 = signals::EMUS_IndividualCellVoltage__0132;
            using EMUS_IndividualCellVoltage__0133 = signals::EMUS_IndividualCellVoltage__0133;
            using EMUS_IndividualCellVoltage__0134 = signals::EMUS_IndividualCellVoltage__0134;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0015'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0016 {
            public:
            constexpr static uint32_t id = 0x19B50111;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellVoltage__0135 = signals::EMUS_IndividualCellVoltage__0135;
            using EMUS_IndividualCellVoltage__0136 = signals::EMUS_IndividualCellVoltage__0136;
            using EMUS_IndividualCellVoltage__0137 = signals::EMUS_IndividualCellVoltage__0137;
            using EMUS_IndividualCellVoltage__0138 = signals::EMUS_IndividualCellVoltage__0138;
            using EMUS_IndividualCellVoltage__0139 = signals::EMUS_IndividualCellVoltage__0139;
            using EMUS_IndividualCellVoltage__0140 = signals::EMUS_IndividualCellVoltage__0140;
            using EMUS_IndividualCellVoltage__0141 = signals::EMUS_IndividualCellVoltage__0141;
            using EMUS_IndividualCellVoltage__0142 = signals::EMUS_IndividualCellVoltage__0142;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0016'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Temp_Ex {
            public:
            constexpr static uint32_t id = 0x19B50200;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp_Data_ = signals::EMUS_IndividualCellModTemp_Data_;
            using EMUS_IndividualCellModTemp__0000 = signals::EMUS_IndividualCellModTemp__0000;
            using EMUS_IndividualCellModTemp__0001 = signals::EMUS_IndividualCellModTemp__0001;
            using EMUS_IndividualCellModTemp__0002 = signals::EMUS_IndividualCellModTemp__0002;
            using EMUS_IndividualCellModTemp__0003 = signals::EMUS_IndividualCellModTemp__0003;
            using EMUS_IndividualCellModTemp__0004 = signals::EMUS_IndividualCellModTemp__0004;
            using EMUS_IndividualCellModTemp__0005 = signals::EMUS_IndividualCellModTemp__0005;
            using EMUS_IndividualCellModTemp__0006 = signals::EMUS_IndividualCellModTemp__0006;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Temp_Ex'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0000 {
            public:
            constexpr static uint32_t id = 0x19B50201;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0007 = signals::EMUS_IndividualCellModTemp__0007;
            using EMUS_IndividualCellModTemp__0008 = signals::EMUS_IndividualCellModTemp__0008;
            using EMUS_IndividualCellModTemp__0009 = signals::EMUS_IndividualCellModTemp__0009;
            using EMUS_IndividualCellModTemp__0010 = signals::EMUS_IndividualCellModTemp__0010;
            using EMUS_IndividualCellModTemp__0011 = signals::EMUS_IndividualCellModTemp__0011;
            using EMUS_IndividualCellModTemp__0012 = signals::EMUS_IndividualCellModTemp__0012;
            using EMUS_IndividualCellModTemp__0013 = signals::EMUS_IndividualCellModTemp__0013;
            using EMUS_IndividualCellModTemp__0014 = signals::EMUS_IndividualCellModTemp__0014;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0000'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0001 {
            public:
            constexpr static uint32_t id = 0x19B50202;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0015 = signals::EMUS_IndividualCellModTemp__0015;
            using EMUS_IndividualCellModTemp__0016 = signals::EMUS_IndividualCellModTemp__0016;
            using EMUS_IndividualCellModTemp__0017 = signals::EMUS_IndividualCellModTemp__0017;
            using EMUS_IndividualCellModTemp__0018 = signals::EMUS_IndividualCellModTemp__0018;
            using EMUS_IndividualCellModTemp__0019 = signals::EMUS_IndividualCellModTemp__0019;
            using EMUS_IndividualCellModTemp__0020 = signals::EMUS_IndividualCellModTemp__0020;
            using EMUS_IndividualCellModTemp__0021 = signals::EMUS_IndividualCellModTemp__0021;
            using EMUS_IndividualCellModTemp__0022 = signals::EMUS_IndividualCellModTemp__0022;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0001'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0002 {
            public:
            constexpr static uint32_t id = 0x19B50203;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0023 = signals::EMUS_IndividualCellModTemp__0023;
            using EMUS_IndividualCellModTemp__0024 = signals::EMUS_IndividualCellModTemp__0024;
            using EMUS_IndividualCellModTemp__0025 = signals::EMUS_IndividualCellModTemp__0025;
            using EMUS_IndividualCellModTemp__0026 = signals::EMUS_IndividualCellModTemp__0026;
            using EMUS_IndividualCellModTemp__0027 = signals::EMUS_IndividualCellModTemp__0027;
            using EMUS_IndividualCellModTemp__0028 = signals::EMUS_IndividualCellModTemp__0028;
            using EMUS_IndividualCellModTemp__0029 = signals::EMUS_IndividualCellModTemp__0029;
            using EMUS_IndividualCellModTemp__0030 = signals::EMUS_IndividualCellModTemp__0030;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0002'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0003 {
            public:
            constexpr static uint32_t id = 0x19B50204;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0031 = signals::EMUS_IndividualCellModTemp__0031;
            using EMUS_IndividualCellModTemp__0032 = signals::EMUS_IndividualCellModTemp__0032;
            using EMUS_IndividualCellModTemp__0033 = signals::EMUS_IndividualCellModTemp__0033;
            using EMUS_IndividualCellModTemp__0034 = signals::EMUS_IndividualCellModTemp__0034;
            using EMUS_IndividualCellModTemp__0035 = signals::EMUS_IndividualCellModTemp__0035;
            using EMUS_IndividualCellModTemp__0036 = signals::EMUS_IndividualCellModTemp__0036;
            using EMUS_IndividualCellModTemp__0037 = signals::EMUS_IndividualCellModTemp__0037;
            using EMUS_IndividualCellModTemp__0038 = signals::EMUS_IndividualCellModTemp__0038;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0003'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0004 {
            public:
            constexpr static uint32_t id = 0x19B50205;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0039 = signals::EMUS_IndividualCellModTemp__0039;
            using EMUS_IndividualCellModTemp__0040 = signals::EMUS_IndividualCellModTemp__0040;
            using EMUS_IndividualCellModTemp__0041 = signals::EMUS_IndividualCellModTemp__0041;
            using EMUS_IndividualCellModTemp__0042 = signals::EMUS_IndividualCellModTemp__0042;
            using EMUS_IndividualCellModTemp__0043 = signals::EMUS_IndividualCellModTemp__0043;
            using EMUS_IndividualCellModTemp__0044 = signals::EMUS_IndividualCellModTemp__0044;
            using EMUS_IndividualCellModTemp__0045 = signals::EMUS_IndividualCellModTemp__0045;
            using EMUS_IndividualCellModTemp__0046 = signals::EMUS_IndividualCellModTemp__0046;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0004'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0005 {
            public:
            constexpr static uint32_t id = 0x19B50206;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0047 = signals::EMUS_IndividualCellModTemp__0047;
            using EMUS_IndividualCellModTemp__0048 = signals::EMUS_IndividualCellModTemp__0048;
            using EMUS_IndividualCellModTemp__0049 = signals::EMUS_IndividualCellModTemp__0049;
            using EMUS_IndividualCellModTemp__0050 = signals::EMUS_IndividualCellModTemp__0050;
            using EMUS_IndividualCellModTemp__0051 = signals::EMUS_IndividualCellModTemp__0051;
            using EMUS_IndividualCellModTemp__0052 = signals::EMUS_IndividualCellModTemp__0052;
            using EMUS_IndividualCellModTemp__0053 = signals::EMUS_IndividualCellModTemp__0053;
            using EMUS_IndividualCellModTemp__0054 = signals::EMUS_IndividualCellModTemp__0054;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0005'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0006 {
            public:
            constexpr static uint32_t id = 0x19B50207;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0055 = signals::EMUS_IndividualCellModTemp__0055;
            using EMUS_IndividualCellModTemp__0056 = signals::EMUS_IndividualCellModTemp__0056;
            using EMUS_IndividualCellModTemp__0057 = signals::EMUS_IndividualCellModTemp__0057;
            using EMUS_IndividualCellModTemp__0058 = signals::EMUS_IndividualCellModTemp__0058;
            using EMUS_IndividualCellModTemp__0059 = signals::EMUS_IndividualCellModTemp__0059;
            using EMUS_IndividualCellModTemp__0060 = signals::EMUS_IndividualCellModTemp__0060;
            using EMUS_IndividualCellModTemp__0061 = signals::EMUS_IndividualCellModTemp__0061;
            using EMUS_IndividualCellModTemp__0062 = signals::EMUS_IndividualCellModTemp__0062;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0006'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0007 {
            public:
            constexpr static uint32_t id = 0x19B50208;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0063 = signals::EMUS_IndividualCellModTemp__0063;
            using EMUS_IndividualCellModTemp__0064 = signals::EMUS_IndividualCellModTemp__0064;
            using EMUS_IndividualCellModTemp__0065 = signals::EMUS_IndividualCellModTemp__0065;
            using EMUS_IndividualCellModTemp__0066 = signals::EMUS_IndividualCellModTemp__0066;
            using EMUS_IndividualCellModTemp__0067 = signals::EMUS_IndividualCellModTemp__0067;
            using EMUS_IndividualCellModTemp__0068 = signals::EMUS_IndividualCellModTemp__0068;
            using EMUS_IndividualCellModTemp__0069 = signals::EMUS_IndividualCellModTemp__0069;
            using EMUS_IndividualCellModTemp__0070 = signals::EMUS_IndividualCellModTemp__0070;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0007'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0008 {
            public:
            constexpr static uint32_t id = 0x19B50209;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0071 = signals::EMUS_IndividualCellModTemp__0071;
            using EMUS_IndividualCellModTemp__0072 = signals::EMUS_IndividualCellModTemp__0072;
            using EMUS_IndividualCellModTemp__0073 = signals::EMUS_IndividualCellModTemp__0073;
            using EMUS_IndividualCellModTemp__0074 = signals::EMUS_IndividualCellModTemp__0074;
            using EMUS_IndividualCellModTemp__0075 = signals::EMUS_IndividualCellModTemp__0075;
            using EMUS_IndividualCellModTemp__0076 = signals::EMUS_IndividualCellModTemp__0076;
            using EMUS_IndividualCellModTemp__0077 = signals::EMUS_IndividualCellModTemp__0077;
            using EMUS_IndividualCellModTemp__0078 = signals::EMUS_IndividualCellModTemp__0078;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0008'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0009 {
            public:
            constexpr static uint32_t id = 0x19B5020A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0079 = signals::EMUS_IndividualCellModTemp__0079;
            using EMUS_IndividualCellModTemp__0080 = signals::EMUS_IndividualCellModTemp__0080;
            using EMUS_IndividualCellModTemp__0081 = signals::EMUS_IndividualCellModTemp__0081;
            using EMUS_IndividualCellModTemp__0082 = signals::EMUS_IndividualCellModTemp__0082;
            using EMUS_IndividualCellModTemp__0083 = signals::EMUS_IndividualCellModTemp__0083;
            using EMUS_IndividualCellModTemp__0084 = signals::EMUS_IndividualCellModTemp__0084;
            using EMUS_IndividualCellModTemp__0085 = signals::EMUS_IndividualCellModTemp__0085;
            using EMUS_IndividualCellModTemp__0086 = signals::EMUS_IndividualCellModTemp__0086;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0009'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0010 {
            public:
            constexpr static uint32_t id = 0x19B5020B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0087 = signals::EMUS_IndividualCellModTemp__0087;
            using EMUS_IndividualCellModTemp__0088 = signals::EMUS_IndividualCellModTemp__0088;
            using EMUS_IndividualCellModTemp__0089 = signals::EMUS_IndividualCellModTemp__0089;
            using EMUS_IndividualCellModTemp__0090 = signals::EMUS_IndividualCellModTemp__0090;
            using EMUS_IndividualCellModTemp__0091 = signals::EMUS_IndividualCellModTemp__0091;
            using EMUS_IndividualCellModTemp__0092 = signals::EMUS_IndividualCellModTemp__0092;
            using EMUS_IndividualCellModTemp__0093 = signals::EMUS_IndividualCellModTemp__0093;
            using EMUS_IndividualCellModTemp__0094 = signals::EMUS_IndividualCellModTemp__0094;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0010'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0011 {
            public:
            constexpr static uint32_t id = 0x19B5020C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0095 = signals::EMUS_IndividualCellModTemp__0095;
            using EMUS_IndividualCellModTemp__0096 = signals::EMUS_IndividualCellModTemp__0096;
            using EMUS_IndividualCellModTemp__0097 = signals::EMUS_IndividualCellModTemp__0097;
            using EMUS_IndividualCellModTemp__0098 = signals::EMUS_IndividualCellModTemp__0098;
            using EMUS_IndividualCellModTemp__0099 = signals::EMUS_IndividualCellModTemp__0099;
            using EMUS_IndividualCellModTemp__0100 = signals::EMUS_IndividualCellModTemp__0100;
            using EMUS_IndividualCellModTemp__0101 = signals::EMUS_IndividualCellModTemp__0101;
            using EMUS_IndividualCellModTemp__0102 = signals::EMUS_IndividualCellModTemp__0102;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0011'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0012 {
            public:
            constexpr static uint32_t id = 0x19B5020D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0103 = signals::EMUS_IndividualCellModTemp__0103;
            using EMUS_IndividualCellModTemp__0104 = signals::EMUS_IndividualCellModTemp__0104;
            using EMUS_IndividualCellModTemp__0105 = signals::EMUS_IndividualCellModTemp__0105;
            using EMUS_IndividualCellModTemp__0106 = signals::EMUS_IndividualCellModTemp__0106;
            using EMUS_IndividualCellModTemp__0107 = signals::EMUS_IndividualCellModTemp__0107;
            using EMUS_IndividualCellModTemp__0108 = signals::EMUS_IndividualCellModTemp__0108;
            using EMUS_IndividualCellModTemp__0109 = signals::EMUS_IndividualCellModTemp__0109;
            using EMUS_IndividualCellModTemp__0110 = signals::EMUS_IndividualCellModTemp__0110;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0012'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0013 {
            public:
            constexpr static uint32_t id = 0x19B5020E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0111 = signals::EMUS_IndividualCellModTemp__0111;
            using EMUS_IndividualCellModTemp__0112 = signals::EMUS_IndividualCellModTemp__0112;
            using EMUS_IndividualCellModTemp__0113 = signals::EMUS_IndividualCellModTemp__0113;
            using EMUS_IndividualCellModTemp__0114 = signals::EMUS_IndividualCellModTemp__0114;
            using EMUS_IndividualCellModTemp__0115 = signals::EMUS_IndividualCellModTemp__0115;
            using EMUS_IndividualCellModTemp__0116 = signals::EMUS_IndividualCellModTemp__0116;
            using EMUS_IndividualCellModTemp__0117 = signals::EMUS_IndividualCellModTemp__0117;
            using EMUS_IndividualCellModTemp__0118 = signals::EMUS_IndividualCellModTemp__0118;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0013'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0014 {
            public:
            constexpr static uint32_t id = 0x19B5020F;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0119 = signals::EMUS_IndividualCellModTemp__0119;
            using EMUS_IndividualCellModTemp__0120 = signals::EMUS_IndividualCellModTemp__0120;
            using EMUS_IndividualCellModTemp__0121 = signals::EMUS_IndividualCellModTemp__0121;
            using EMUS_IndividualCellModTemp__0122 = signals::EMUS_IndividualCellModTemp__0122;
            using EMUS_IndividualCellModTemp__0123 = signals::EMUS_IndividualCellModTemp__0123;
            using EMUS_IndividualCellModTemp__0124 = signals::EMUS_IndividualCellModTemp__0124;
            using EMUS_IndividualCellModTemp__0125 = signals::EMUS_IndividualCellModTemp__0125;
            using EMUS_IndividualCellModTemp__0126 = signals::EMUS_IndividualCellModTemp__0126;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0014'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0015 {
            public:
            constexpr static uint32_t id = 0x19B50210;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0127 = signals::EMUS_IndividualCellModTemp__0127;
            using EMUS_IndividualCellModTemp__0128 = signals::EMUS_IndividualCellModTemp__0128;
            using EMUS_IndividualCellModTemp__0129 = signals::EMUS_IndividualCellModTemp__0129;
            using EMUS_IndividualCellModTemp__0130 = signals::EMUS_IndividualCellModTemp__0130;
            using EMUS_IndividualCellModTemp__0131 = signals::EMUS_IndividualCellModTemp__0131;
            using EMUS_IndividualCellModTemp__0132 = signals::EMUS_IndividualCellModTemp__0132;
            using EMUS_IndividualCellModTemp__0133 = signals::EMUS_IndividualCellModTemp__0133;
            using EMUS_IndividualCellModTemp__0134 = signals::EMUS_IndividualCellModTemp__0134;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0015'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0016 {
            public:
            constexpr static uint32_t id = 0x19B50211;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellModTemp__0135 = signals::EMUS_IndividualCellModTemp__0135;
            using EMUS_IndividualCellModTemp__0136 = signals::EMUS_IndividualCellModTemp__0136;
            using EMUS_IndividualCellModTemp__0137 = signals::EMUS_IndividualCellModTemp__0137;
            using EMUS_IndividualCellModTemp__0138 = signals::EMUS_IndividualCellModTemp__0138;
            using EMUS_IndividualCellModTemp__0139 = signals::EMUS_IndividualCellModTemp__0139;
            using EMUS_IndividualCellModTemp__0140 = signals::EMUS_IndividualCellModTemp__0140;
            using EMUS_IndividualCellModTemp__0141 = signals::EMUS_IndividualCellModTemp__0141;
            using EMUS_IndividualCellModTemp__0142 = signals::EMUS_IndividualCellModTemp__0142;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0016'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_Ext_A0 {
            public:
            constexpr static uint32_t id = 0x19B50800;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperature_D = signals::EMUS_IndividualCellTemperature_D;
            using EMUS_IndividualCellTemperat_0000 = signals::EMUS_IndividualCellTemperat_0000;
            using EMUS_IndividualCellTemperat_0001 = signals::EMUS_IndividualCellTemperat_0001;
            using EMUS_IndividualCellTemperat_0002 = signals::EMUS_IndividualCellTemperat_0002;
            using EMUS_IndividualCellTemperat_0003 = signals::EMUS_IndividualCellTemperat_0003;
            using EMUS_IndividualCellTemperat_0004 = signals::EMUS_IndividualCellTemperat_0004;
            using EMUS_IndividualCellTemperat_0005 = signals::EMUS_IndividualCellTemperat_0005;
            using EMUS_IndividualCellTemperat_0006 = signals::EMUS_IndividualCellTemperat_0006;

            // Attributes of message 'EMUS_Individual_Cell_Temp_Ext_A0'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0000 {
            public:
            constexpr static uint32_t id = 0x19B50801;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0007 = signals::EMUS_IndividualCellTemperat_0007;
            using EMUS_IndividualCellTemperat_0008 = signals::EMUS_IndividualCellTemperat_0008;
            using EMUS_IndividualCellTemperat_0009 = signals::EMUS_IndividualCellTemperat_0009;
            using EMUS_IndividualCellTemperat_0010 = signals::EMUS_IndividualCellTemperat_0010;
            using EMUS_IndividualCellTemperat_0011 = signals::EMUS_IndividualCellTemperat_0011;
            using EMUS_IndividualCellTemperat_0012 = signals::EMUS_IndividualCellTemperat_0012;
            using EMUS_IndividualCellTemperat_0013 = signals::EMUS_IndividualCellTemperat_0013;
            using EMUS_IndividualCellTemperat_0014 = signals::EMUS_IndividualCellTemperat_0014;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0000'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0001 {
            public:
            constexpr static uint32_t id = 0x19B50802;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0015 = signals::EMUS_IndividualCellTemperat_0015;
            using EMUS_IndividualCellTemperat_0016 = signals::EMUS_IndividualCellTemperat_0016;
            using EMUS_IndividualCellTemperat_0017 = signals::EMUS_IndividualCellTemperat_0017;
            using EMUS_IndividualCellTemperat_0018 = signals::EMUS_IndividualCellTemperat_0018;
            using EMUS_IndividualCellTemperat_0019 = signals::EMUS_IndividualCellTemperat_0019;
            using EMUS_IndividualCellTemperat_0020 = signals::EMUS_IndividualCellTemperat_0020;
            using EMUS_IndividualCellTemperat_0021 = signals::EMUS_IndividualCellTemperat_0021;
            using EMUS_IndividualCellTemperat_0022 = signals::EMUS_IndividualCellTemperat_0022;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0001'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0002 {
            public:
            constexpr static uint32_t id = 0x19B50803;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0023 = signals::EMUS_IndividualCellTemperat_0023;
            using EMUS_IndividualCellTemperat_0024 = signals::EMUS_IndividualCellTemperat_0024;
            using EMUS_IndividualCellTemperat_0025 = signals::EMUS_IndividualCellTemperat_0025;
            using EMUS_IndividualCellTemperat_0026 = signals::EMUS_IndividualCellTemperat_0026;
            using EMUS_IndividualCellTemperat_0027 = signals::EMUS_IndividualCellTemperat_0027;
            using EMUS_IndividualCellTemperat_0028 = signals::EMUS_IndividualCellTemperat_0028;
            using EMUS_IndividualCellTemperat_0029 = signals::EMUS_IndividualCellTemperat_0029;
            using EMUS_IndividualCellTemperat_0030 = signals::EMUS_IndividualCellTemperat_0030;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0002'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0003 {
            public:
            constexpr static uint32_t id = 0x19B50804;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0031 = signals::EMUS_IndividualCellTemperat_0031;
            using EMUS_IndividualCellTemperat_0032 = signals::EMUS_IndividualCellTemperat_0032;
            using EMUS_IndividualCellTemperat_0033 = signals::EMUS_IndividualCellTemperat_0033;
            using EMUS_IndividualCellTemperat_0034 = signals::EMUS_IndividualCellTemperat_0034;
            using EMUS_IndividualCellTemperat_0035 = signals::EMUS_IndividualCellTemperat_0035;
            using EMUS_IndividualCellTemperat_0036 = signals::EMUS_IndividualCellTemperat_0036;
            using EMUS_IndividualCellTemperat_0037 = signals::EMUS_IndividualCellTemperat_0037;
            using EMUS_IndividualCellTemperat_0038 = signals::EMUS_IndividualCellTemperat_0038;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0003'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0004 {
            public:
            constexpr static uint32_t id = 0x19B50805;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0039 = signals::EMUS_IndividualCellTemperat_0039;
            using EMUS_IndividualCellTemperat_0040 = signals::EMUS_IndividualCellTemperat_0040;
            using EMUS_IndividualCellTemperat_0041 = signals::EMUS_IndividualCellTemperat_0041;
            using EMUS_IndividualCellTemperat_0042 = signals::EMUS_IndividualCellTemperat_0042;
            using EMUS_IndividualCellTemperat_0043 = signals::EMUS_IndividualCellTemperat_0043;
            using EMUS_IndividualCellTemperat_0044 = signals::EMUS_IndividualCellTemperat_0044;
            using EMUS_IndividualCellTemperat_0045 = signals::EMUS_IndividualCellTemperat_0045;
            using EMUS_IndividualCellTemperat_0046 = signals::EMUS_IndividualCellTemperat_0046;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0004'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0005 {
            public:
            constexpr static uint32_t id = 0x19B50806;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0047 = signals::EMUS_IndividualCellTemperat_0047;
            using EMUS_IndividualCellTemperat_0048 = signals::EMUS_IndividualCellTemperat_0048;
            using EMUS_IndividualCellTemperat_0049 = signals::EMUS_IndividualCellTemperat_0049;
            using EMUS_IndividualCellTemperat_0050 = signals::EMUS_IndividualCellTemperat_0050;
            using EMUS_IndividualCellTemperat_0051 = signals::EMUS_IndividualCellTemperat_0051;
            using EMUS_IndividualCellTemperat_0052 = signals::EMUS_IndividualCellTemperat_0052;
            using EMUS_IndividualCellTemperat_0053 = signals::EMUS_IndividualCellTemperat_0053;
            using EMUS_IndividualCellTemperat_0054 = signals::EMUS_IndividualCellTemperat_0054;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0005'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0006 {
            public:
            constexpr static uint32_t id = 0x19B50807;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0055 = signals::EMUS_IndividualCellTemperat_0055;
            using EMUS_IndividualCellTemperat_0056 = signals::EMUS_IndividualCellTemperat_0056;
            using EMUS_IndividualCellTemperat_0057 = signals::EMUS_IndividualCellTemperat_0057;
            using EMUS_IndividualCellTemperat_0058 = signals::EMUS_IndividualCellTemperat_0058;
            using EMUS_IndividualCellTemperat_0059 = signals::EMUS_IndividualCellTemperat_0059;
            using EMUS_IndividualCellTemperat_0060 = signals::EMUS_IndividualCellTemperat_0060;
            using EMUS_IndividualCellTemperat_0061 = signals::EMUS_IndividualCellTemperat_0061;
            using EMUS_IndividualCellTemperat_0062 = signals::EMUS_IndividualCellTemperat_0062;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0006'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0007 {
            public:
            constexpr static uint32_t id = 0x19B50808;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0063 = signals::EMUS_IndividualCellTemperat_0063;
            using EMUS_IndividualCellTemperat_0064 = signals::EMUS_IndividualCellTemperat_0064;
            using EMUS_IndividualCellTemperat_0065 = signals::EMUS_IndividualCellTemperat_0065;
            using EMUS_IndividualCellTemperat_0066 = signals::EMUS_IndividualCellTemperat_0066;
            using EMUS_IndividualCellTemperat_0067 = signals::EMUS_IndividualCellTemperat_0067;
            using EMUS_IndividualCellTemperat_0068 = signals::EMUS_IndividualCellTemperat_0068;
            using EMUS_IndividualCellTemperat_0069 = signals::EMUS_IndividualCellTemperat_0069;
            using EMUS_IndividualCellTemperat_0070 = signals::EMUS_IndividualCellTemperat_0070;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0007'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_E_0008 {
            public:
            constexpr static uint32_t id = 0x19B50809;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0071 = signals::EMUS_IndividualCellTemperat_0071;
            using EMUS_IndividualCellTemperat_0072 = signals::EMUS_IndividualCellTemperat_0072;
            using EMUS_IndividualCellTemperat_0073 = signals::EMUS_IndividualCellTemperat_0073;
            using EMUS_IndividualCellTemperat_0074 = signals::EMUS_IndividualCellTemperat_0074;
            using EMUS_IndividualCellTemperat_0075 = signals::EMUS_IndividualCellTemperat_0075;
            using EMUS_IndividualCellTemperat_0076 = signals::EMUS_IndividualCellTemperat_0076;
            using EMUS_IndividualCellTemperat_0077 = signals::EMUS_IndividualCellTemperat_0077;
            using EMUS_IndividualCellTemperat_0078 = signals::EMUS_IndividualCellTemperat_0078;

            // Attributes of message 'EMUS_Individual_Cell_Temp_E_0008'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_Ext_A1 {
            public:
            constexpr static uint32_t id = 0x19B5080A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellTemperat_0079 = signals::EMUS_IndividualCellTemperat_0079;
            using EMUS_IndividualCellTemperat_0080 = signals::EMUS_IndividualCellTemperat_0080;
            using EMUS_IndividualCellTemperat_0081 = signals::EMUS_IndividualCellTemperat_0081;
            using EMUS_IndividualCellTemperat_0082 = signals::EMUS_IndividualCellTemperat_0082;
            using EMUS_IndividualCellTemperat_0083 = signals::EMUS_IndividualCellTemperat_0083;
            using EMUS_IndividualCellTemperat_0084 = signals::EMUS_IndividualCellTemperat_0084;
            using EMUS_IndividualCellTemperat_0085 = signals::EMUS_IndividualCellTemperat_0085;
            using EMUS_IndividualCellTemperat_0086 = signals::EMUS_IndividualCellTemperat_0086;

            // Attributes of message 'EMUS_Individual_Cell_Temp_Ext_A1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cells_Volta_0017 {
            public:
            constexpr static uint32_t id = 0x19B5000B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Individual_Cells_Group_Opt_ = signals::EMUS_Individual_Cells_Group_Opt_;
            using EMUS_IndividualCellVoltage__0143 = signals::EMUS_IndividualCellVoltage__0143;
            using EMUS_IndividualCellVoltage__0144 = signals::EMUS_IndividualCellVoltage__0144;
            using EMUS_IndividualCellVoltage__0145 = signals::EMUS_IndividualCellVoltage__0145;
            using EMUS_IndividualCellVoltage__0146 = signals::EMUS_IndividualCellVoltage__0146;
            using EMUS_IndividualCellVoltage__0147 = signals::EMUS_IndividualCellVoltage__0147;
            using EMUS_IndividualCellVoltage__0148 = signals::EMUS_IndividualCellVoltage__0148;
            using EMUS_IndividualCellVoltage__0149 = signals::EMUS_IndividualCellVoltage__0149;

            // Attributes of message 'EMUS_Individual_Cells_Volta_0017'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan_Rate_ {
            public:
            constexpr static uint32_t id = 0x19B5000D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Individual_Cells_Group_0000 = signals::EMUS_Individual_Cells_Group_0000;
            using EMUS_IndividualCellBalancRate_Da = signals::EMUS_IndividualCellBalancRate_Da;
            using EMUS_IndividualCellBalancRa_0000 = signals::EMUS_IndividualCellBalancRa_0000;
            using EMUS_IndividualCellBalancRa_0001 = signals::EMUS_IndividualCellBalancRa_0001;
            using EMUS_IndividualCellBalancRa_0002 = signals::EMUS_IndividualCellBalancRa_0002;
            using EMUS_IndividualCellBalancRa_0003 = signals::EMUS_IndividualCellBalancRa_0003;
            using EMUS_IndividualCellBalancRa_0004 = signals::EMUS_IndividualCellBalancRa_0004;
            using EMUS_IndividualCellBalancRa_0005 = signals::EMUS_IndividualCellBalancRa_0005;

            // Attributes of message 'EMUS_Individual_Cell_Balan_Rate_'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0000 {
            public:
            constexpr static uint32_t id = 0x19B50300;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0006 = signals::EMUS_IndividualCellBalancRa_0006;
            using EMUS_IndividualCellBalancRa_0007 = signals::EMUS_IndividualCellBalancRa_0007;
            using EMUS_IndividualCellBalancRa_0008 = signals::EMUS_IndividualCellBalancRa_0008;
            using EMUS_IndividualCellBalancRa_0009 = signals::EMUS_IndividualCellBalancRa_0009;
            using EMUS_IndividualCellBalancRa_0010 = signals::EMUS_IndividualCellBalancRa_0010;
            using EMUS_IndividualCellBalancRa_0011 = signals::EMUS_IndividualCellBalancRa_0011;
            using EMUS_IndividualCellBalancRa_0012 = signals::EMUS_IndividualCellBalancRa_0012;
            using EMUS_IndividualCellBalancRa_0013 = signals::EMUS_IndividualCellBalancRa_0013;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0000'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0001 {
            public:
            constexpr static uint32_t id = 0x19B50301;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0014 = signals::EMUS_IndividualCellBalancRa_0014;
            using EMUS_IndividualCellBalancRa_0015 = signals::EMUS_IndividualCellBalancRa_0015;
            using EMUS_IndividualCellBalancRa_0016 = signals::EMUS_IndividualCellBalancRa_0016;
            using EMUS_IndividualCellBalancRa_0017 = signals::EMUS_IndividualCellBalancRa_0017;
            using EMUS_IndividualCellBalancRa_0018 = signals::EMUS_IndividualCellBalancRa_0018;
            using EMUS_IndividualCellBalancRa_0019 = signals::EMUS_IndividualCellBalancRa_0019;
            using EMUS_IndividualCellBalancRa_0020 = signals::EMUS_IndividualCellBalancRa_0020;
            using EMUS_IndividualCellBalancRa_0021 = signals::EMUS_IndividualCellBalancRa_0021;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0001'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0002 {
            public:
            constexpr static uint32_t id = 0x19B50302;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0022 = signals::EMUS_IndividualCellBalancRa_0022;
            using EMUS_IndividualCellBalancRa_0023 = signals::EMUS_IndividualCellBalancRa_0023;
            using EMUS_IndividualCellBalancRa_0024 = signals::EMUS_IndividualCellBalancRa_0024;
            using EMUS_IndividualCellBalancRa_0025 = signals::EMUS_IndividualCellBalancRa_0025;
            using EMUS_IndividualCellBalancRa_0026 = signals::EMUS_IndividualCellBalancRa_0026;
            using EMUS_IndividualCellBalancRa_0027 = signals::EMUS_IndividualCellBalancRa_0027;
            using EMUS_IndividualCellBalancRa_0028 = signals::EMUS_IndividualCellBalancRa_0028;
            using EMUS_IndividualCellBalancRa_0029 = signals::EMUS_IndividualCellBalancRa_0029;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0002'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0003 {
            public:
            constexpr static uint32_t id = 0x19B50303;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0030 = signals::EMUS_IndividualCellBalancRa_0030;
            using EMUS_IndividualCellBalancRa_0031 = signals::EMUS_IndividualCellBalancRa_0031;
            using EMUS_IndividualCellBalancRa_0032 = signals::EMUS_IndividualCellBalancRa_0032;
            using EMUS_IndividualCellBalancRa_0033 = signals::EMUS_IndividualCellBalancRa_0033;
            using EMUS_IndividualCellBalancRa_0034 = signals::EMUS_IndividualCellBalancRa_0034;
            using EMUS_IndividualCellBalancRa_0035 = signals::EMUS_IndividualCellBalancRa_0035;
            using EMUS_IndividualCellBalancRa_0036 = signals::EMUS_IndividualCellBalancRa_0036;
            using EMUS_IndividualCellBalancRa_0037 = signals::EMUS_IndividualCellBalancRa_0037;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0003'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0004 {
            public:
            constexpr static uint32_t id = 0x19B50304;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0038 = signals::EMUS_IndividualCellBalancRa_0038;
            using EMUS_IndividualCellBalancRa_0039 = signals::EMUS_IndividualCellBalancRa_0039;
            using EMUS_IndividualCellBalancRa_0040 = signals::EMUS_IndividualCellBalancRa_0040;
            using EMUS_IndividualCellBalancRa_0041 = signals::EMUS_IndividualCellBalancRa_0041;
            using EMUS_IndividualCellBalancRa_0042 = signals::EMUS_IndividualCellBalancRa_0042;
            using EMUS_IndividualCellBalancRa_0043 = signals::EMUS_IndividualCellBalancRa_0043;
            using EMUS_IndividualCellBalancRa_0044 = signals::EMUS_IndividualCellBalancRa_0044;
            using EMUS_IndividualCellBalancRa_0045 = signals::EMUS_IndividualCellBalancRa_0045;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0004'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0005 {
            public:
            constexpr static uint32_t id = 0x19B50305;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0046 = signals::EMUS_IndividualCellBalancRa_0046;
            using EMUS_IndividualCellBalancRa_0047 = signals::EMUS_IndividualCellBalancRa_0047;
            using EMUS_IndividualCellBalancRa_0048 = signals::EMUS_IndividualCellBalancRa_0048;
            using EMUS_IndividualCellBalancRa_0049 = signals::EMUS_IndividualCellBalancRa_0049;
            using EMUS_IndividualCellBalancRa_0050 = signals::EMUS_IndividualCellBalancRa_0050;
            using EMUS_IndividualCellBalancRa_0051 = signals::EMUS_IndividualCellBalancRa_0051;
            using EMUS_IndividualCellBalancRa_0052 = signals::EMUS_IndividualCellBalancRa_0052;
            using EMUS_IndividualCellBalancRa_0053 = signals::EMUS_IndividualCellBalancRa_0053;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0005'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0006 {
            public:
            constexpr static uint32_t id = 0x19B50306;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0054 = signals::EMUS_IndividualCellBalancRa_0054;
            using EMUS_IndividualCellBalancRa_0055 = signals::EMUS_IndividualCellBalancRa_0055;
            using EMUS_IndividualCellBalancRa_0056 = signals::EMUS_IndividualCellBalancRa_0056;
            using EMUS_IndividualCellBalancRa_0057 = signals::EMUS_IndividualCellBalancRa_0057;
            using EMUS_IndividualCellBalancRa_0058 = signals::EMUS_IndividualCellBalancRa_0058;
            using EMUS_IndividualCellBalancRa_0059 = signals::EMUS_IndividualCellBalancRa_0059;
            using EMUS_IndividualCellBalancRa_0060 = signals::EMUS_IndividualCellBalancRa_0060;
            using EMUS_IndividualCellBalancRa_0061 = signals::EMUS_IndividualCellBalancRa_0061;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0006'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0007 {
            public:
            constexpr static uint32_t id = 0x19B50307;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0062 = signals::EMUS_IndividualCellBalancRa_0062;
            using EMUS_IndividualCellBalancRa_0063 = signals::EMUS_IndividualCellBalancRa_0063;
            using EMUS_IndividualCellBalancRa_0064 = signals::EMUS_IndividualCellBalancRa_0064;
            using EMUS_IndividualCellBalancRa_0065 = signals::EMUS_IndividualCellBalancRa_0065;
            using EMUS_IndividualCellBalancRa_0066 = signals::EMUS_IndividualCellBalancRa_0066;
            using EMUS_IndividualCellBalancRa_0067 = signals::EMUS_IndividualCellBalancRa_0067;
            using EMUS_IndividualCellBalancRa_0068 = signals::EMUS_IndividualCellBalancRa_0068;
            using EMUS_IndividualCellBalancRa_0069 = signals::EMUS_IndividualCellBalancRa_0069;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0007'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0008 {
            public:
            constexpr static uint32_t id = 0x19B50308;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0070 = signals::EMUS_IndividualCellBalancRa_0070;
            using EMUS_IndividualCellBalancRa_0071 = signals::EMUS_IndividualCellBalancRa_0071;
            using EMUS_IndividualCellBalancRa_0072 = signals::EMUS_IndividualCellBalancRa_0072;
            using EMUS_IndividualCellBalancRa_0073 = signals::EMUS_IndividualCellBalancRa_0073;
            using EMUS_IndividualCellBalancRa_0074 = signals::EMUS_IndividualCellBalancRa_0074;
            using EMUS_IndividualCellBalancRa_0075 = signals::EMUS_IndividualCellBalancRa_0075;
            using EMUS_IndividualCellBalancRa_0076 = signals::EMUS_IndividualCellBalancRa_0076;
            using EMUS_IndividualCellBalancRa_0077 = signals::EMUS_IndividualCellBalancRa_0077;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0008'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0009 {
            public:
            constexpr static uint32_t id = 0x19B50309;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0078 = signals::EMUS_IndividualCellBalancRa_0078;
            using EMUS_IndividualCellBalancRa_0079 = signals::EMUS_IndividualCellBalancRa_0079;
            using EMUS_IndividualCellBalancRa_0080 = signals::EMUS_IndividualCellBalancRa_0080;
            using EMUS_IndividualCellBalancRa_0081 = signals::EMUS_IndividualCellBalancRa_0081;
            using EMUS_IndividualCellBalancRa_0082 = signals::EMUS_IndividualCellBalancRa_0082;
            using EMUS_IndividualCellBalancRa_0083 = signals::EMUS_IndividualCellBalancRa_0083;
            using EMUS_IndividualCellBalancRa_0084 = signals::EMUS_IndividualCellBalancRa_0084;
            using EMUS_IndividualCellBalancRa_0085 = signals::EMUS_IndividualCellBalancRa_0085;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0009'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0010 {
            public:
            constexpr static uint32_t id = 0x19B5030A;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0086 = signals::EMUS_IndividualCellBalancRa_0086;
            using EMUS_IndividualCellBalancRa_0087 = signals::EMUS_IndividualCellBalancRa_0087;
            using EMUS_IndividualCellBalancRa_0088 = signals::EMUS_IndividualCellBalancRa_0088;
            using EMUS_IndividualCellBalancRa_0089 = signals::EMUS_IndividualCellBalancRa_0089;
            using EMUS_IndividualCellBalancRa_0090 = signals::EMUS_IndividualCellBalancRa_0090;
            using EMUS_IndividualCellBalancRa_0091 = signals::EMUS_IndividualCellBalancRa_0091;
            using EMUS_IndividualCellBalancRa_0092 = signals::EMUS_IndividualCellBalancRa_0092;
            using EMUS_IndividualCellBalancRa_0093 = signals::EMUS_IndividualCellBalancRa_0093;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0010'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0011 {
            public:
            constexpr static uint32_t id = 0x19B5030B;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0094 = signals::EMUS_IndividualCellBalancRa_0094;
            using EMUS_IndividualCellBalancRa_0095 = signals::EMUS_IndividualCellBalancRa_0095;
            using EMUS_IndividualCellBalancRa_0096 = signals::EMUS_IndividualCellBalancRa_0096;
            using EMUS_IndividualCellBalancRa_0097 = signals::EMUS_IndividualCellBalancRa_0097;
            using EMUS_IndividualCellBalancRa_0098 = signals::EMUS_IndividualCellBalancRa_0098;
            using EMUS_IndividualCellBalancRa_0099 = signals::EMUS_IndividualCellBalancRa_0099;
            using EMUS_IndividualCellBalancRa_0100 = signals::EMUS_IndividualCellBalancRa_0100;
            using EMUS_IndividualCellBalancRa_0101 = signals::EMUS_IndividualCellBalancRa_0101;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0011'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0012 {
            public:
            constexpr static uint32_t id = 0x19B5030C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0102 = signals::EMUS_IndividualCellBalancRa_0102;
            using EMUS_IndividualCellBalancRa_0103 = signals::EMUS_IndividualCellBalancRa_0103;
            using EMUS_IndividualCellBalancRa_0104 = signals::EMUS_IndividualCellBalancRa_0104;
            using EMUS_IndividualCellBalancRa_0105 = signals::EMUS_IndividualCellBalancRa_0105;
            using EMUS_IndividualCellBalancRa_0106 = signals::EMUS_IndividualCellBalancRa_0106;
            using EMUS_IndividualCellBalancRa_0107 = signals::EMUS_IndividualCellBalancRa_0107;
            using EMUS_IndividualCellBalancRa_0108 = signals::EMUS_IndividualCellBalancRa_0108;
            using EMUS_IndividualCellBalancRa_0109 = signals::EMUS_IndividualCellBalancRa_0109;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0012'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0013 {
            public:
            constexpr static uint32_t id = 0x19B5030D;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0110 = signals::EMUS_IndividualCellBalancRa_0110;
            using EMUS_IndividualCellBalancRa_0111 = signals::EMUS_IndividualCellBalancRa_0111;
            using EMUS_IndividualCellBalancRa_0112 = signals::EMUS_IndividualCellBalancRa_0112;
            using EMUS_IndividualCellBalancRa_0113 = signals::EMUS_IndividualCellBalancRa_0113;
            using EMUS_IndividualCellBalancRa_0114 = signals::EMUS_IndividualCellBalancRa_0114;
            using EMUS_IndividualCellBalancRa_0115 = signals::EMUS_IndividualCellBalancRa_0115;
            using EMUS_IndividualCellBalancRa_0116 = signals::EMUS_IndividualCellBalancRa_0116;
            using EMUS_IndividualCellBalancRa_0117 = signals::EMUS_IndividualCellBalancRa_0117;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0013'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0014 {
            public:
            constexpr static uint32_t id = 0x19B5030E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0118 = signals::EMUS_IndividualCellBalancRa_0118;
            using EMUS_IndividualCellBalancRa_0119 = signals::EMUS_IndividualCellBalancRa_0119;
            using EMUS_IndividualCellBalancRa_0120 = signals::EMUS_IndividualCellBalancRa_0120;
            using EMUS_IndividualCellBalancRa_0121 = signals::EMUS_IndividualCellBalancRa_0121;
            using EMUS_IndividualCellBalancRa_0122 = signals::EMUS_IndividualCellBalancRa_0122;
            using EMUS_IndividualCellBalancRa_0123 = signals::EMUS_IndividualCellBalancRa_0123;
            using EMUS_IndividualCellBalancRa_0124 = signals::EMUS_IndividualCellBalancRa_0124;
            using EMUS_IndividualCellBalancRa_0125 = signals::EMUS_IndividualCellBalancRa_0125;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0014'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0015 {
            public:
            constexpr static uint32_t id = 0x19B5030F;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0126 = signals::EMUS_IndividualCellBalancRa_0126;
            using EMUS_IndividualCellBalancRa_0127 = signals::EMUS_IndividualCellBalancRa_0127;
            using EMUS_IndividualCellBalancRa_0128 = signals::EMUS_IndividualCellBalancRa_0128;
            using EMUS_IndividualCellBalancRa_0129 = signals::EMUS_IndividualCellBalancRa_0129;
            using EMUS_IndividualCellBalancRa_0130 = signals::EMUS_IndividualCellBalancRa_0130;
            using EMUS_IndividualCellBalancRa_0131 = signals::EMUS_IndividualCellBalancRa_0131;
            using EMUS_IndividualCellBalancRa_0132 = signals::EMUS_IndividualCellBalancRa_0132;
            using EMUS_IndividualCellBalancRa_0133 = signals::EMUS_IndividualCellBalancRa_0133;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0015'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0016 {
            public:
            constexpr static uint32_t id = 0x19B50310;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0134 = signals::EMUS_IndividualCellBalancRa_0134;
            using EMUS_IndividualCellBalancRa_0135 = signals::EMUS_IndividualCellBalancRa_0135;
            using EMUS_IndividualCellBalancRa_0136 = signals::EMUS_IndividualCellBalancRa_0136;
            using EMUS_IndividualCellBalancRa_0137 = signals::EMUS_IndividualCellBalancRa_0137;
            using EMUS_IndividualCellBalancRa_0138 = signals::EMUS_IndividualCellBalancRa_0138;
            using EMUS_IndividualCellBalancRa_0139 = signals::EMUS_IndividualCellBalancRa_0139;
            using EMUS_IndividualCellBalancRa_0140 = signals::EMUS_IndividualCellBalancRa_0140;
            using EMUS_IndividualCellBalancRa_0141 = signals::EMUS_IndividualCellBalancRa_0141;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0016'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Balan__0017 {
            public:
            constexpr static uint32_t id = 0x19B50311;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_IndividualCellBalancRa_0142 = signals::EMUS_IndividualCellBalancRa_0142;
            using EMUS_IndividualCellBalancRa_0143 = signals::EMUS_IndividualCellBalancRa_0143;
            using EMUS_IndividualCellBalancRa_0144 = signals::EMUS_IndividualCellBalancRa_0144;
            using EMUS_IndividualCellBalancRa_0145 = signals::EMUS_IndividualCellBalancRa_0145;
            using EMUS_IndividualCellBalancRa_0146 = signals::EMUS_IndividualCellBalancRa_0146;
            using EMUS_IndividualCellBalancRa_0147 = signals::EMUS_IndividualCellBalancRa_0147;
            using EMUS_IndividualCellBalancRa_0148 = signals::EMUS_IndividualCellBalancRa_0148;
            using EMUS_IndividualCellBalancRa_0149 = signals::EMUS_IndividualCellBalancRa_0149;

            // Attributes of message 'EMUS_Individual_Cell_Balan__0017'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Mod_Te_0017 {
            public:
            constexpr static uint32_t id = 0x19B5000C;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Individual_Cells_Group_0001 = signals::EMUS_Individual_Cells_Group_0001;
            using EMUS_IndividualCellModTemp__0143 = signals::EMUS_IndividualCellModTemp__0143;
            using EMUS_IndividualCellModTemp__0144 = signals::EMUS_IndividualCellModTemp__0144;
            using EMUS_IndividualCellModTemp__0145 = signals::EMUS_IndividualCellModTemp__0145;
            using EMUS_IndividualCellModTemp__0146 = signals::EMUS_IndividualCellModTemp__0146;
            using EMUS_IndividualCellModTemp__0147 = signals::EMUS_IndividualCellModTemp__0147;
            using EMUS_IndividualCellModTemp__0148 = signals::EMUS_IndividualCellModTemp__0148;
            using EMUS_IndividualCellModTemp__0149 = signals::EMUS_IndividualCellModTemp__0149;

            // Attributes of message 'EMUS_Individual_Cell_Mod_Te_0017'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Individual_Cell_Temp_Ext_B {
            public:
            constexpr static uint32_t id = 0x19B5000E;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_Individual_Cells_Group_0002 = signals::EMUS_Individual_Cells_Group_0002;
            using EMUS_IndividualCellTemperat_0143 = signals::EMUS_IndividualCellTemperat_0143;
            using EMUS_IndividualCellTemperat_0144 = signals::EMUS_IndividualCellTemperat_0144;
            using EMUS_IndividualCellTemperat_0145 = signals::EMUS_IndividualCellTemperat_0145;
            using EMUS_IndividualCellTemperat_0146 = signals::EMUS_IndividualCellTemperat_0146;
            using EMUS_IndividualCellTemperat_0147 = signals::EMUS_IndividualCellTemperat_0147;
            using EMUS_IndividualCellTemperat_0148 = signals::EMUS_IndividualCellTemperat_0148;
            using EMUS_IndividualCellTemperat_0149 = signals::EMUS_IndividualCellTemperat_0149;

            // Attributes of message 'EMUS_Individual_Cell_Temp_Ext_B'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class EMUS_Login_Set_Password_Status_E {
            public:
            constexpr static uint32_t id = 0x19B50403;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = true;

            // Signals
            using EMUS_LoginSetPasswordStatus = signals::EMUS_LoginSetPasswordStatus;

            // Attributes of message 'EMUS_Login_Set_Password_Status_E'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_Voltage {
            public:
            constexpr static uint32_t id = 0x199;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_EMUS_MinCellVoltage = signals::HVTU_EMUS_MinCellVoltage;
            using HVTU_EMUS_AvgCellVoltage = signals::HVTU_EMUS_AvgCellVoltage;
            using HVTU_EMUS_Pack_Voltage = signals::HVTU_EMUS_Pack_Voltage;
            using HVTU_EMUS_MaxCellVoltage = signals::HVTU_EMUS_MaxCellVoltage;

            // Attributes of message 'HVTU_TX_Voltage'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1D9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_Balance_Rate {
            public:
            constexpr static uint32_t id = 0x219;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_EMUS_AvgCellBalanceRate = signals::HVTU_EMUS_AvgCellBalanceRate;
            using HVTU_EMUS_MaxCellBalanceRate = signals::HVTU_EMUS_MaxCellBalanceRate;
            using HVTU_EMUS_MinCellBalanceRate = signals::HVTU_EMUS_MinCellBalanceRate;

            // Attributes of message 'HVTU_TX_Balance_Rate'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x259;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_Cell_Mod_Temp {
            public:
            constexpr static uint32_t id = 0x299;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_EMUS_MaxCellModTemp = signals::HVTU_EMUS_MaxCellModTemp;
            using HVTU_EMUS_AvgCellModTemp = signals::HVTU_EMUS_AvgCellModTemp;
            using HVTU_EMUS_MinCellModTemp = signals::HVTU_EMUS_MinCellModTemp;

            // Attributes of message 'HVTU_TX_Cell_Mod_Temp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2D9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_Cell_Temp {
            public:
            constexpr static uint32_t id = 0x319;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_EMUS_AvgCellTemp = signals::HVTU_EMUS_AvgCellTemp;
            using HVTU_EMUS_MaxCellTemp = signals::HVTU_EMUS_MaxCellTemp;
            using HVTU_EMUS_MinCellTemp = signals::HVTU_EMUS_MinCellTemp;

            // Attributes of message 'HVTU_TX_Cell_Temp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x359;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_Diagnostics {
            public:
            constexpr static uint32_t id = 0x399;
            constexpr static uint8_t dlc = 3;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_EMUS_Diag_BatChargeFinish = signals::HVTU_EMUS_Diag_BatChargeFinish;
            using HVTU_EMUS_Diag_CellBalanceValid = signals::HVTU_EMUS_Diag_CellBalanceValid;
            using HVTU_EMUS_Diag_CellModOverHeat = signals::HVTU_EMUS_Diag_CellModOverHeat;
            using HVTU_EMUS_Diag_CellModTempValid = signals::HVTU_EMUS_Diag_CellModTempValid;
            using HVTU_EMUS_Diag_CellOverHeat = signals::HVTU_EMUS_Diag_CellOverHeat;
            using HVTU_EMUS_Diag_CellTempValid = signals::HVTU_EMUS_Diag_CellTempValid;
            using HVTU_EMUS_Diag_CellVoltValid = signals::HVTU_EMUS_Diag_CellVoltValid;
            using HVTU_EMUS_Diag_ChargeOverCurrent = signals::HVTU_EMUS_Diag_ChargeOverCurrent;
            using HVTU_EMUS_Diag_DchrgOverCurrent = signals::HVTU_EMUS_Diag_DchrgOverCurrent;
            using HVTU_EMUS_Diag_HighCurrent = signals::HVTU_EMUS_Diag_HighCurrent;
            using HVTU_EMUS_Diag_HighTemp = signals::HVTU_EMUS_Diag_HighTemp;
            using HVTU_EMUS_Diag_Leackage = signals::HVTU_EMUS_Diag_Leackage;
            using HVTU_EMUS_Diag_LowVoltage = signals::HVTU_EMUS_Diag_LowVoltage;
            using HVTU_EMUS_Diag_NoCellComm = signals::HVTU_EMUS_Diag_NoCellComm;
            using HVTU_EMUS_Diag_NumOfCellsVal = signals::HVTU_EMUS_Diag_NumOfCellsVal;
            using HVTU_EMUS_Diag_NoCurrentSensor = signals::HVTU_EMUS_Diag_NoCurrentSensor;
            using HVTU_EMUS_Diag_OverVoltage = signals::HVTU_EMUS_Diag_OverVoltage;
            using HVTU_EMUS_Diag_Pack_UnderVoltage = signals::HVTU_EMUS_Diag_Pack_UnderVoltage;
            using HVTU_EMUS_Diag_UnderVoltage = signals::HVTU_EMUS_Diag_UnderVoltage;

            // Attributes of message 'HVTU_TX_Diagnostics'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_Current_SOC {
            public:
            constexpr static uint32_t id = 0x3D9;
            constexpr static uint8_t dlc = 5;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_EMUS_Pack_Current = signals::HVTU_EMUS_Pack_Current;
            using HVTU_EMUS_Pack_Est_Charge = signals::HVTU_EMUS_Pack_Est_Charge;
            using HVTU_EMUS_Pack_SOC = signals::HVTU_EMUS_Pack_SOC;

            // Attributes of message 'HVTU_TX_Current_SOC'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x419;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x459;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x499;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4D9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x519;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x559;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x599;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_SDO_ID = signals::HVTU_SDO_ID;
            using HVTU_SDO_RespCode = signals::HVTU_SDO_RespCode;
            using HVTU_OD_CAN2_DelayedTxMessages = signals::HVTU_OD_CAN2_DelayedTxMessages;
            using HVTU_OD_CAN2_ErrorStatus = signals::HVTU_OD_CAN2_ErrorStatus;
            using HVTU_OD_CAN2_DiscardedTxMessages = signals::HVTU_OD_CAN2_DiscardedTxMessages;
            using HVTU_OD_CAN2_Status = signals::HVTU_OD_CAN2_Status;
            using HVTU_OD_CAN2_Baudrate = signals::HVTU_OD_CAN2_Baudrate;
            using HVTU_OD_CAN2_autoErrorReset = signals::HVTU_OD_CAN2_autoErrorReset;
            using HVTU_OD_CAN2_lastErrorCode = signals::HVTU_OD_CAN2_lastErrorCode;
            using HVTU_OD_CAN2_RxErrCnt = signals::HVTU_OD_CAN2_RxErrCnt;
            using HVTU_OD_CAN2_TxErrCnt = signals::HVTU_OD_CAN2_TxErrCnt;
            using HVTU_OD_CAN1_DelayedTxMessages = signals::HVTU_OD_CAN1_DelayedTxMessages;
            using HVTU_OD_CAN1_ErrorStatus = signals::HVTU_OD_CAN1_ErrorStatus;
            using HVTU_OD_CAN1_DiscardedTxMessages = signals::HVTU_OD_CAN1_DiscardedTxMessages;
            using HVTU_OD_CAN1_Status = signals::HVTU_OD_CAN1_Status;
            using HVTU_OD_CAN1_Baudrate = signals::HVTU_OD_CAN1_Baudrate;
            using HVTU_OD_CAN1_autoErrorReset = signals::HVTU_OD_CAN1_autoErrorReset;
            using HVTU_OD_CAN1_lastErrorCode = signals::HVTU_OD_CAN1_lastErrorCode;
            using HVTU_OD_CAN1_RxErrCnt = signals::HVTU_OD_CAN1_RxErrCnt;
            using HVTU_OD_CAN1_TxErrCnt = signals::HVTU_OD_CAN1_TxErrCnt;
            using HVTU_OD_BuildTime = signals::HVTU_OD_BuildTime;
            using HVTU_OD_BuildDate = signals::HVTU_OD_BuildDate;
            using HVTU_OD_ChipUID2 = signals::HVTU_OD_ChipUID2;
            using HVTU_OD_ChipUID1 = signals::HVTU_OD_ChipUID1;
            using HVTU_OD_SdcOut = signals::HVTU_OD_SdcOut;
            using HVTU_OD_SdcIn = signals::HVTU_OD_SdcIn;
            using HVTU_OD_runtime = signals::HVTU_OD_runtime;
            using HVTU_OD_InputVoltage = signals::HVTU_OD_InputVoltage;
            using HVTU_OD_BoardTemp = signals::HVTU_OD_BoardTemp;
            using HVTU_OD_MemFree = signals::HVTU_OD_MemFree;
            using HVTU_OD_CpuUsage = signals::HVTU_OD_CpuUsage;
            using HVTU_OD_OdEntrySendInterval = signals::HVTU_OD_OdEntrySendInterval;
            using HVTU_OD_SendOdOnBootup = signals::HVTU_OD_SendOdOnBootup;
            using HVTU_OD_HeartbeatInterval = signals::HVTU_OD_HeartbeatInterval;
            using HVTU_OD_DbcVersion = signals::HVTU_OD_DbcVersion;
            using HVTU_OD_StackVersion = signals::HVTU_OD_StackVersion;
            using HVTU_OD_ProtocolVersion = signals::HVTU_OD_ProtocolVersion;
            using HVTU_OD_NodeStatus = signals::HVTU_OD_NodeStatus;
            using HVTU_OD_NodeID = signals::HVTU_OD_NodeID;

            // Attributes of message 'HVTU_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5D9;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_SDO_ID = signals::HVTU_SDO_ID;
            using HVTU_OD_CAN2_DelayedTxMessages = signals::HVTU_OD_CAN2_DelayedTxMessages;
            using HVTU_OD_CAN2_ErrorStatus = signals::HVTU_OD_CAN2_ErrorStatus;
            using HVTU_OD_CAN2_DiscardedTxMessages = signals::HVTU_OD_CAN2_DiscardedTxMessages;
            using HVTU_OD_CAN2_Status = signals::HVTU_OD_CAN2_Status;
            using HVTU_OD_CAN2_Baudrate = signals::HVTU_OD_CAN2_Baudrate;
            using HVTU_OD_CAN2_autoErrorReset = signals::HVTU_OD_CAN2_autoErrorReset;
            using HVTU_OD_CAN2_lastErrorCode = signals::HVTU_OD_CAN2_lastErrorCode;
            using HVTU_OD_CAN2_RxErrCnt = signals::HVTU_OD_CAN2_RxErrCnt;
            using HVTU_OD_CAN2_TxErrCnt = signals::HVTU_OD_CAN2_TxErrCnt;
            using HVTU_OD_CAN1_DelayedTxMessages = signals::HVTU_OD_CAN1_DelayedTxMessages;
            using HVTU_OD_CAN1_ErrorStatus = signals::HVTU_OD_CAN1_ErrorStatus;
            using HVTU_OD_CAN1_DiscardedTxMessages = signals::HVTU_OD_CAN1_DiscardedTxMessages;
            using HVTU_OD_CAN1_Status = signals::HVTU_OD_CAN1_Status;
            using HVTU_OD_CAN1_Baudrate = signals::HVTU_OD_CAN1_Baudrate;
            using HVTU_OD_CAN1_autoErrorReset = signals::HVTU_OD_CAN1_autoErrorReset;
            using HVTU_OD_CAN1_lastErrorCode = signals::HVTU_OD_CAN1_lastErrorCode;
            using HVTU_OD_CAN1_RxErrCnt = signals::HVTU_OD_CAN1_RxErrCnt;
            using HVTU_OD_CAN1_TxErrCnt = signals::HVTU_OD_CAN1_TxErrCnt;
            using HVTU_OD_BuildTime = signals::HVTU_OD_BuildTime;
            using HVTU_OD_BuildDate = signals::HVTU_OD_BuildDate;
            using HVTU_OD_ChipUID2 = signals::HVTU_OD_ChipUID2;
            using HVTU_OD_ChipUID1 = signals::HVTU_OD_ChipUID1;
            using HVTU_OD_SdcOut = signals::HVTU_OD_SdcOut;
            using HVTU_OD_SdcIn = signals::HVTU_OD_SdcIn;
            using HVTU_OD_runtime = signals::HVTU_OD_runtime;
            using HVTU_OD_InputVoltage = signals::HVTU_OD_InputVoltage;
            using HVTU_OD_BoardTemp = signals::HVTU_OD_BoardTemp;
            using HVTU_OD_MemFree = signals::HVTU_OD_MemFree;
            using HVTU_OD_CpuUsage = signals::HVTU_OD_CpuUsage;
            using HVTU_OD_OdEntrySendInterval = signals::HVTU_OD_OdEntrySendInterval;
            using HVTU_OD_SendOdOnBootup = signals::HVTU_OD_SendOdOnBootup;
            using HVTU_OD_HeartbeatInterval = signals::HVTU_OD_HeartbeatInterval;
            using HVTU_OD_DbcVersion = signals::HVTU_OD_DbcVersion;
            using HVTU_OD_StackVersion = signals::HVTU_OD_StackVersion;
            using HVTU_OD_ProtocolVersion = signals::HVTU_OD_ProtocolVersion;
            using HVTU_OD_NodeStatus = signals::HVTU_OD_NodeStatus;
            using HVTU_OD_NodeID = signals::HVTU_OD_NodeID;

            // Attributes of message 'HVTU_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x619;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_SDO_ID = signals::HVTU_SDO_ID;

            // Attributes of message 'HVTU_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_Heartbeat {
            public:
            constexpr static uint32_t id = 0x719;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using HVTU_NodeState = signals::HVTU_NodeState;

            // Attributes of message 'HVTU_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_BTL_TX {
            public:
            constexpr static uint32_t id = 0x759;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class HVTU_BTL_RX {
            public:
            constexpr static uint32_t id = 0x799;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'HVTU_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_EMCY {
            public:
            constexpr static uint32_t id = 0xA2;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_W0_OtherWarning = signals::TelemetryNode_W0_OtherWarning;
            using TelemetryNode_E0_OtherError = signals::TelemetryNode_E0_OtherError;

            // Attributes of message 'TelemetryNode_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1A2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_RX_Shutdown {
            public:
            constexpr static uint32_t id = 0x1E2;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_RX_Shutdown_ = signals::TelemetryNode_RX_Shutdown;

            // Attributes of message 'TelemetryNode_RX_Shutdown'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x222;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x262;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2A2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2E2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x322;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x362;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3A2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3E2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x422;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x462;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4A2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4E2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_CAN_Error {
            public:
            constexpr static uint32_t id = 0x522;
            constexpr static uint8_t dlc = 6;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_CAN1_RxErrors = signals::TelemetryNode_CAN1_RxErrors;
            using TelemetryNode_CAN1_TxErrors = signals::TelemetryNode_CAN1_TxErrors;
            using TelemetryNode_CAN2_RxErrors = signals::TelemetryNode_CAN2_RxErrors;
            using TelemetryNode_CAN2_TxErrors = signals::TelemetryNode_CAN2_TxErrors;

            // Attributes of message 'TelemetryNode_TX_CAN_Error'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_TX_Info {
            public:
            constexpr static uint32_t id = 0x562;
            constexpr static uint8_t dlc = 7;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_CpuUsage = signals::TelemetryNode_CpuUsage;
            using TelemetryNode_Temperature = signals::TelemetryNode_Temperature;
            using TelemetryNode_Time = signals::TelemetryNode_Time;
            using TelemetryNode_Date = signals::TelemetryNode_Date;

            // Attributes of message 'TelemetryNode_TX_Info'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5A2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_SDO_ID = signals::TelemetryNode_SDO_ID;
            using TelemetryNode_SDO_RespCode = signals::TelemetryNode_SDO_RespCode;
            using TelemetryNode_OD_CanRestart = signals::TelemetryNode_OD_CanRestart;
            using TelemetryNode_OD_Reboot = signals::TelemetryNode_OD_Reboot;
            using TelemetryNode_OD_Shutdown = signals::TelemetryNode_OD_Shutdown;
            using TelemetryNode_OD_CAN2_DelayedTxMessages = signals::TelemetryNode_OD_CAN2_DelayedTxMessages;
            using TelemetryNode_OD_CAN2_ErrorStatus = signals::TelemetryNode_OD_CAN2_ErrorStatus;
            using TelemetryNode_OD_CAN2_DiscardedTxMessages = signals::TelemetryNode_OD_CAN2_DiscardedTxMessages;
            using TelemetryNode_OD_CAN2_Status = signals::TelemetryNode_OD_CAN2_Status;
            using TelemetryNode_OD_CAN2_Baudrate = signals::TelemetryNode_OD_CAN2_Baudrate;
            using TelemetryNode_OD_CAN2_autoErrorReset = signals::TelemetryNode_OD_CAN2_autoErrorReset;
            using TelemetryNode_OD_CAN2_lastErrorCode = signals::TelemetryNode_OD_CAN2_lastErrorCode;
            using TelemetryNode_OD_CAN2_RxErrCnt = signals::TelemetryNode_OD_CAN2_RxErrCnt;
            using TelemetryNode_OD_CAN2_TxErrCnt = signals::TelemetryNode_OD_CAN2_TxErrCnt;
            using TelemetryNode_OD_CAN1_DelayedTxMessages = signals::TelemetryNode_OD_CAN1_DelayedTxMessages;
            using TelemetryNode_OD_CAN1_ErrorStatus = signals::TelemetryNode_OD_CAN1_ErrorStatus;
            using TelemetryNode_OD_CAN1_DiscardedTxMessages = signals::TelemetryNode_OD_CAN1_DiscardedTxMessages;
            using TelemetryNode_OD_CAN1_Status = signals::TelemetryNode_OD_CAN1_Status;
            using TelemetryNode_OD_CAN1_Baudrate = signals::TelemetryNode_OD_CAN1_Baudrate;
            using TelemetryNode_OD_CAN1_autoErrorReset = signals::TelemetryNode_OD_CAN1_autoErrorReset;
            using TelemetryNode_OD_CAN1_lastErrorCode = signals::TelemetryNode_OD_CAN1_lastErrorCode;
            using TelemetryNode_OD_CAN1_RxErrCnt = signals::TelemetryNode_OD_CAN1_RxErrCnt;
            using TelemetryNode_OD_CAN1_TxErrCnt = signals::TelemetryNode_OD_CAN1_TxErrCnt;
            using TelemetryNode_OD_BuildTime = signals::TelemetryNode_OD_BuildTime;
            using TelemetryNode_OD_BuildDate = signals::TelemetryNode_OD_BuildDate;
            using TelemetryNode_OD_ChipUID2 = signals::TelemetryNode_OD_ChipUID2;
            using TelemetryNode_OD_ChipUID1 = signals::TelemetryNode_OD_ChipUID1;
            using TelemetryNode_OD_SdcOut = signals::TelemetryNode_OD_SdcOut;
            using TelemetryNode_OD_SdcIn = signals::TelemetryNode_OD_SdcIn;
            using TelemetryNode_OD_runtime = signals::TelemetryNode_OD_runtime;
            using TelemetryNode_OD_InputVoltage = signals::TelemetryNode_OD_InputVoltage;
            using TelemetryNode_OD_BoardTemp = signals::TelemetryNode_OD_BoardTemp;
            using TelemetryNode_OD_MemFree = signals::TelemetryNode_OD_MemFree;
            using TelemetryNode_OD_CpuUsage = signals::TelemetryNode_OD_CpuUsage;
            using TelemetryNode_OD_OdEntrySendInterval = signals::TelemetryNode_OD_OdEntrySendInterval;
            using TelemetryNode_OD_SendOdOnBootup = signals::TelemetryNode_OD_SendOdOnBootup;
            using TelemetryNode_OD_HeartbeatInterval = signals::TelemetryNode_OD_HeartbeatInterval;
            using TelemetryNode_OD_DbcVersion = signals::TelemetryNode_OD_DbcVersion;
            using TelemetryNode_OD_StackVersion = signals::TelemetryNode_OD_StackVersion;
            using TelemetryNode_OD_ProtocolVersion = signals::TelemetryNode_OD_ProtocolVersion;
            using TelemetryNode_OD_NodeStatus = signals::TelemetryNode_OD_NodeStatus;
            using TelemetryNode_OD_NodeID = signals::TelemetryNode_OD_NodeID;

            // Attributes of message 'TelemetryNode_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5E2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_SDO_ID = signals::TelemetryNode_SDO_ID;
            using TelemetryNode_OD_CanRestart = signals::TelemetryNode_OD_CanRestart;
            using TelemetryNode_OD_Reboot = signals::TelemetryNode_OD_Reboot;
            using TelemetryNode_OD_Shutdown = signals::TelemetryNode_OD_Shutdown;
            using TelemetryNode_OD_CAN2_DelayedTxMessages = signals::TelemetryNode_OD_CAN2_DelayedTxMessages;
            using TelemetryNode_OD_CAN2_ErrorStatus = signals::TelemetryNode_OD_CAN2_ErrorStatus;
            using TelemetryNode_OD_CAN2_DiscardedTxMessages = signals::TelemetryNode_OD_CAN2_DiscardedTxMessages;
            using TelemetryNode_OD_CAN2_Status = signals::TelemetryNode_OD_CAN2_Status;
            using TelemetryNode_OD_CAN2_Baudrate = signals::TelemetryNode_OD_CAN2_Baudrate;
            using TelemetryNode_OD_CAN2_autoErrorReset = signals::TelemetryNode_OD_CAN2_autoErrorReset;
            using TelemetryNode_OD_CAN2_lastErrorCode = signals::TelemetryNode_OD_CAN2_lastErrorCode;
            using TelemetryNode_OD_CAN2_RxErrCnt = signals::TelemetryNode_OD_CAN2_RxErrCnt;
            using TelemetryNode_OD_CAN2_TxErrCnt = signals::TelemetryNode_OD_CAN2_TxErrCnt;
            using TelemetryNode_OD_CAN1_DelayedTxMessages = signals::TelemetryNode_OD_CAN1_DelayedTxMessages;
            using TelemetryNode_OD_CAN1_ErrorStatus = signals::TelemetryNode_OD_CAN1_ErrorStatus;
            using TelemetryNode_OD_CAN1_DiscardedTxMessages = signals::TelemetryNode_OD_CAN1_DiscardedTxMessages;
            using TelemetryNode_OD_CAN1_Status = signals::TelemetryNode_OD_CAN1_Status;
            using TelemetryNode_OD_CAN1_Baudrate = signals::TelemetryNode_OD_CAN1_Baudrate;
            using TelemetryNode_OD_CAN1_autoErrorReset = signals::TelemetryNode_OD_CAN1_autoErrorReset;
            using TelemetryNode_OD_CAN1_lastErrorCode = signals::TelemetryNode_OD_CAN1_lastErrorCode;
            using TelemetryNode_OD_CAN1_RxErrCnt = signals::TelemetryNode_OD_CAN1_RxErrCnt;
            using TelemetryNode_OD_CAN1_TxErrCnt = signals::TelemetryNode_OD_CAN1_TxErrCnt;
            using TelemetryNode_OD_BuildTime = signals::TelemetryNode_OD_BuildTime;
            using TelemetryNode_OD_BuildDate = signals::TelemetryNode_OD_BuildDate;
            using TelemetryNode_OD_ChipUID2 = signals::TelemetryNode_OD_ChipUID2;
            using TelemetryNode_OD_ChipUID1 = signals::TelemetryNode_OD_ChipUID1;
            using TelemetryNode_OD_SdcOut = signals::TelemetryNode_OD_SdcOut;
            using TelemetryNode_OD_SdcIn = signals::TelemetryNode_OD_SdcIn;
            using TelemetryNode_OD_runtime = signals::TelemetryNode_OD_runtime;
            using TelemetryNode_OD_InputVoltage = signals::TelemetryNode_OD_InputVoltage;
            using TelemetryNode_OD_BoardTemp = signals::TelemetryNode_OD_BoardTemp;
            using TelemetryNode_OD_MemFree = signals::TelemetryNode_OD_MemFree;
            using TelemetryNode_OD_CpuUsage = signals::TelemetryNode_OD_CpuUsage;
            using TelemetryNode_OD_OdEntrySendInterval = signals::TelemetryNode_OD_OdEntrySendInterval;
            using TelemetryNode_OD_SendOdOnBootup = signals::TelemetryNode_OD_SendOdOnBootup;
            using TelemetryNode_OD_HeartbeatInterval = signals::TelemetryNode_OD_HeartbeatInterval;
            using TelemetryNode_OD_DbcVersion = signals::TelemetryNode_OD_DbcVersion;
            using TelemetryNode_OD_StackVersion = signals::TelemetryNode_OD_StackVersion;
            using TelemetryNode_OD_ProtocolVersion = signals::TelemetryNode_OD_ProtocolVersion;
            using TelemetryNode_OD_NodeStatus = signals::TelemetryNode_OD_NodeStatus;
            using TelemetryNode_OD_NodeID = signals::TelemetryNode_OD_NodeID;

            // Attributes of message 'TelemetryNode_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x622;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_SDO_ID = signals::TelemetryNode_SDO_ID;

            // Attributes of message 'TelemetryNode_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_Heartbeat {
            public:
            constexpr static uint32_t id = 0x722;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using TelemetryNode_NodeState = signals::TelemetryNode_NodeState;

            // Attributes of message 'TelemetryNode_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_BTL_TX {
            public:
            constexpr static uint32_t id = 0x762;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class TelemetryNode_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7A2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'TelemetryNode_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_EMCY {
            public:
            constexpr static uint32_t id = 0xA1;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB1_W0_OtherWarning = signals::MDB1_W0_OtherWarning;
            using MDB1_E0_OtherError = signals::MDB1_E0_OtherError;

            // Attributes of message 'MDB1_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1A1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1E1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x221;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x261;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2A1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2E1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x321;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x361;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3A1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3E1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x421;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x461;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4A1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4E1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x521;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x561;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5A1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB1_SDO_ID = signals::MDB1_SDO_ID;
            using MDB1_SDO_RespCode = signals::MDB1_SDO_RespCode;
            using MDB1_OD_CAN2_DelayedTxMessages = signals::MDB1_OD_CAN2_DelayedTxMessages;
            using MDB1_OD_CAN2_ErrorStatus = signals::MDB1_OD_CAN2_ErrorStatus;
            using MDB1_OD_CAN2_DiscardedTxMessages = signals::MDB1_OD_CAN2_DiscardedTxMessages;
            using MDB1_OD_CAN2_Status = signals::MDB1_OD_CAN2_Status;
            using MDB1_OD_CAN2_Baudrate = signals::MDB1_OD_CAN2_Baudrate;
            using MDB1_OD_CAN2_autoErrorReset = signals::MDB1_OD_CAN2_autoErrorReset;
            using MDB1_OD_CAN2_lastErrorCode = signals::MDB1_OD_CAN2_lastErrorCode;
            using MDB1_OD_CAN2_RxErrCnt = signals::MDB1_OD_CAN2_RxErrCnt;
            using MDB1_OD_CAN2_TxErrCnt = signals::MDB1_OD_CAN2_TxErrCnt;
            using MDB1_OD_CAN1_DelayedTxMessages = signals::MDB1_OD_CAN1_DelayedTxMessages;
            using MDB1_OD_CAN1_ErrorStatus = signals::MDB1_OD_CAN1_ErrorStatus;
            using MDB1_OD_CAN1_DiscardedTxMessages = signals::MDB1_OD_CAN1_DiscardedTxMessages;
            using MDB1_OD_CAN1_Status = signals::MDB1_OD_CAN1_Status;
            using MDB1_OD_CAN1_Baudrate = signals::MDB1_OD_CAN1_Baudrate;
            using MDB1_OD_CAN1_autoErrorReset = signals::MDB1_OD_CAN1_autoErrorReset;
            using MDB1_OD_CAN1_lastErrorCode = signals::MDB1_OD_CAN1_lastErrorCode;
            using MDB1_OD_CAN1_RxErrCnt = signals::MDB1_OD_CAN1_RxErrCnt;
            using MDB1_OD_CAN1_TxErrCnt = signals::MDB1_OD_CAN1_TxErrCnt;
            using MDB1_OD_BuildTime = signals::MDB1_OD_BuildTime;
            using MDB1_OD_BuildDate = signals::MDB1_OD_BuildDate;
            using MDB1_OD_ChipUID2 = signals::MDB1_OD_ChipUID2;
            using MDB1_OD_ChipUID1 = signals::MDB1_OD_ChipUID1;
            using MDB1_OD_SdcOut = signals::MDB1_OD_SdcOut;
            using MDB1_OD_SdcIn = signals::MDB1_OD_SdcIn;
            using MDB1_OD_runtime = signals::MDB1_OD_runtime;
            using MDB1_OD_InputVoltage = signals::MDB1_OD_InputVoltage;
            using MDB1_OD_BoardTemp = signals::MDB1_OD_BoardTemp;
            using MDB1_OD_MemFree = signals::MDB1_OD_MemFree;
            using MDB1_OD_CpuUsage = signals::MDB1_OD_CpuUsage;
            using MDB1_OD_OdEntrySendInterval = signals::MDB1_OD_OdEntrySendInterval;
            using MDB1_OD_SendOdOnBootup = signals::MDB1_OD_SendOdOnBootup;
            using MDB1_OD_HeartbeatInterval = signals::MDB1_OD_HeartbeatInterval;
            using MDB1_OD_DbcVersion = signals::MDB1_OD_DbcVersion;
            using MDB1_OD_StackVersion = signals::MDB1_OD_StackVersion;
            using MDB1_OD_ProtocolVersion = signals::MDB1_OD_ProtocolVersion;
            using MDB1_OD_NodeStatus = signals::MDB1_OD_NodeStatus;
            using MDB1_OD_NodeID = signals::MDB1_OD_NodeID;

            // Attributes of message 'MDB1_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5E1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB1_SDO_ID = signals::MDB1_SDO_ID;
            using MDB1_OD_CAN2_DelayedTxMessages = signals::MDB1_OD_CAN2_DelayedTxMessages;
            using MDB1_OD_CAN2_ErrorStatus = signals::MDB1_OD_CAN2_ErrorStatus;
            using MDB1_OD_CAN2_DiscardedTxMessages = signals::MDB1_OD_CAN2_DiscardedTxMessages;
            using MDB1_OD_CAN2_Status = signals::MDB1_OD_CAN2_Status;
            using MDB1_OD_CAN2_Baudrate = signals::MDB1_OD_CAN2_Baudrate;
            using MDB1_OD_CAN2_autoErrorReset = signals::MDB1_OD_CAN2_autoErrorReset;
            using MDB1_OD_CAN2_lastErrorCode = signals::MDB1_OD_CAN2_lastErrorCode;
            using MDB1_OD_CAN2_RxErrCnt = signals::MDB1_OD_CAN2_RxErrCnt;
            using MDB1_OD_CAN2_TxErrCnt = signals::MDB1_OD_CAN2_TxErrCnt;
            using MDB1_OD_CAN1_DelayedTxMessages = signals::MDB1_OD_CAN1_DelayedTxMessages;
            using MDB1_OD_CAN1_ErrorStatus = signals::MDB1_OD_CAN1_ErrorStatus;
            using MDB1_OD_CAN1_DiscardedTxMessages = signals::MDB1_OD_CAN1_DiscardedTxMessages;
            using MDB1_OD_CAN1_Status = signals::MDB1_OD_CAN1_Status;
            using MDB1_OD_CAN1_Baudrate = signals::MDB1_OD_CAN1_Baudrate;
            using MDB1_OD_CAN1_autoErrorReset = signals::MDB1_OD_CAN1_autoErrorReset;
            using MDB1_OD_CAN1_lastErrorCode = signals::MDB1_OD_CAN1_lastErrorCode;
            using MDB1_OD_CAN1_RxErrCnt = signals::MDB1_OD_CAN1_RxErrCnt;
            using MDB1_OD_CAN1_TxErrCnt = signals::MDB1_OD_CAN1_TxErrCnt;
            using MDB1_OD_BuildTime = signals::MDB1_OD_BuildTime;
            using MDB1_OD_BuildDate = signals::MDB1_OD_BuildDate;
            using MDB1_OD_ChipUID2 = signals::MDB1_OD_ChipUID2;
            using MDB1_OD_ChipUID1 = signals::MDB1_OD_ChipUID1;
            using MDB1_OD_SdcOut = signals::MDB1_OD_SdcOut;
            using MDB1_OD_SdcIn = signals::MDB1_OD_SdcIn;
            using MDB1_OD_runtime = signals::MDB1_OD_runtime;
            using MDB1_OD_InputVoltage = signals::MDB1_OD_InputVoltage;
            using MDB1_OD_BoardTemp = signals::MDB1_OD_BoardTemp;
            using MDB1_OD_MemFree = signals::MDB1_OD_MemFree;
            using MDB1_OD_CpuUsage = signals::MDB1_OD_CpuUsage;
            using MDB1_OD_OdEntrySendInterval = signals::MDB1_OD_OdEntrySendInterval;
            using MDB1_OD_SendOdOnBootup = signals::MDB1_OD_SendOdOnBootup;
            using MDB1_OD_HeartbeatInterval = signals::MDB1_OD_HeartbeatInterval;
            using MDB1_OD_DbcVersion = signals::MDB1_OD_DbcVersion;
            using MDB1_OD_StackVersion = signals::MDB1_OD_StackVersion;
            using MDB1_OD_ProtocolVersion = signals::MDB1_OD_ProtocolVersion;
            using MDB1_OD_NodeStatus = signals::MDB1_OD_NodeStatus;
            using MDB1_OD_NodeID = signals::MDB1_OD_NodeID;

            // Attributes of message 'MDB1_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x621;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB1_SDO_ID = signals::MDB1_SDO_ID;

            // Attributes of message 'MDB1_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_Heartbeat {
            public:
            constexpr static uint32_t id = 0x721;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB1_NodeState = signals::MDB1_NodeState;

            // Attributes of message 'MDB1_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_BTL_TX {
            public:
            constexpr static uint32_t id = 0x761;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB1_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7A1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB1_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_EMCY {
            public:
            constexpr static uint32_t id = 0xA3;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB2_W0_OtherWarning = signals::MDB2_W0_OtherWarning;
            using MDB2_E0_OtherError = signals::MDB2_E0_OtherError;

            // Attributes of message 'MDB2_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1A3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1E3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x223;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x263;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2A3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2E3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x323;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x363;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3A3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3E3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x423;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x463;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4A3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4E3;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x523;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x563;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5A3;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB2_SDO_ID = signals::MDB2_SDO_ID;
            using MDB2_SDO_RespCode = signals::MDB2_SDO_RespCode;
            using MDB2_OD_CAN2_DelayedTxMessages = signals::MDB2_OD_CAN2_DelayedTxMessages;
            using MDB2_OD_CAN2_ErrorStatus = signals::MDB2_OD_CAN2_ErrorStatus;
            using MDB2_OD_CAN2_DiscardedTxMessages = signals::MDB2_OD_CAN2_DiscardedTxMessages;
            using MDB2_OD_CAN2_Status = signals::MDB2_OD_CAN2_Status;
            using MDB2_OD_CAN2_Baudrate = signals::MDB2_OD_CAN2_Baudrate;
            using MDB2_OD_CAN2_autoErrorReset = signals::MDB2_OD_CAN2_autoErrorReset;
            using MDB2_OD_CAN2_lastErrorCode = signals::MDB2_OD_CAN2_lastErrorCode;
            using MDB2_OD_CAN2_RxErrCnt = signals::MDB2_OD_CAN2_RxErrCnt;
            using MDB2_OD_CAN2_TxErrCnt = signals::MDB2_OD_CAN2_TxErrCnt;
            using MDB2_OD_CAN1_DelayedTxMessages = signals::MDB2_OD_CAN1_DelayedTxMessages;
            using MDB2_OD_CAN1_ErrorStatus = signals::MDB2_OD_CAN1_ErrorStatus;
            using MDB2_OD_CAN1_DiscardedTxMessages = signals::MDB2_OD_CAN1_DiscardedTxMessages;
            using MDB2_OD_CAN1_Status = signals::MDB2_OD_CAN1_Status;
            using MDB2_OD_CAN1_Baudrate = signals::MDB2_OD_CAN1_Baudrate;
            using MDB2_OD_CAN1_autoErrorReset = signals::MDB2_OD_CAN1_autoErrorReset;
            using MDB2_OD_CAN1_lastErrorCode = signals::MDB2_OD_CAN1_lastErrorCode;
            using MDB2_OD_CAN1_RxErrCnt = signals::MDB2_OD_CAN1_RxErrCnt;
            using MDB2_OD_CAN1_TxErrCnt = signals::MDB2_OD_CAN1_TxErrCnt;
            using MDB2_OD_BuildTime = signals::MDB2_OD_BuildTime;
            using MDB2_OD_BuildDate = signals::MDB2_OD_BuildDate;
            using MDB2_OD_ChipUID2 = signals::MDB2_OD_ChipUID2;
            using MDB2_OD_ChipUID1 = signals::MDB2_OD_ChipUID1;
            using MDB2_OD_SdcOut = signals::MDB2_OD_SdcOut;
            using MDB2_OD_SdcIn = signals::MDB2_OD_SdcIn;
            using MDB2_OD_runtime = signals::MDB2_OD_runtime;
            using MDB2_OD_InputVoltage = signals::MDB2_OD_InputVoltage;
            using MDB2_OD_BoardTemp = signals::MDB2_OD_BoardTemp;
            using MDB2_OD_MemFree = signals::MDB2_OD_MemFree;
            using MDB2_OD_CpuUsage = signals::MDB2_OD_CpuUsage;
            using MDB2_OD_OdEntrySendInterval = signals::MDB2_OD_OdEntrySendInterval;
            using MDB2_OD_SendOdOnBootup = signals::MDB2_OD_SendOdOnBootup;
            using MDB2_OD_HeartbeatInterval = signals::MDB2_OD_HeartbeatInterval;
            using MDB2_OD_DbcVersion = signals::MDB2_OD_DbcVersion;
            using MDB2_OD_StackVersion = signals::MDB2_OD_StackVersion;
            using MDB2_OD_ProtocolVersion = signals::MDB2_OD_ProtocolVersion;
            using MDB2_OD_NodeStatus = signals::MDB2_OD_NodeStatus;
            using MDB2_OD_NodeID = signals::MDB2_OD_NodeID;

            // Attributes of message 'MDB2_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5E3;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB2_SDO_ID = signals::MDB2_SDO_ID;
            using MDB2_OD_CAN2_DelayedTxMessages = signals::MDB2_OD_CAN2_DelayedTxMessages;
            using MDB2_OD_CAN2_ErrorStatus = signals::MDB2_OD_CAN2_ErrorStatus;
            using MDB2_OD_CAN2_DiscardedTxMessages = signals::MDB2_OD_CAN2_DiscardedTxMessages;
            using MDB2_OD_CAN2_Status = signals::MDB2_OD_CAN2_Status;
            using MDB2_OD_CAN2_Baudrate = signals::MDB2_OD_CAN2_Baudrate;
            using MDB2_OD_CAN2_autoErrorReset = signals::MDB2_OD_CAN2_autoErrorReset;
            using MDB2_OD_CAN2_lastErrorCode = signals::MDB2_OD_CAN2_lastErrorCode;
            using MDB2_OD_CAN2_RxErrCnt = signals::MDB2_OD_CAN2_RxErrCnt;
            using MDB2_OD_CAN2_TxErrCnt = signals::MDB2_OD_CAN2_TxErrCnt;
            using MDB2_OD_CAN1_DelayedTxMessages = signals::MDB2_OD_CAN1_DelayedTxMessages;
            using MDB2_OD_CAN1_ErrorStatus = signals::MDB2_OD_CAN1_ErrorStatus;
            using MDB2_OD_CAN1_DiscardedTxMessages = signals::MDB2_OD_CAN1_DiscardedTxMessages;
            using MDB2_OD_CAN1_Status = signals::MDB2_OD_CAN1_Status;
            using MDB2_OD_CAN1_Baudrate = signals::MDB2_OD_CAN1_Baudrate;
            using MDB2_OD_CAN1_autoErrorReset = signals::MDB2_OD_CAN1_autoErrorReset;
            using MDB2_OD_CAN1_lastErrorCode = signals::MDB2_OD_CAN1_lastErrorCode;
            using MDB2_OD_CAN1_RxErrCnt = signals::MDB2_OD_CAN1_RxErrCnt;
            using MDB2_OD_CAN1_TxErrCnt = signals::MDB2_OD_CAN1_TxErrCnt;
            using MDB2_OD_BuildTime = signals::MDB2_OD_BuildTime;
            using MDB2_OD_BuildDate = signals::MDB2_OD_BuildDate;
            using MDB2_OD_ChipUID2 = signals::MDB2_OD_ChipUID2;
            using MDB2_OD_ChipUID1 = signals::MDB2_OD_ChipUID1;
            using MDB2_OD_SdcOut = signals::MDB2_OD_SdcOut;
            using MDB2_OD_SdcIn = signals::MDB2_OD_SdcIn;
            using MDB2_OD_runtime = signals::MDB2_OD_runtime;
            using MDB2_OD_InputVoltage = signals::MDB2_OD_InputVoltage;
            using MDB2_OD_BoardTemp = signals::MDB2_OD_BoardTemp;
            using MDB2_OD_MemFree = signals::MDB2_OD_MemFree;
            using MDB2_OD_CpuUsage = signals::MDB2_OD_CpuUsage;
            using MDB2_OD_OdEntrySendInterval = signals::MDB2_OD_OdEntrySendInterval;
            using MDB2_OD_SendOdOnBootup = signals::MDB2_OD_SendOdOnBootup;
            using MDB2_OD_HeartbeatInterval = signals::MDB2_OD_HeartbeatInterval;
            using MDB2_OD_DbcVersion = signals::MDB2_OD_DbcVersion;
            using MDB2_OD_StackVersion = signals::MDB2_OD_StackVersion;
            using MDB2_OD_ProtocolVersion = signals::MDB2_OD_ProtocolVersion;
            using MDB2_OD_NodeStatus = signals::MDB2_OD_NodeStatus;
            using MDB2_OD_NodeID = signals::MDB2_OD_NodeID;

            // Attributes of message 'MDB2_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x623;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB2_SDO_ID = signals::MDB2_SDO_ID;

            // Attributes of message 'MDB2_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_Heartbeat {
            public:
            constexpr static uint32_t id = 0x723;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB2_NodeState = signals::MDB2_NodeState;

            // Attributes of message 'MDB2_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_BTL_TX {
            public:
            constexpr static uint32_t id = 0x763;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB2_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7A3;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB2_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_EMCY {
            public:
            constexpr static uint32_t id = 0xA7;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB3_W0_OtherWarning = signals::MDB3_W0_OtherWarning;
            using MDB3_E0_OtherError = signals::MDB3_E0_OtherError;

            // Attributes of message 'MDB3_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1A7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1E7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x227;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x267;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2A7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2E7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x327;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x367;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3A7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3E7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x427;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x467;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4A7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4E7;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x527;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x567;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5A7;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB3_SDO_ID = signals::MDB3_SDO_ID;
            using MDB3_SDO_RespCode = signals::MDB3_SDO_RespCode;
            using MDB3_OD_CAN2_DelayedTxMessages = signals::MDB3_OD_CAN2_DelayedTxMessages;
            using MDB3_OD_CAN2_ErrorStatus = signals::MDB3_OD_CAN2_ErrorStatus;
            using MDB3_OD_CAN2_DiscardedTxMessages = signals::MDB3_OD_CAN2_DiscardedTxMessages;
            using MDB3_OD_CAN2_Status = signals::MDB3_OD_CAN2_Status;
            using MDB3_OD_CAN2_Baudrate = signals::MDB3_OD_CAN2_Baudrate;
            using MDB3_OD_CAN2_autoErrorReset = signals::MDB3_OD_CAN2_autoErrorReset;
            using MDB3_OD_CAN2_lastErrorCode = signals::MDB3_OD_CAN2_lastErrorCode;
            using MDB3_OD_CAN2_RxErrCnt = signals::MDB3_OD_CAN2_RxErrCnt;
            using MDB3_OD_CAN2_TxErrCnt = signals::MDB3_OD_CAN2_TxErrCnt;
            using MDB3_OD_CAN1_DelayedTxMessages = signals::MDB3_OD_CAN1_DelayedTxMessages;
            using MDB3_OD_CAN1_ErrorStatus = signals::MDB3_OD_CAN1_ErrorStatus;
            using MDB3_OD_CAN1_DiscardedTxMessages = signals::MDB3_OD_CAN1_DiscardedTxMessages;
            using MDB3_OD_CAN1_Status = signals::MDB3_OD_CAN1_Status;
            using MDB3_OD_CAN1_Baudrate = signals::MDB3_OD_CAN1_Baudrate;
            using MDB3_OD_CAN1_autoErrorReset = signals::MDB3_OD_CAN1_autoErrorReset;
            using MDB3_OD_CAN1_lastErrorCode = signals::MDB3_OD_CAN1_lastErrorCode;
            using MDB3_OD_CAN1_RxErrCnt = signals::MDB3_OD_CAN1_RxErrCnt;
            using MDB3_OD_CAN1_TxErrCnt = signals::MDB3_OD_CAN1_TxErrCnt;
            using MDB3_OD_BuildTime = signals::MDB3_OD_BuildTime;
            using MDB3_OD_BuildDate = signals::MDB3_OD_BuildDate;
            using MDB3_OD_ChipUID2 = signals::MDB3_OD_ChipUID2;
            using MDB3_OD_ChipUID1 = signals::MDB3_OD_ChipUID1;
            using MDB3_OD_SdcOut = signals::MDB3_OD_SdcOut;
            using MDB3_OD_SdcIn = signals::MDB3_OD_SdcIn;
            using MDB3_OD_runtime = signals::MDB3_OD_runtime;
            using MDB3_OD_InputVoltage = signals::MDB3_OD_InputVoltage;
            using MDB3_OD_BoardTemp = signals::MDB3_OD_BoardTemp;
            using MDB3_OD_MemFree = signals::MDB3_OD_MemFree;
            using MDB3_OD_CpuUsage = signals::MDB3_OD_CpuUsage;
            using MDB3_OD_OdEntrySendInterval = signals::MDB3_OD_OdEntrySendInterval;
            using MDB3_OD_SendOdOnBootup = signals::MDB3_OD_SendOdOnBootup;
            using MDB3_OD_HeartbeatInterval = signals::MDB3_OD_HeartbeatInterval;
            using MDB3_OD_DbcVersion = signals::MDB3_OD_DbcVersion;
            using MDB3_OD_StackVersion = signals::MDB3_OD_StackVersion;
            using MDB3_OD_ProtocolVersion = signals::MDB3_OD_ProtocolVersion;
            using MDB3_OD_NodeStatus = signals::MDB3_OD_NodeStatus;
            using MDB3_OD_NodeID = signals::MDB3_OD_NodeID;

            // Attributes of message 'MDB3_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5E7;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB3_SDO_ID = signals::MDB3_SDO_ID;
            using MDB3_OD_CAN2_DelayedTxMessages = signals::MDB3_OD_CAN2_DelayedTxMessages;
            using MDB3_OD_CAN2_ErrorStatus = signals::MDB3_OD_CAN2_ErrorStatus;
            using MDB3_OD_CAN2_DiscardedTxMessages = signals::MDB3_OD_CAN2_DiscardedTxMessages;
            using MDB3_OD_CAN2_Status = signals::MDB3_OD_CAN2_Status;
            using MDB3_OD_CAN2_Baudrate = signals::MDB3_OD_CAN2_Baudrate;
            using MDB3_OD_CAN2_autoErrorReset = signals::MDB3_OD_CAN2_autoErrorReset;
            using MDB3_OD_CAN2_lastErrorCode = signals::MDB3_OD_CAN2_lastErrorCode;
            using MDB3_OD_CAN2_RxErrCnt = signals::MDB3_OD_CAN2_RxErrCnt;
            using MDB3_OD_CAN2_TxErrCnt = signals::MDB3_OD_CAN2_TxErrCnt;
            using MDB3_OD_CAN1_DelayedTxMessages = signals::MDB3_OD_CAN1_DelayedTxMessages;
            using MDB3_OD_CAN1_ErrorStatus = signals::MDB3_OD_CAN1_ErrorStatus;
            using MDB3_OD_CAN1_DiscardedTxMessages = signals::MDB3_OD_CAN1_DiscardedTxMessages;
            using MDB3_OD_CAN1_Status = signals::MDB3_OD_CAN1_Status;
            using MDB3_OD_CAN1_Baudrate = signals::MDB3_OD_CAN1_Baudrate;
            using MDB3_OD_CAN1_autoErrorReset = signals::MDB3_OD_CAN1_autoErrorReset;
            using MDB3_OD_CAN1_lastErrorCode = signals::MDB3_OD_CAN1_lastErrorCode;
            using MDB3_OD_CAN1_RxErrCnt = signals::MDB3_OD_CAN1_RxErrCnt;
            using MDB3_OD_CAN1_TxErrCnt = signals::MDB3_OD_CAN1_TxErrCnt;
            using MDB3_OD_BuildTime = signals::MDB3_OD_BuildTime;
            using MDB3_OD_BuildDate = signals::MDB3_OD_BuildDate;
            using MDB3_OD_ChipUID2 = signals::MDB3_OD_ChipUID2;
            using MDB3_OD_ChipUID1 = signals::MDB3_OD_ChipUID1;
            using MDB3_OD_SdcOut = signals::MDB3_OD_SdcOut;
            using MDB3_OD_SdcIn = signals::MDB3_OD_SdcIn;
            using MDB3_OD_runtime = signals::MDB3_OD_runtime;
            using MDB3_OD_InputVoltage = signals::MDB3_OD_InputVoltage;
            using MDB3_OD_BoardTemp = signals::MDB3_OD_BoardTemp;
            using MDB3_OD_MemFree = signals::MDB3_OD_MemFree;
            using MDB3_OD_CpuUsage = signals::MDB3_OD_CpuUsage;
            using MDB3_OD_OdEntrySendInterval = signals::MDB3_OD_OdEntrySendInterval;
            using MDB3_OD_SendOdOnBootup = signals::MDB3_OD_SendOdOnBootup;
            using MDB3_OD_HeartbeatInterval = signals::MDB3_OD_HeartbeatInterval;
            using MDB3_OD_DbcVersion = signals::MDB3_OD_DbcVersion;
            using MDB3_OD_StackVersion = signals::MDB3_OD_StackVersion;
            using MDB3_OD_ProtocolVersion = signals::MDB3_OD_ProtocolVersion;
            using MDB3_OD_NodeStatus = signals::MDB3_OD_NodeStatus;
            using MDB3_OD_NodeID = signals::MDB3_OD_NodeID;

            // Attributes of message 'MDB3_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x627;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB3_SDO_ID = signals::MDB3_SDO_ID;

            // Attributes of message 'MDB3_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_Heartbeat {
            public:
            constexpr static uint32_t id = 0x727;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB3_NodeState = signals::MDB3_NodeState;

            // Attributes of message 'MDB3_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_BTL_TX {
            public:
            constexpr static uint32_t id = 0x767;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB3_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7A7;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB3_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_EMCY {
            public:
            constexpr static uint32_t id = 0xA8;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB4_W0_OtherWarning = signals::MDB4_W0_OtherWarning;
            using MDB4_E0_OtherError = signals::MDB4_E0_OtherError;

            // Attributes of message 'MDB4_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1A8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1E8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x228;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x268;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2A8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2E8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x328;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x368;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3A8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3E8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x428;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x468;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4A8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4E8;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x528;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x568;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5A8;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB4_SDO_ID = signals::MDB4_SDO_ID;
            using MDB4_SDO_RespCode = signals::MDB4_SDO_RespCode;
            using MDB4_OD_CAN2_DelayedTxMessages = signals::MDB4_OD_CAN2_DelayedTxMessages;
            using MDB4_OD_CAN2_ErrorStatus = signals::MDB4_OD_CAN2_ErrorStatus;
            using MDB4_OD_CAN2_DiscardedTxMessages = signals::MDB4_OD_CAN2_DiscardedTxMessages;
            using MDB4_OD_CAN2_Status = signals::MDB4_OD_CAN2_Status;
            using MDB4_OD_CAN2_Baudrate = signals::MDB4_OD_CAN2_Baudrate;
            using MDB4_OD_CAN2_autoErrorReset = signals::MDB4_OD_CAN2_autoErrorReset;
            using MDB4_OD_CAN2_lastErrorCode = signals::MDB4_OD_CAN2_lastErrorCode;
            using MDB4_OD_CAN2_RxErrCnt = signals::MDB4_OD_CAN2_RxErrCnt;
            using MDB4_OD_CAN2_TxErrCnt = signals::MDB4_OD_CAN2_TxErrCnt;
            using MDB4_OD_CAN1_DelayedTxMessages = signals::MDB4_OD_CAN1_DelayedTxMessages;
            using MDB4_OD_CAN1_ErrorStatus = signals::MDB4_OD_CAN1_ErrorStatus;
            using MDB4_OD_CAN1_DiscardedTxMessages = signals::MDB4_OD_CAN1_DiscardedTxMessages;
            using MDB4_OD_CAN1_Status = signals::MDB4_OD_CAN1_Status;
            using MDB4_OD_CAN1_Baudrate = signals::MDB4_OD_CAN1_Baudrate;
            using MDB4_OD_CAN1_autoErrorReset = signals::MDB4_OD_CAN1_autoErrorReset;
            using MDB4_OD_CAN1_lastErrorCode = signals::MDB4_OD_CAN1_lastErrorCode;
            using MDB4_OD_CAN1_RxErrCnt = signals::MDB4_OD_CAN1_RxErrCnt;
            using MDB4_OD_CAN1_TxErrCnt = signals::MDB4_OD_CAN1_TxErrCnt;
            using MDB4_OD_BuildTime = signals::MDB4_OD_BuildTime;
            using MDB4_OD_BuildDate = signals::MDB4_OD_BuildDate;
            using MDB4_OD_ChipUID2 = signals::MDB4_OD_ChipUID2;
            using MDB4_OD_ChipUID1 = signals::MDB4_OD_ChipUID1;
            using MDB4_OD_SdcOut = signals::MDB4_OD_SdcOut;
            using MDB4_OD_SdcIn = signals::MDB4_OD_SdcIn;
            using MDB4_OD_runtime = signals::MDB4_OD_runtime;
            using MDB4_OD_InputVoltage = signals::MDB4_OD_InputVoltage;
            using MDB4_OD_BoardTemp = signals::MDB4_OD_BoardTemp;
            using MDB4_OD_MemFree = signals::MDB4_OD_MemFree;
            using MDB4_OD_CpuUsage = signals::MDB4_OD_CpuUsage;
            using MDB4_OD_OdEntrySendInterval = signals::MDB4_OD_OdEntrySendInterval;
            using MDB4_OD_SendOdOnBootup = signals::MDB4_OD_SendOdOnBootup;
            using MDB4_OD_HeartbeatInterval = signals::MDB4_OD_HeartbeatInterval;
            using MDB4_OD_DbcVersion = signals::MDB4_OD_DbcVersion;
            using MDB4_OD_StackVersion = signals::MDB4_OD_StackVersion;
            using MDB4_OD_ProtocolVersion = signals::MDB4_OD_ProtocolVersion;
            using MDB4_OD_NodeStatus = signals::MDB4_OD_NodeStatus;
            using MDB4_OD_NodeID = signals::MDB4_OD_NodeID;

            // Attributes of message 'MDB4_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5E8;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB4_SDO_ID = signals::MDB4_SDO_ID;
            using MDB4_OD_CAN2_DelayedTxMessages = signals::MDB4_OD_CAN2_DelayedTxMessages;
            using MDB4_OD_CAN2_ErrorStatus = signals::MDB4_OD_CAN2_ErrorStatus;
            using MDB4_OD_CAN2_DiscardedTxMessages = signals::MDB4_OD_CAN2_DiscardedTxMessages;
            using MDB4_OD_CAN2_Status = signals::MDB4_OD_CAN2_Status;
            using MDB4_OD_CAN2_Baudrate = signals::MDB4_OD_CAN2_Baudrate;
            using MDB4_OD_CAN2_autoErrorReset = signals::MDB4_OD_CAN2_autoErrorReset;
            using MDB4_OD_CAN2_lastErrorCode = signals::MDB4_OD_CAN2_lastErrorCode;
            using MDB4_OD_CAN2_RxErrCnt = signals::MDB4_OD_CAN2_RxErrCnt;
            using MDB4_OD_CAN2_TxErrCnt = signals::MDB4_OD_CAN2_TxErrCnt;
            using MDB4_OD_CAN1_DelayedTxMessages = signals::MDB4_OD_CAN1_DelayedTxMessages;
            using MDB4_OD_CAN1_ErrorStatus = signals::MDB4_OD_CAN1_ErrorStatus;
            using MDB4_OD_CAN1_DiscardedTxMessages = signals::MDB4_OD_CAN1_DiscardedTxMessages;
            using MDB4_OD_CAN1_Status = signals::MDB4_OD_CAN1_Status;
            using MDB4_OD_CAN1_Baudrate = signals::MDB4_OD_CAN1_Baudrate;
            using MDB4_OD_CAN1_autoErrorReset = signals::MDB4_OD_CAN1_autoErrorReset;
            using MDB4_OD_CAN1_lastErrorCode = signals::MDB4_OD_CAN1_lastErrorCode;
            using MDB4_OD_CAN1_RxErrCnt = signals::MDB4_OD_CAN1_RxErrCnt;
            using MDB4_OD_CAN1_TxErrCnt = signals::MDB4_OD_CAN1_TxErrCnt;
            using MDB4_OD_BuildTime = signals::MDB4_OD_BuildTime;
            using MDB4_OD_BuildDate = signals::MDB4_OD_BuildDate;
            using MDB4_OD_ChipUID2 = signals::MDB4_OD_ChipUID2;
            using MDB4_OD_ChipUID1 = signals::MDB4_OD_ChipUID1;
            using MDB4_OD_SdcOut = signals::MDB4_OD_SdcOut;
            using MDB4_OD_SdcIn = signals::MDB4_OD_SdcIn;
            using MDB4_OD_runtime = signals::MDB4_OD_runtime;
            using MDB4_OD_InputVoltage = signals::MDB4_OD_InputVoltage;
            using MDB4_OD_BoardTemp = signals::MDB4_OD_BoardTemp;
            using MDB4_OD_MemFree = signals::MDB4_OD_MemFree;
            using MDB4_OD_CpuUsage = signals::MDB4_OD_CpuUsage;
            using MDB4_OD_OdEntrySendInterval = signals::MDB4_OD_OdEntrySendInterval;
            using MDB4_OD_SendOdOnBootup = signals::MDB4_OD_SendOdOnBootup;
            using MDB4_OD_HeartbeatInterval = signals::MDB4_OD_HeartbeatInterval;
            using MDB4_OD_DbcVersion = signals::MDB4_OD_DbcVersion;
            using MDB4_OD_StackVersion = signals::MDB4_OD_StackVersion;
            using MDB4_OD_ProtocolVersion = signals::MDB4_OD_ProtocolVersion;
            using MDB4_OD_NodeStatus = signals::MDB4_OD_NodeStatus;
            using MDB4_OD_NodeID = signals::MDB4_OD_NodeID;

            // Attributes of message 'MDB4_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x628;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB4_SDO_ID = signals::MDB4_SDO_ID;

            // Attributes of message 'MDB4_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_Heartbeat {
            public:
            constexpr static uint32_t id = 0x728;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB4_NodeState = signals::MDB4_NodeState;

            // Attributes of message 'MDB4_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_BTL_TX {
            public:
            constexpr static uint32_t id = 0x768;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB4_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7A8;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB4_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_EMCY {
            public:
            constexpr static uint32_t id = 0xA9;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB5_W0_OtherWarning = signals::MDB5_W0_OtherWarning;
            using MDB5_E0_OtherError = signals::MDB5_E0_OtherError;

            // Attributes of message 'MDB5_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1A9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1E9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x229;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x269;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2A9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2E9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x329;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x369;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3A9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3E9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x429;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x469;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4A9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4E9;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x529;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x569;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5A9;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB5_SDO_ID = signals::MDB5_SDO_ID;
            using MDB5_SDO_RespCode = signals::MDB5_SDO_RespCode;
            using MDB5_OD_CAN2_DelayedTxMessages = signals::MDB5_OD_CAN2_DelayedTxMessages;
            using MDB5_OD_CAN2_ErrorStatus = signals::MDB5_OD_CAN2_ErrorStatus;
            using MDB5_OD_CAN2_DiscardedTxMessages = signals::MDB5_OD_CAN2_DiscardedTxMessages;
            using MDB5_OD_CAN2_Status = signals::MDB5_OD_CAN2_Status;
            using MDB5_OD_CAN2_Baudrate = signals::MDB5_OD_CAN2_Baudrate;
            using MDB5_OD_CAN2_autoErrorReset = signals::MDB5_OD_CAN2_autoErrorReset;
            using MDB5_OD_CAN2_lastErrorCode = signals::MDB5_OD_CAN2_lastErrorCode;
            using MDB5_OD_CAN2_RxErrCnt = signals::MDB5_OD_CAN2_RxErrCnt;
            using MDB5_OD_CAN2_TxErrCnt = signals::MDB5_OD_CAN2_TxErrCnt;
            using MDB5_OD_CAN1_DelayedTxMessages = signals::MDB5_OD_CAN1_DelayedTxMessages;
            using MDB5_OD_CAN1_ErrorStatus = signals::MDB5_OD_CAN1_ErrorStatus;
            using MDB5_OD_CAN1_DiscardedTxMessages = signals::MDB5_OD_CAN1_DiscardedTxMessages;
            using MDB5_OD_CAN1_Status = signals::MDB5_OD_CAN1_Status;
            using MDB5_OD_CAN1_Baudrate = signals::MDB5_OD_CAN1_Baudrate;
            using MDB5_OD_CAN1_autoErrorReset = signals::MDB5_OD_CAN1_autoErrorReset;
            using MDB5_OD_CAN1_lastErrorCode = signals::MDB5_OD_CAN1_lastErrorCode;
            using MDB5_OD_CAN1_RxErrCnt = signals::MDB5_OD_CAN1_RxErrCnt;
            using MDB5_OD_CAN1_TxErrCnt = signals::MDB5_OD_CAN1_TxErrCnt;
            using MDB5_OD_BuildTime = signals::MDB5_OD_BuildTime;
            using MDB5_OD_BuildDate = signals::MDB5_OD_BuildDate;
            using MDB5_OD_ChipUID2 = signals::MDB5_OD_ChipUID2;
            using MDB5_OD_ChipUID1 = signals::MDB5_OD_ChipUID1;
            using MDB5_OD_SdcOut = signals::MDB5_OD_SdcOut;
            using MDB5_OD_SdcIn = signals::MDB5_OD_SdcIn;
            using MDB5_OD_runtime = signals::MDB5_OD_runtime;
            using MDB5_OD_InputVoltage = signals::MDB5_OD_InputVoltage;
            using MDB5_OD_BoardTemp = signals::MDB5_OD_BoardTemp;
            using MDB5_OD_MemFree = signals::MDB5_OD_MemFree;
            using MDB5_OD_CpuUsage = signals::MDB5_OD_CpuUsage;
            using MDB5_OD_OdEntrySendInterval = signals::MDB5_OD_OdEntrySendInterval;
            using MDB5_OD_SendOdOnBootup = signals::MDB5_OD_SendOdOnBootup;
            using MDB5_OD_HeartbeatInterval = signals::MDB5_OD_HeartbeatInterval;
            using MDB5_OD_DbcVersion = signals::MDB5_OD_DbcVersion;
            using MDB5_OD_StackVersion = signals::MDB5_OD_StackVersion;
            using MDB5_OD_ProtocolVersion = signals::MDB5_OD_ProtocolVersion;
            using MDB5_OD_NodeStatus = signals::MDB5_OD_NodeStatus;
            using MDB5_OD_NodeID = signals::MDB5_OD_NodeID;

            // Attributes of message 'MDB5_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5E9;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB5_SDO_ID = signals::MDB5_SDO_ID;
            using MDB5_OD_CAN2_DelayedTxMessages = signals::MDB5_OD_CAN2_DelayedTxMessages;
            using MDB5_OD_CAN2_ErrorStatus = signals::MDB5_OD_CAN2_ErrorStatus;
            using MDB5_OD_CAN2_DiscardedTxMessages = signals::MDB5_OD_CAN2_DiscardedTxMessages;
            using MDB5_OD_CAN2_Status = signals::MDB5_OD_CAN2_Status;
            using MDB5_OD_CAN2_Baudrate = signals::MDB5_OD_CAN2_Baudrate;
            using MDB5_OD_CAN2_autoErrorReset = signals::MDB5_OD_CAN2_autoErrorReset;
            using MDB5_OD_CAN2_lastErrorCode = signals::MDB5_OD_CAN2_lastErrorCode;
            using MDB5_OD_CAN2_RxErrCnt = signals::MDB5_OD_CAN2_RxErrCnt;
            using MDB5_OD_CAN2_TxErrCnt = signals::MDB5_OD_CAN2_TxErrCnt;
            using MDB5_OD_CAN1_DelayedTxMessages = signals::MDB5_OD_CAN1_DelayedTxMessages;
            using MDB5_OD_CAN1_ErrorStatus = signals::MDB5_OD_CAN1_ErrorStatus;
            using MDB5_OD_CAN1_DiscardedTxMessages = signals::MDB5_OD_CAN1_DiscardedTxMessages;
            using MDB5_OD_CAN1_Status = signals::MDB5_OD_CAN1_Status;
            using MDB5_OD_CAN1_Baudrate = signals::MDB5_OD_CAN1_Baudrate;
            using MDB5_OD_CAN1_autoErrorReset = signals::MDB5_OD_CAN1_autoErrorReset;
            using MDB5_OD_CAN1_lastErrorCode = signals::MDB5_OD_CAN1_lastErrorCode;
            using MDB5_OD_CAN1_RxErrCnt = signals::MDB5_OD_CAN1_RxErrCnt;
            using MDB5_OD_CAN1_TxErrCnt = signals::MDB5_OD_CAN1_TxErrCnt;
            using MDB5_OD_BuildTime = signals::MDB5_OD_BuildTime;
            using MDB5_OD_BuildDate = signals::MDB5_OD_BuildDate;
            using MDB5_OD_ChipUID2 = signals::MDB5_OD_ChipUID2;
            using MDB5_OD_ChipUID1 = signals::MDB5_OD_ChipUID1;
            using MDB5_OD_SdcOut = signals::MDB5_OD_SdcOut;
            using MDB5_OD_SdcIn = signals::MDB5_OD_SdcIn;
            using MDB5_OD_runtime = signals::MDB5_OD_runtime;
            using MDB5_OD_InputVoltage = signals::MDB5_OD_InputVoltage;
            using MDB5_OD_BoardTemp = signals::MDB5_OD_BoardTemp;
            using MDB5_OD_MemFree = signals::MDB5_OD_MemFree;
            using MDB5_OD_CpuUsage = signals::MDB5_OD_CpuUsage;
            using MDB5_OD_OdEntrySendInterval = signals::MDB5_OD_OdEntrySendInterval;
            using MDB5_OD_SendOdOnBootup = signals::MDB5_OD_SendOdOnBootup;
            using MDB5_OD_HeartbeatInterval = signals::MDB5_OD_HeartbeatInterval;
            using MDB5_OD_DbcVersion = signals::MDB5_OD_DbcVersion;
            using MDB5_OD_StackVersion = signals::MDB5_OD_StackVersion;
            using MDB5_OD_ProtocolVersion = signals::MDB5_OD_ProtocolVersion;
            using MDB5_OD_NodeStatus = signals::MDB5_OD_NodeStatus;
            using MDB5_OD_NodeID = signals::MDB5_OD_NodeID;

            // Attributes of message 'MDB5_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x629;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB5_SDO_ID = signals::MDB5_SDO_ID;

            // Attributes of message 'MDB5_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_Heartbeat {
            public:
            constexpr static uint32_t id = 0x729;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB5_NodeState = signals::MDB5_NodeState;

            // Attributes of message 'MDB5_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_BTL_TX {
            public:
            constexpr static uint32_t id = 0x769;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB5_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7A9;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB5_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_EMCY {
            public:
            constexpr static uint32_t id = 0xB1;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB6_W0_OtherWarning = signals::MDB6_W0_OtherWarning;
            using MDB6_E0_OtherError = signals::MDB6_E0_OtherError;

            // Attributes of message 'MDB6_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1B1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1F1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x231;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x271;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2B1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2F1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x331;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x371;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3B1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3F1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x431;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x471;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4B1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4F1;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x531;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x571;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5B1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB6_SDO_ID = signals::MDB6_SDO_ID;
            using MDB6_SDO_RespCode = signals::MDB6_SDO_RespCode;
            using MDB6_OD_CAN2_DelayedTxMessages = signals::MDB6_OD_CAN2_DelayedTxMessages;
            using MDB6_OD_CAN2_ErrorStatus = signals::MDB6_OD_CAN2_ErrorStatus;
            using MDB6_OD_CAN2_DiscardedTxMessages = signals::MDB6_OD_CAN2_DiscardedTxMessages;
            using MDB6_OD_CAN2_Status = signals::MDB6_OD_CAN2_Status;
            using MDB6_OD_CAN2_Baudrate = signals::MDB6_OD_CAN2_Baudrate;
            using MDB6_OD_CAN2_autoErrorReset = signals::MDB6_OD_CAN2_autoErrorReset;
            using MDB6_OD_CAN2_lastErrorCode = signals::MDB6_OD_CAN2_lastErrorCode;
            using MDB6_OD_CAN2_RxErrCnt = signals::MDB6_OD_CAN2_RxErrCnt;
            using MDB6_OD_CAN2_TxErrCnt = signals::MDB6_OD_CAN2_TxErrCnt;
            using MDB6_OD_CAN1_DelayedTxMessages = signals::MDB6_OD_CAN1_DelayedTxMessages;
            using MDB6_OD_CAN1_ErrorStatus = signals::MDB6_OD_CAN1_ErrorStatus;
            using MDB6_OD_CAN1_DiscardedTxMessages = signals::MDB6_OD_CAN1_DiscardedTxMessages;
            using MDB6_OD_CAN1_Status = signals::MDB6_OD_CAN1_Status;
            using MDB6_OD_CAN1_Baudrate = signals::MDB6_OD_CAN1_Baudrate;
            using MDB6_OD_CAN1_autoErrorReset = signals::MDB6_OD_CAN1_autoErrorReset;
            using MDB6_OD_CAN1_lastErrorCode = signals::MDB6_OD_CAN1_lastErrorCode;
            using MDB6_OD_CAN1_RxErrCnt = signals::MDB6_OD_CAN1_RxErrCnt;
            using MDB6_OD_CAN1_TxErrCnt = signals::MDB6_OD_CAN1_TxErrCnt;
            using MDB6_OD_BuildTime = signals::MDB6_OD_BuildTime;
            using MDB6_OD_BuildDate = signals::MDB6_OD_BuildDate;
            using MDB6_OD_ChipUID2 = signals::MDB6_OD_ChipUID2;
            using MDB6_OD_ChipUID1 = signals::MDB6_OD_ChipUID1;
            using MDB6_OD_SdcOut = signals::MDB6_OD_SdcOut;
            using MDB6_OD_SdcIn = signals::MDB6_OD_SdcIn;
            using MDB6_OD_runtime = signals::MDB6_OD_runtime;
            using MDB6_OD_InputVoltage = signals::MDB6_OD_InputVoltage;
            using MDB6_OD_BoardTemp = signals::MDB6_OD_BoardTemp;
            using MDB6_OD_MemFree = signals::MDB6_OD_MemFree;
            using MDB6_OD_CpuUsage = signals::MDB6_OD_CpuUsage;
            using MDB6_OD_OdEntrySendInterval = signals::MDB6_OD_OdEntrySendInterval;
            using MDB6_OD_SendOdOnBootup = signals::MDB6_OD_SendOdOnBootup;
            using MDB6_OD_HeartbeatInterval = signals::MDB6_OD_HeartbeatInterval;
            using MDB6_OD_DbcVersion = signals::MDB6_OD_DbcVersion;
            using MDB6_OD_StackVersion = signals::MDB6_OD_StackVersion;
            using MDB6_OD_ProtocolVersion = signals::MDB6_OD_ProtocolVersion;
            using MDB6_OD_NodeStatus = signals::MDB6_OD_NodeStatus;
            using MDB6_OD_NodeID = signals::MDB6_OD_NodeID;

            // Attributes of message 'MDB6_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5F1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB6_SDO_ID = signals::MDB6_SDO_ID;
            using MDB6_OD_CAN2_DelayedTxMessages = signals::MDB6_OD_CAN2_DelayedTxMessages;
            using MDB6_OD_CAN2_ErrorStatus = signals::MDB6_OD_CAN2_ErrorStatus;
            using MDB6_OD_CAN2_DiscardedTxMessages = signals::MDB6_OD_CAN2_DiscardedTxMessages;
            using MDB6_OD_CAN2_Status = signals::MDB6_OD_CAN2_Status;
            using MDB6_OD_CAN2_Baudrate = signals::MDB6_OD_CAN2_Baudrate;
            using MDB6_OD_CAN2_autoErrorReset = signals::MDB6_OD_CAN2_autoErrorReset;
            using MDB6_OD_CAN2_lastErrorCode = signals::MDB6_OD_CAN2_lastErrorCode;
            using MDB6_OD_CAN2_RxErrCnt = signals::MDB6_OD_CAN2_RxErrCnt;
            using MDB6_OD_CAN2_TxErrCnt = signals::MDB6_OD_CAN2_TxErrCnt;
            using MDB6_OD_CAN1_DelayedTxMessages = signals::MDB6_OD_CAN1_DelayedTxMessages;
            using MDB6_OD_CAN1_ErrorStatus = signals::MDB6_OD_CAN1_ErrorStatus;
            using MDB6_OD_CAN1_DiscardedTxMessages = signals::MDB6_OD_CAN1_DiscardedTxMessages;
            using MDB6_OD_CAN1_Status = signals::MDB6_OD_CAN1_Status;
            using MDB6_OD_CAN1_Baudrate = signals::MDB6_OD_CAN1_Baudrate;
            using MDB6_OD_CAN1_autoErrorReset = signals::MDB6_OD_CAN1_autoErrorReset;
            using MDB6_OD_CAN1_lastErrorCode = signals::MDB6_OD_CAN1_lastErrorCode;
            using MDB6_OD_CAN1_RxErrCnt = signals::MDB6_OD_CAN1_RxErrCnt;
            using MDB6_OD_CAN1_TxErrCnt = signals::MDB6_OD_CAN1_TxErrCnt;
            using MDB6_OD_BuildTime = signals::MDB6_OD_BuildTime;
            using MDB6_OD_BuildDate = signals::MDB6_OD_BuildDate;
            using MDB6_OD_ChipUID2 = signals::MDB6_OD_ChipUID2;
            using MDB6_OD_ChipUID1 = signals::MDB6_OD_ChipUID1;
            using MDB6_OD_SdcOut = signals::MDB6_OD_SdcOut;
            using MDB6_OD_SdcIn = signals::MDB6_OD_SdcIn;
            using MDB6_OD_runtime = signals::MDB6_OD_runtime;
            using MDB6_OD_InputVoltage = signals::MDB6_OD_InputVoltage;
            using MDB6_OD_BoardTemp = signals::MDB6_OD_BoardTemp;
            using MDB6_OD_MemFree = signals::MDB6_OD_MemFree;
            using MDB6_OD_CpuUsage = signals::MDB6_OD_CpuUsage;
            using MDB6_OD_OdEntrySendInterval = signals::MDB6_OD_OdEntrySendInterval;
            using MDB6_OD_SendOdOnBootup = signals::MDB6_OD_SendOdOnBootup;
            using MDB6_OD_HeartbeatInterval = signals::MDB6_OD_HeartbeatInterval;
            using MDB6_OD_DbcVersion = signals::MDB6_OD_DbcVersion;
            using MDB6_OD_StackVersion = signals::MDB6_OD_StackVersion;
            using MDB6_OD_ProtocolVersion = signals::MDB6_OD_ProtocolVersion;
            using MDB6_OD_NodeStatus = signals::MDB6_OD_NodeStatus;
            using MDB6_OD_NodeID = signals::MDB6_OD_NodeID;

            // Attributes of message 'MDB6_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x631;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB6_SDO_ID = signals::MDB6_SDO_ID;

            // Attributes of message 'MDB6_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_Heartbeat {
            public:
            constexpr static uint32_t id = 0x731;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using MDB6_NodeState = signals::MDB6_NodeState;

            // Attributes of message 'MDB6_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_BTL_TX {
            public:
            constexpr static uint32_t id = 0x771;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class MDB6_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7B1;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'MDB6_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_EMCY {
            public:
            constexpr static uint32_t id = 0xB2;
            constexpr static uint8_t dlc = 4;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_W0_OtherWarning = signals::Track_W0_OtherWarning;
            using Track_E0_OtherError = signals::Track_E0_OtherError;

            // Attributes of message 'Track_EMCY'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1B2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_RX_PDO1 {
            public:
            constexpr static uint32_t id = 0x1F2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_RX_PDO1'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO2 {
            public:
            constexpr static uint32_t id = 0x232;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_RX_PDO2 {
            public:
            constexpr static uint32_t id = 0x272;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_RX_PDO2'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2B2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_RX_PDO3 {
            public:
            constexpr static uint32_t id = 0x2F2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_RX_PDO3'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO4 {
            public:
            constexpr static uint32_t id = 0x332;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_RX_PDO4 {
            public:
            constexpr static uint32_t id = 0x372;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_RX_PDO4'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO5 {
            public:
            constexpr static uint32_t id = 0x3B2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO5'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO6 {
            public:
            constexpr static uint32_t id = 0x3F2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO6'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO7 {
            public:
            constexpr static uint32_t id = 0x432;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO7'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO8 {
            public:
            constexpr static uint32_t id = 0x472;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO8'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO9 {
            public:
            constexpr static uint32_t id = 0x4B2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO9'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO10 {
            public:
            constexpr static uint32_t id = 0x4F2;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO10'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO11 {
            public:
            constexpr static uint32_t id = 0x532;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO11'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_TX_PDO12 {
            public:
            constexpr static uint32_t id = 0x572;
            constexpr static uint8_t dlc = 0;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_TX_PDO12'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_SDO_Resp {
            public:
            constexpr static uint32_t id = 0x5B2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_SDO_ID = signals::Track_SDO_ID;
            using Track_SDO_RespCode = signals::Track_SDO_RespCode;
            using Track_OD_CAN2_DelayedTxMessages = signals::Track_OD_CAN2_DelayedTxMessages;
            using Track_OD_CAN2_ErrorStatus = signals::Track_OD_CAN2_ErrorStatus;
            using Track_OD_CAN2_DiscardedTxMessages = signals::Track_OD_CAN2_DiscardedTxMessages;
            using Track_OD_CAN2_Status = signals::Track_OD_CAN2_Status;
            using Track_OD_CAN2_Baudrate = signals::Track_OD_CAN2_Baudrate;
            using Track_OD_CAN2_autoErrorReset = signals::Track_OD_CAN2_autoErrorReset;
            using Track_OD_CAN2_lastErrorCode = signals::Track_OD_CAN2_lastErrorCode;
            using Track_OD_CAN2_RxErrCnt = signals::Track_OD_CAN2_RxErrCnt;
            using Track_OD_CAN2_TxErrCnt = signals::Track_OD_CAN2_TxErrCnt;
            using Track_OD_CAN1_DelayedTxMessages = signals::Track_OD_CAN1_DelayedTxMessages;
            using Track_OD_CAN1_ErrorStatus = signals::Track_OD_CAN1_ErrorStatus;
            using Track_OD_CAN1_DiscardedTxMessages = signals::Track_OD_CAN1_DiscardedTxMessages;
            using Track_OD_CAN1_Status = signals::Track_OD_CAN1_Status;
            using Track_OD_CAN1_Baudrate = signals::Track_OD_CAN1_Baudrate;
            using Track_OD_CAN1_autoErrorReset = signals::Track_OD_CAN1_autoErrorReset;
            using Track_OD_CAN1_lastErrorCode = signals::Track_OD_CAN1_lastErrorCode;
            using Track_OD_CAN1_RxErrCnt = signals::Track_OD_CAN1_RxErrCnt;
            using Track_OD_CAN1_TxErrCnt = signals::Track_OD_CAN1_TxErrCnt;
            using Track_OD_BuildTime = signals::Track_OD_BuildTime;
            using Track_OD_BuildDate = signals::Track_OD_BuildDate;
            using Track_OD_ChipUID2 = signals::Track_OD_ChipUID2;
            using Track_OD_ChipUID1 = signals::Track_OD_ChipUID1;
            using Track_OD_SdcOut = signals::Track_OD_SdcOut;
            using Track_OD_SdcIn = signals::Track_OD_SdcIn;
            using Track_OD_runtime = signals::Track_OD_runtime;
            using Track_OD_InputVoltage = signals::Track_OD_InputVoltage;
            using Track_OD_BoardTemp = signals::Track_OD_BoardTemp;
            using Track_OD_MemFree = signals::Track_OD_MemFree;
            using Track_OD_CpuUsage = signals::Track_OD_CpuUsage;
            using Track_OD_OdEntrySendInterval = signals::Track_OD_OdEntrySendInterval;
            using Track_OD_SendOdOnBootup = signals::Track_OD_SendOdOnBootup;
            using Track_OD_HeartbeatInterval = signals::Track_OD_HeartbeatInterval;
            using Track_OD_DbcVersion = signals::Track_OD_DbcVersion;
            using Track_OD_StackVersion = signals::Track_OD_StackVersion;
            using Track_OD_ProtocolVersion = signals::Track_OD_ProtocolVersion;
            using Track_OD_NodeStatus = signals::Track_OD_NodeStatus;
            using Track_OD_NodeID = signals::Track_OD_NodeID;

            // Attributes of message 'Track_SDO_Resp'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_SDO_Req_Up {
            public:
            constexpr static uint32_t id = 0x5F2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_SDO_ID = signals::Track_SDO_ID;
            using Track_OD_CAN2_DelayedTxMessages = signals::Track_OD_CAN2_DelayedTxMessages;
            using Track_OD_CAN2_ErrorStatus = signals::Track_OD_CAN2_ErrorStatus;
            using Track_OD_CAN2_DiscardedTxMessages = signals::Track_OD_CAN2_DiscardedTxMessages;
            using Track_OD_CAN2_Status = signals::Track_OD_CAN2_Status;
            using Track_OD_CAN2_Baudrate = signals::Track_OD_CAN2_Baudrate;
            using Track_OD_CAN2_autoErrorReset = signals::Track_OD_CAN2_autoErrorReset;
            using Track_OD_CAN2_lastErrorCode = signals::Track_OD_CAN2_lastErrorCode;
            using Track_OD_CAN2_RxErrCnt = signals::Track_OD_CAN2_RxErrCnt;
            using Track_OD_CAN2_TxErrCnt = signals::Track_OD_CAN2_TxErrCnt;
            using Track_OD_CAN1_DelayedTxMessages = signals::Track_OD_CAN1_DelayedTxMessages;
            using Track_OD_CAN1_ErrorStatus = signals::Track_OD_CAN1_ErrorStatus;
            using Track_OD_CAN1_DiscardedTxMessages = signals::Track_OD_CAN1_DiscardedTxMessages;
            using Track_OD_CAN1_Status = signals::Track_OD_CAN1_Status;
            using Track_OD_CAN1_Baudrate = signals::Track_OD_CAN1_Baudrate;
            using Track_OD_CAN1_autoErrorReset = signals::Track_OD_CAN1_autoErrorReset;
            using Track_OD_CAN1_lastErrorCode = signals::Track_OD_CAN1_lastErrorCode;
            using Track_OD_CAN1_RxErrCnt = signals::Track_OD_CAN1_RxErrCnt;
            using Track_OD_CAN1_TxErrCnt = signals::Track_OD_CAN1_TxErrCnt;
            using Track_OD_BuildTime = signals::Track_OD_BuildTime;
            using Track_OD_BuildDate = signals::Track_OD_BuildDate;
            using Track_OD_ChipUID2 = signals::Track_OD_ChipUID2;
            using Track_OD_ChipUID1 = signals::Track_OD_ChipUID1;
            using Track_OD_SdcOut = signals::Track_OD_SdcOut;
            using Track_OD_SdcIn = signals::Track_OD_SdcIn;
            using Track_OD_runtime = signals::Track_OD_runtime;
            using Track_OD_InputVoltage = signals::Track_OD_InputVoltage;
            using Track_OD_BoardTemp = signals::Track_OD_BoardTemp;
            using Track_OD_MemFree = signals::Track_OD_MemFree;
            using Track_OD_CpuUsage = signals::Track_OD_CpuUsage;
            using Track_OD_OdEntrySendInterval = signals::Track_OD_OdEntrySendInterval;
            using Track_OD_SendOdOnBootup = signals::Track_OD_SendOdOnBootup;
            using Track_OD_HeartbeatInterval = signals::Track_OD_HeartbeatInterval;
            using Track_OD_DbcVersion = signals::Track_OD_DbcVersion;
            using Track_OD_StackVersion = signals::Track_OD_StackVersion;
            using Track_OD_ProtocolVersion = signals::Track_OD_ProtocolVersion;
            using Track_OD_NodeStatus = signals::Track_OD_NodeStatus;
            using Track_OD_NodeID = signals::Track_OD_NodeID;

            // Attributes of message 'Track_SDO_Req_Up'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_SDO_Req_Down {
            public:
            constexpr static uint32_t id = 0x632;
            constexpr static uint8_t dlc = 2;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_SDO_ID = signals::Track_SDO_ID;

            // Attributes of message 'Track_SDO_Req_Down'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_Heartbeat {
            public:
            constexpr static uint32_t id = 0x732;
            constexpr static uint8_t dlc = 1;
            constexpr static bool isExtendedId = false;

            // Signals
            using Track_NodeState = signals::Track_NodeState;

            // Attributes of message 'Track_Heartbeat'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_BTL_TX {
            public:
            constexpr static uint32_t id = 0x772;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_BTL_TX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };
        class Track_BTL_RX {
            public:
            constexpr static uint32_t id = 0x7B2;
            constexpr static uint8_t dlc = 8;
            constexpr static bool isExtendedId = false;

            // Attributes of message 'Track_BTL_RX'
            constexpr static uint16_t GenMsgCycleTime = 100;
        };

        
    }
}

#endif // DBCPARSER_POD2022_HPP